---
title: 使用檢查點來重新啟動套件 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: conceptual
helpviewer_keywords:
- checkpoints [Integration Services]
- restarting packages
- starting packages
ms.assetid: 48f2fbb7-8964-484a-8311-5126cf594bfb
author: chugugrace
ms.author: chugu
ms.openlocfilehash: aa0e0e9ad1da67bfc70dec61396ab026df62d3ee
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87597192"
---
# <a name="restart-packages-by-using-checkpoints"></a><span data-ttu-id="44607-102">使用檢查點來重新啟動封裝</span><span class="sxs-lookup"><span data-stu-id="44607-102">Restart Packages by Using Checkpoints</span></span>
  [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] <span data-ttu-id="44607-103">可以從失敗點重新啟動失敗的封裝，而無需重新執行整個封裝。</span><span class="sxs-lookup"><span data-stu-id="44607-103">can restart failed packages from the point of failure, instead of rerunning the whole package.</span></span> <span data-ttu-id="44607-104">如果封裝設定為使用檢查點，則封裝執行的相關資訊會寫入檢查點檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-104">If a package is configured to use checkpoints, information about package execution is written to a checkpoint file.</span></span> <span data-ttu-id="44607-105">當失敗的封裝重新執行時，檢查點檔案會用於從失敗點重新啟動封裝。</span><span class="sxs-lookup"><span data-stu-id="44607-105">When the failed package is rerun, the checkpoint file is used to restart the package from the point of failure.</span></span> <span data-ttu-id="44607-106">如果封裝順利執行，則會刪除檢查點檔案，然後在下次封裝執行時重新建立檢查點檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-106">If the package runs successfully, the checkpoint file is deleted, and then re-created the next time the package is run.</span></span>  
  
 <span data-ttu-id="44607-107">在封裝中使用檢查點有下列優點。</span><span class="sxs-lookup"><span data-stu-id="44607-107">Using checkpoints in a package can provide the following benefits.</span></span>  
  
-   <span data-ttu-id="44607-108">避免重複下載和上傳大型檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-108">Avoid repeating the downloading and uploading of large files.</span></span> <span data-ttu-id="44607-109">例如，對每個下載使用 FTP 工作來下載多個大型檔案的封裝，在下載單一檔案失敗後可以重新啟動，然後只下載該單一檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-109">For example, a package that downloads multiple large files by using an FTP task for each download can be restarted after the downloading of a single file fails and then download only that file.</span></span>  
  
-   <span data-ttu-id="44607-110">避免重複載入大量資料。</span><span class="sxs-lookup"><span data-stu-id="44607-110">Avoid repeating the loading of large amounts of data.</span></span> <span data-ttu-id="44607-111">例如，如果封裝針對每個維度使用不同「大量插入」工作向資料倉儲中的維度資料表執行大量插入，則當一個維度資料表的插入失敗時，該封裝會重新啟動，且只重新載入該維度。</span><span class="sxs-lookup"><span data-stu-id="44607-111">For example, a package that performs bulk inserts into dimension tables in a data warehouse using a different Bulk Insert task for each dimension can be restarted if the insertion fails for one dimension table, and only that dimension will be reloaded.</span></span>  
  
-   <span data-ttu-id="44607-112">避免重複彙總值。</span><span class="sxs-lookup"><span data-stu-id="44607-112">Avoid repeating the aggregation of values.</span></span> <span data-ttu-id="44607-113">例如，使用資料流程工作執行每個彙總以計算許多彙總 (例如，平均和總和) 的封裝，可以在計算一個彙總失敗之後重新啟動，且只重新計算該彙總。</span><span class="sxs-lookup"><span data-stu-id="44607-113">For example, a package that computes many aggregates, such as averages and sums, using a separate Data Flow task to perform each aggregation, can be restarted after computing an aggregation fails and only that aggregation will be recomputed.</span></span>  
  
 <span data-ttu-id="44607-114">如果封裝設定為使用檢查點，則 [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] 會擷取檢查點檔案中的重新啟動點。</span><span class="sxs-lookup"><span data-stu-id="44607-114">If a package is configured to use checkpoints, [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] captures the restart point in the checkpoint file.</span></span> <span data-ttu-id="44607-115">失敗的容器類型和功能的實作 (例如，交易) 會影響檢查點檔案中記錄的重新啟動點。</span><span class="sxs-lookup"><span data-stu-id="44607-115">The type of container that fails and the implementation of features such as transactions affect the restart point that is recorded in the checkpoint file.</span></span> <span data-ttu-id="44607-116">檢查點檔案中也會擷取變數目前的值。</span><span class="sxs-lookup"><span data-stu-id="44607-116">The current values of variables are also captured in the checkpoint file.</span></span> <span data-ttu-id="44607-117">然而，具有 `Object` 資料類型之變數的值不會儲存於檢查點檔案中。</span><span class="sxs-lookup"><span data-stu-id="44607-117">However, the values of variables that have the `Object` data type are not saved in checkpoint files.</span></span>  
  
## <a name="defining-restart-points"></a><span data-ttu-id="44607-118">定義重新啟動點</span><span class="sxs-lookup"><span data-stu-id="44607-118">Defining Restart Points</span></span>  
 <span data-ttu-id="44607-119">封裝單一工作的工作主機容器是可以重新啟動的最小基本單位工作。</span><span class="sxs-lookup"><span data-stu-id="44607-119">The task host container, which encapsulates a single task, is the smallest atomic unit of work that can be restarted.</span></span> <span data-ttu-id="44607-120">「Foreach 迴圈」容器和交易容器也會視為最小基本單位工作。</span><span class="sxs-lookup"><span data-stu-id="44607-120">The Foreach Loop container and a transacted container are also treated as atomic units of work.</span></span>  
  
 <span data-ttu-id="44607-121">如果封裝在交易容器執行時停止，則交易會結束，且該容器執行的任何工作都會回復。</span><span class="sxs-lookup"><span data-stu-id="44607-121">If a package is stopped while a transacted container is running, the transaction ends and any work performed by the container is rolled back.</span></span> <span data-ttu-id="44607-122">當封裝重新啟動時，會重新執行失敗的容器。</span><span class="sxs-lookup"><span data-stu-id="44607-122">When the package is restarted, the container that failed is rerun.</span></span> <span data-ttu-id="44607-123">如果交易容器的任何子容器完成，則不會在檢查點檔案中記錄。</span><span class="sxs-lookup"><span data-stu-id="44607-123">The completion of any child containers of transacted container is not recorded in the checkpoint file.</span></span> <span data-ttu-id="44607-124">因此，當封裝重新啟動時，交易容器及其子容器都會重新執行。</span><span class="sxs-lookup"><span data-stu-id="44607-124">Therefore, when the package is restarted, the transacted container and its child containers run again.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="44607-125">在相同的封裝中使用檢查點與交易可能會造成非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="44607-125">Using checkpoints and transactions in the same package could cause unexpected results.</span></span> <span data-ttu-id="44607-126">例如，當封裝失敗並從檢查點重新啟動時，封裝可能會重複已經過成功認可的交易。</span><span class="sxs-lookup"><span data-stu-id="44607-126">For example, when a package fails and restarts from a checkpoint, the package might repeat a transaction that has already been successfully committed.</span></span>  
  
 <span data-ttu-id="44607-127">不會儲存 For 迴圈和 Foreach 迴圈容器的檢查點資料。</span><span class="sxs-lookup"><span data-stu-id="44607-127">Checkpoint data is not saved for For Loop and Foreach Loop containers.</span></span> <span data-ttu-id="44607-128">當封裝重新啟動時，For 迴圈和 Foreach 迴圈容器及其子容器會再次執行。</span><span class="sxs-lookup"><span data-stu-id="44607-128">When a package is restarted, the For Loop and Foreach Loop containers and the child containers are run again.</span></span> <span data-ttu-id="44607-129">如果迴圈中的子容器順利執行，則不會在檢查點檔案中記錄它，而是重新執行。</span><span class="sxs-lookup"><span data-stu-id="44607-129">If a child container in the loop runs successfully, it is not recorded in the checkpoint file, instead it is rerun.</span></span> <span data-ttu-id="44607-130">如需詳細資訊和因應措施，請參閱 [For 迴圈或 Foreach 迴圈容器項目都不接受 SSIS 檢查點](https://go.microsoft.com/fwlink/?LinkId=241633)。</span><span class="sxs-lookup"><span data-stu-id="44607-130">For more information and a workaround, see [SSIS Checkpoints are not honored for For Loop or Foreach Loop container items](https://go.microsoft.com/fwlink/?LinkId=241633).</span></span>  
  
 <span data-ttu-id="44607-131">如果封裝重新啟動，則不會重新載入封裝組態，該封裝會使用寫入檢查點檔案的組態資訊。</span><span class="sxs-lookup"><span data-stu-id="44607-131">If the package is restarted the package configurations are not reloaded, instead the package uses the configuration information written to the checkpoint file.</span></span> <span data-ttu-id="44607-132">這會確保封裝在重新執行時使用與其失敗時相同的組態。</span><span class="sxs-lookup"><span data-stu-id="44607-132">This ensures that the package uses the same configurations when it is rerun as the time it failed.</span></span>  
  
 <span data-ttu-id="44607-133">封裝只可以在控制流程層級重新啟動。</span><span class="sxs-lookup"><span data-stu-id="44607-133">A package can be restarted only at the control flow level.</span></span> <span data-ttu-id="44607-134">您無法在資料流程中間重新啟動封裝。</span><span class="sxs-lookup"><span data-stu-id="44607-134">You cannot restart a package in the middle of a data flow.</span></span> <span data-ttu-id="44607-135">為避免重新執行整個資料流程，封裝可能會設計成包含多個資料流程，每個都使用不同的資料流程工作。</span><span class="sxs-lookup"><span data-stu-id="44607-135">To avoid rerunning the whole data flow, the package might be designed to include multiple data flows, each one using a different Data Flow task.</span></span> <span data-ttu-id="44607-136">如此一來，重新啟動封裝時就只需重新執行一個資料流程工作。</span><span class="sxs-lookup"><span data-stu-id="44607-136">This way the package can be restarted, rerunning only one Data Flow task.</span></span>  
  
## <a name="configuring-a-package-to-restart"></a><span data-ttu-id="44607-137">設定重新啟動的封裝</span><span class="sxs-lookup"><span data-stu-id="44607-137">Configuring a Package to Restart</span></span>  
 <span data-ttu-id="44607-138">檢查點檔案包含所有完成之容器的執行結果、系統和使用者自訂之變數的目前值，以及封裝組態資訊。</span><span class="sxs-lookup"><span data-stu-id="44607-138">The checkpoint file includes the execution results of all completed containers, the current values of system and user-defined variables, and package configuration information.</span></span> <span data-ttu-id="44607-139">該檔案還包含封裝的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="44607-139">The file also includes the unique identifier of the package.</span></span> <span data-ttu-id="44607-140">若要順利重新啟動封裝，檢查點檔案中的封裝識別碼必須與封裝中的識別碼相符，否則重新啟動會失敗。</span><span class="sxs-lookup"><span data-stu-id="44607-140">To successfully restart a package, the package identifier in the checkpoint file and the package must match; otherwise the restart fails.</span></span> <span data-ttu-id="44607-141">這會防止封裝使用不同封裝版本寫入的檢查點檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-141">This prevents a package from using a checkpoint file written by a different package version.</span></span> <span data-ttu-id="44607-142">如果封裝順利執行，則在其重新啟動後，會刪除檢查點檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-142">If the package runs successfully, after it is restarted the checkpoint file is deleted.</span></span>  
  
 <span data-ttu-id="44607-143">下表列出設定用以實作檢查點的封裝屬性。</span><span class="sxs-lookup"><span data-stu-id="44607-143">The following table lists the package properties that you set to implement checkpoints.</span></span>  
  
|<span data-ttu-id="44607-144">屬性</span><span class="sxs-lookup"><span data-stu-id="44607-144">Property</span></span>|<span data-ttu-id="44607-145">描述</span><span class="sxs-lookup"><span data-stu-id="44607-145">Description</span></span>|  
|--------------|-----------------|  
|<span data-ttu-id="44607-146">CheckpointFileName</span><span class="sxs-lookup"><span data-stu-id="44607-146">CheckpointFileName</span></span>|<span data-ttu-id="44607-147">指定檢查點檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="44607-147">Specifies the name of the checkpoint file.</span></span>|  
|<span data-ttu-id="44607-148">CheckpointUsage</span><span class="sxs-lookup"><span data-stu-id="44607-148">CheckpointUsage</span></span>|<span data-ttu-id="44607-149">指定是否使用檢查點。</span><span class="sxs-lookup"><span data-stu-id="44607-149">Specifies whether checkpoints are used.</span></span>|  
|<span data-ttu-id="44607-150">SaveCheckpoints</span><span class="sxs-lookup"><span data-stu-id="44607-150">SaveCheckpoints</span></span>|<span data-ttu-id="44607-151">指出封裝是否儲存檢查點。</span><span class="sxs-lookup"><span data-stu-id="44607-151">Indicates whether the package saves checkpoints.</span></span> <span data-ttu-id="44607-152">必須將此屬性設為 True，才能從失敗點重新啟動封裝。</span><span class="sxs-lookup"><span data-stu-id="44607-152">This property must be set to True to restart a package from a point of failure.</span></span>|  
  
 <span data-ttu-id="44607-153">此外，您必須 `true` 針對封裝中要識別為重新啟動點的所有容器，將 FailPackageOnFailure 屬性設定為。</span><span class="sxs-lookup"><span data-stu-id="44607-153">Additionally, you must set the FailPackageOnFailure property to `true` for all the containers in the package that you want to identify as restart points.</span></span>  
  
 <span data-ttu-id="44607-154">可以使用 ForceExecutionResult 屬性來測試封裝中檢查點的使用。</span><span class="sxs-lookup"><span data-stu-id="44607-154">You can use the ForceExecutionResult property to test the use of checkpoints in a package.</span></span> <span data-ttu-id="44607-155">將工作或容器的 ForceExecutionResult 設為 [Failure]，可以模擬即時失敗。</span><span class="sxs-lookup"><span data-stu-id="44607-155">By setting ForceExecutionResult of a task or container to Failure, you can imitate real-time failure.</span></span> <span data-ttu-id="44607-156">當重新執行封裝時，會重新執行失敗的工作和容器。</span><span class="sxs-lookup"><span data-stu-id="44607-156">When you rerun the package, the failed task and containers will be rerun.</span></span>  
  
### <a name="checkpoint-usage"></a><span data-ttu-id="44607-157">檢查點使用方式</span><span class="sxs-lookup"><span data-stu-id="44607-157">Checkpoint Usage</span></span>  
 <span data-ttu-id="44607-158">CheckpointUsage 屬性可以設為下列值：</span><span class="sxs-lookup"><span data-stu-id="44607-158">The CheckpointUsage property can be set to the following values:</span></span>  
  
|<span data-ttu-id="44607-159">值</span><span class="sxs-lookup"><span data-stu-id="44607-159">Value</span></span>|<span data-ttu-id="44607-160">描述</span><span class="sxs-lookup"><span data-stu-id="44607-160">Description</span></span>|  
|-----------|-----------------|  
|`Never`|<span data-ttu-id="44607-161">指定不使用檢查點檔案，且封裝從封裝工作流程的開始點執行。</span><span class="sxs-lookup"><span data-stu-id="44607-161">Specifies that the checkpoint file is not used and that the package runs from the start of the package workflow.</span></span>|  
|`Always`|<span data-ttu-id="44607-162">指定總是使用檢查點檔案，且封裝從上一個執行失敗點重新啟動。</span><span class="sxs-lookup"><span data-stu-id="44607-162">Specifies that the checkpoint file is always used and that the package restarts from the point of the previous execution failure.</span></span> <span data-ttu-id="44607-163">如果找不到檢查點檔案，則封裝會失敗。</span><span class="sxs-lookup"><span data-stu-id="44607-163">If the checkpoint file is not found, the package fails.</span></span>|  
|`IfExists`|<span data-ttu-id="44607-164">指定如果存在檢查點檔案，就使用該檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-164">Specifies that the checkpoint file is used if it exists.</span></span> <span data-ttu-id="44607-165">如果存在檢查點檔案，則封裝會從上一個執行失敗點重新啟動，否則，封裝會從封裝工作流程的開始點執行。</span><span class="sxs-lookup"><span data-stu-id="44607-165">If the checkpoint file exists, the package restarts from the point of the previous execution failure; otherwise, it runs from the start of the package workflow.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="44607-166">Dtexec 的 **/checkpointing on**選項相當於將封裝的屬性設定 `SaveCheckpoints` 為 `True` ，並將屬性設 `CheckpointUsage` 為 Always。</span><span class="sxs-lookup"><span data-stu-id="44607-166">The **/CheckPointing on** option of dtexec is equivalent to setting the `SaveCheckpoints` property of the package to `True`, and the `CheckpointUsage` property to Always.</span></span> <span data-ttu-id="44607-167">如需詳細資訊，請參閱 [dtexec Utility](dtexec-utility.md)。</span><span class="sxs-lookup"><span data-stu-id="44607-167">For more information, see [dtexec Utility](dtexec-utility.md).</span></span>  
  
## <a name="securing-checkpoint-files"></a><span data-ttu-id="44607-168">保護檢查點檔案</span><span class="sxs-lookup"><span data-stu-id="44607-168">Securing Checkpoint Files</span></span>  
 <span data-ttu-id="44607-169">封裝等級保護並不包括檢查點檔案的保護，因此您必須個別保護這些檔案。</span><span class="sxs-lookup"><span data-stu-id="44607-169">Package level protection does not include protection of checkpoint files and you must secure these files separately.</span></span> <span data-ttu-id="44607-170">檢查點資料只能儲存在檔案系統中，而且您應該使用作業系統存取控制清單 (ACL) 來保護儲存檔案之位置或資料夾的安全。</span><span class="sxs-lookup"><span data-stu-id="44607-170">Checkpoint data can be stored only in the file system and you should use an operating system access control list (ACL) to secure the location or folder where you store the file.</span></span> <span data-ttu-id="44607-171">請務必保護檢查點檔案的安全，因為它們包含有關封裝狀態的資訊，包括變數目前的值。</span><span class="sxs-lookup"><span data-stu-id="44607-171">It is important to secure checkpoint files because they contain information about the package state, including the current values of variables.</span></span> <span data-ttu-id="44607-172">例如，變數包含的資料錄集可能具有許多私密資料 (例如電話號碼) 的資料列。</span><span class="sxs-lookup"><span data-stu-id="44607-172">For example, a variable may contain a recordset with many rows of private data such as telephone numbers.</span></span> <span data-ttu-id="44607-173">如需詳細資訊，請參閱 [對封裝使用之檔案的存取權](../access-to-files-used-by-packages.md)。</span><span class="sxs-lookup"><span data-stu-id="44607-173">For more information, see [Access to Files Used by Packages](../access-to-files-used-by-packages.md).</span></span>  
  
### <a name="to-configure-the-checkpoint-properties"></a><span data-ttu-id="44607-174">設定檢查點屬性</span><span class="sxs-lookup"><span data-stu-id="44607-174">To configure the checkpoint properties</span></span>  
  
-   [<span data-ttu-id="44607-175">設定檢查點以重新啟動失敗的封裝</span><span class="sxs-lookup"><span data-stu-id="44607-175">Configure Checkpoints for Restarting a Failed Package</span></span>](../configure-checkpoints-for-restarting-a-failed-package.md)  
  
## <a name="external-resources"></a><span data-ttu-id="44607-176">外部資源</span><span class="sxs-lookup"><span data-stu-id="44607-176">External Resources</span></span>  
  
-   <span data-ttu-id="44607-177">位於 social.technet.microsoft.com 的技術文件： [發生容錯移轉或失敗之後 SSIS 封裝自動重新啟動](https://go.microsoft.com/fwlink/?LinkId=200407)。</span><span class="sxs-lookup"><span data-stu-id="44607-177">Technical article, [Automatic Restart of SSIS packages after Failover or Failure](https://go.microsoft.com/fwlink/?LinkId=200407), on social.technet.microsoft.com</span></span>  
  
-   <span data-ttu-id="44607-178">support.microsoft.com 上的技術支援文件： [For 迴圈或 Foreach 迴圈容器項目都不接受 SSIS 檢查點](https://go.microsoft.com/fwlink/?LinkId=241633)。</span><span class="sxs-lookup"><span data-stu-id="44607-178">Support article, [SSIS Checkpoints are not honored for For Loop or Foreach Loop container items](https://go.microsoft.com/fwlink/?LinkId=241633), on support.microsoft.com.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="44607-179">另請參閱</span><span class="sxs-lookup"><span data-stu-id="44607-179">See Also</span></span>  
 [<span data-ttu-id="44607-180">SQL Server Integration Services</span><span class="sxs-lookup"><span data-stu-id="44607-180">SQL Server Integration Services</span></span>](../sql-server-integration-services.md)  
  
  
