---
title: 比較以磁碟為基礎的資料表儲存體和記憶體最佳化資料表儲存體 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: eacf443c-001a-445f-ad1c-5f5a45eca6f4
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 47cf84427b2f4f26a29f732575530b384d9c4fc9
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87708370"
---
# <a name="comparing-disk-based-table-storage-to-memory-optimized-table-storage"></a><span data-ttu-id="e0aef-102">比較以磁碟為基礎的資料表儲存體和記憶體最佳化資料表儲存體</span><span class="sxs-lookup"><span data-stu-id="e0aef-102">Comparing Disk-Based Table Storage to Memory-Optimized Table Storage</span></span>
  
  
|<span data-ttu-id="e0aef-103">類別</span><span class="sxs-lookup"><span data-stu-id="e0aef-103">Categories</span></span>|<span data-ttu-id="e0aef-104">以磁碟為基礎的資料表</span><span class="sxs-lookup"><span data-stu-id="e0aef-104">Disk-based Table</span></span>|<span data-ttu-id="e0aef-105">持久性記憶體最佳化的資料表</span><span class="sxs-lookup"><span data-stu-id="e0aef-105">Durable Memory-Optimized Table</span></span>|  
|----------------|-----------------------|-------------------------------------|  
|<span data-ttu-id="e0aef-106">DDL</span><span class="sxs-lookup"><span data-stu-id="e0aef-106">DDL</span></span>|<span data-ttu-id="e0aef-107">中繼資料資訊會儲存在資料庫的主要檔案群組中的系統資料表內，而且可透過目錄檢視加以存取。</span><span class="sxs-lookup"><span data-stu-id="e0aef-107">Metadata information is stored in system tables in the primary filegroup of the database and is accessible through catalog views.</span></span>|<span data-ttu-id="e0aef-108">中繼資料資訊會儲存在資料庫的主要檔案群組中的系統資料表內，而且可透過目錄檢視加以存取。</span><span class="sxs-lookup"><span data-stu-id="e0aef-108">Metadata information is stored in system tables in the primary filegroup of the database and is accessible through catalog views.</span></span>|  
|<span data-ttu-id="e0aef-109">結構</span><span class="sxs-lookup"><span data-stu-id="e0aef-109">Structure</span></span>|<span data-ttu-id="e0aef-110">資料列會儲存在 8 千個頁面中。</span><span class="sxs-lookup"><span data-stu-id="e0aef-110">Rows are stored in 8K pages.</span></span> <span data-ttu-id="e0aef-111">頁面只會儲存來自相同資料表的資料列。</span><span class="sxs-lookup"><span data-stu-id="e0aef-111">A page stores only rows from the same table.</span></span>|<span data-ttu-id="e0aef-112">資料列會儲存為個別的資料列。</span><span class="sxs-lookup"><span data-stu-id="e0aef-112">Rows are stored as individual rows.</span></span> <span data-ttu-id="e0aef-113">沒有頁面結構。</span><span class="sxs-lookup"><span data-stu-id="e0aef-113">There is no page structure.</span></span> <span data-ttu-id="e0aef-114">資料檔案中的兩個連續資料列可屬於不同的記憶體最佳化的資料表。</span><span class="sxs-lookup"><span data-stu-id="e0aef-114">Two consecutive rows in a data file can belong to different memory-optimized tables.</span></span>|  
|<span data-ttu-id="e0aef-115">索引</span><span class="sxs-lookup"><span data-stu-id="e0aef-115">Indexes</span></span>|<span data-ttu-id="e0aef-116">索引會儲存在類似於資料列的頁面結構中。</span><span class="sxs-lookup"><span data-stu-id="e0aef-116">Indexes are stored in a page structure similar to data rows.</span></span>|<span data-ttu-id="e0aef-117">只有索引定義會保存下來 (非索引資料列)。</span><span class="sxs-lookup"><span data-stu-id="e0aef-117">Only the index definition is persisted (not index rows).</span></span> <span data-ttu-id="e0aef-118">索引會在記憶體中維護，而且當記憶體最佳化的資料表在重新啟動資料庫的過程中載入記憶體中時，將會重新產生索引。</span><span class="sxs-lookup"><span data-stu-id="e0aef-118">Indexes are maintained in-memory and are regenerated when the memory-optimized table is loaded into memory as part of restarting a database.</span></span> <span data-ttu-id="e0aef-119">因為索引資料列不會保存下來，所以索引變更不會進行任何記錄。</span><span class="sxs-lookup"><span data-stu-id="e0aef-119">Since index rows are not persisted, no logging is done for index changes.</span></span>|  
|<span data-ttu-id="e0aef-120">DML 作業</span><span class="sxs-lookup"><span data-stu-id="e0aef-120">DML operation</span></span>|<span data-ttu-id="e0aef-121">第一步是尋找頁面，然後將它載入緩衝集區內。</span><span class="sxs-lookup"><span data-stu-id="e0aef-121">The first step is to find the page and then load it into buffer-pool.</span></span><br /><br /> <span data-ttu-id="e0aef-122">插入</span><span class="sxs-lookup"><span data-stu-id="e0aef-122">Insert</span></span><br /> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="e0aef-123">會在頁面上插入資料列，以代表資料列排序。</span><span class="sxs-lookup"><span data-stu-id="e0aef-123">inserts the row on the page accounting for row ordering in case of clustered index.</span></span><br /><br /> <span data-ttu-id="e0aef-124">刪除</span><span class="sxs-lookup"><span data-stu-id="e0aef-124">Delete</span></span><br /> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="e0aef-125">會在頁面上找出要刪除的資料列，並將它標記為刪除。</span><span class="sxs-lookup"><span data-stu-id="e0aef-125">locates the row to be deleted on the page and marks it deleted.</span></span><br /><br /> <span data-ttu-id="e0aef-126">更新</span><span class="sxs-lookup"><span data-stu-id="e0aef-126">Update</span></span><br /> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="e0aef-127">會在頁面上找出資料列。</span><span class="sxs-lookup"><span data-stu-id="e0aef-127">locates the row on the page.</span></span> <span data-ttu-id="e0aef-128">非索引鍵資料行會就地完成更新。</span><span class="sxs-lookup"><span data-stu-id="e0aef-128">The update is done in-place for non-key columns.</span></span> <span data-ttu-id="e0aef-129">索引鍵資料行的更新是由刪除和插入作業所完成。</span><span class="sxs-lookup"><span data-stu-id="e0aef-129">Key-column update is done by a delete and insert operation.</span></span><br /><br /> <span data-ttu-id="e0aef-130">當 DML 作業完成後，受影響的頁面會排清到磁碟，這是最小記錄作業的緩衝集區原則、檢查點或交易認可的一部分。</span><span class="sxs-lookup"><span data-stu-id="e0aef-130">After the DML operation completes, the affected pages are flushed to disk as part of buffer pool policy, checkpoint or transaction commit for minimally-logged operations.</span></span> <span data-ttu-id="e0aef-131">頁面上的讀寫作業都會產生不必要的 I/O。</span><span class="sxs-lookup"><span data-stu-id="e0aef-131">Both read/write operations on pages leads to unnecessary I/O.</span></span>|<span data-ttu-id="e0aef-132">如果是記憶體最佳化的資料表，因為資料常駐於記憶體中，所以 DML 作業會直接在記憶體中完成。</span><span class="sxs-lookup"><span data-stu-id="e0aef-132">For memory-optimized tables, since the data resides in memory, the DML operations are done directly in memory.</span></span> <span data-ttu-id="e0aef-133">有背景執行緒會讀取記憶體最佳化之資料表的記錄檔記錄，並將其保存在資料和差異檔案中。</span><span class="sxs-lookup"><span data-stu-id="e0aef-133">There is a background thread that reads the log records for memory-optimized tables and persist them into data and delta files.</span></span> <span data-ttu-id="e0aef-134">更新會產生新的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e0aef-134">An update generates a new row version.</span></span> <span data-ttu-id="e0aef-135">但是更新會記錄為插入之後的刪除。</span><span class="sxs-lookup"><span data-stu-id="e0aef-135">But an update is logged as a delete followed by an insert.</span></span>|  
|<span data-ttu-id="e0aef-136">分割區</span><span class="sxs-lookup"><span data-stu-id="e0aef-136">Data Fragmentation</span></span>|<span data-ttu-id="e0aef-137">資料操作會分割資料，導致磁碟上不連續的部分填滿頁面和邏輯連續頁面。</span><span class="sxs-lookup"><span data-stu-id="e0aef-137">Data manipulation fragments data leading to partially filled pages and logically consecutive pages that are not contiguous on disk.</span></span> <span data-ttu-id="e0aef-138">這樣會降低資料存取效能，而且會要求您重組資料。</span><span class="sxs-lookup"><span data-stu-id="e0aef-138">This degrades data access performance and requires you to defragment data.</span></span>|<span data-ttu-id="e0aef-139">記憶體最佳化的資料不會儲存在頁面上，所以不會分割資料。</span><span class="sxs-lookup"><span data-stu-id="e0aef-139">Memory-optimized data is not stored in pages so there is no data fragmentation.</span></span> <span data-ttu-id="e0aef-140">不過，因為資料列已更新和刪除，所以必須壓縮資料和差異檔案。</span><span class="sxs-lookup"><span data-stu-id="e0aef-140">However, as rows are updated and deleted, the data and delta files need to be compacted.</span></span> <span data-ttu-id="e0aef-141">這是由根據合併原則的背景 MERGE 執行緒所完成。</span><span class="sxs-lookup"><span data-stu-id="e0aef-141">This is done by a background MERGE thread based on a merge policy.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="e0aef-142">另請參閱</span><span class="sxs-lookup"><span data-stu-id="e0aef-142">See Also</span></span>  
 [<span data-ttu-id="e0aef-143">建立及管理記憶體最佳化物件的儲存體</span><span class="sxs-lookup"><span data-stu-id="e0aef-143">Creating and Managing Storage for Memory-Optimized Objects</span></span>](creating-and-managing-storage-for-memory-optimized-objects.md)  
  
  
