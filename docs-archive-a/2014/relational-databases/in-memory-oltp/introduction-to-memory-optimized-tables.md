---
title: 記憶體最佳化的資料表簡介 | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87709462"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="787f3-102">記憶體最佳化的資料表簡介</span><span class="sxs-lookup"><span data-stu-id="787f3-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="787f3-103">記憶體最佳化資料表是使用 [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) 所建立的資料表。</span><span class="sxs-lookup"><span data-stu-id="787f3-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="787f3-104">記憶體最佳化資料表位於記憶體中。</span><span class="sxs-lookup"><span data-stu-id="787f3-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="787f3-105">資料表中的資料列可從記憶體讀取，並且可寫入記憶體。</span><span class="sxs-lookup"><span data-stu-id="787f3-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="787f3-106">整個資料表存在於記憶體中。</span><span class="sxs-lookup"><span data-stu-id="787f3-106">The entire table resides in memory.</span></span> <span data-ttu-id="787f3-107">資料表資料的第二個副本保留在磁碟上，但僅做為持久性用途。</span><span class="sxs-lookup"><span data-stu-id="787f3-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="787f3-108">記憶體中 OLTP 的目標是與 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 整合，以便在開發、部署、管理能力及支援能力等各方面提供完美無瑕的體驗。</span><span class="sxs-lookup"><span data-stu-id="787f3-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="787f3-109">資料庫可以包含位於記憶體中以及以磁碟為基礎的物件。</span><span class="sxs-lookup"><span data-stu-id="787f3-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="787f3-110">記憶體最佳化資料表中的資料列會建立版本。</span><span class="sxs-lookup"><span data-stu-id="787f3-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="787f3-111">這表示，資料表的每個資料列可能有多個版本。</span><span class="sxs-lookup"><span data-stu-id="787f3-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="787f3-112">所有資料列版本都是在相同資料表資料結構中維護。</span><span class="sxs-lookup"><span data-stu-id="787f3-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="787f3-113">只要使用資料列版本設定功能，就能在同一個資料列並行讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="787f3-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="787f3-114">如需有關同一個資料列的並行讀取和寫入的詳細資訊，請參閱＜ [Transactions in Memory-Optimized Tables](memory-optimized-tables.md)＞。</span><span class="sxs-lookup"><span data-stu-id="787f3-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="787f3-115">下圖說明多重版本設定。</span><span class="sxs-lookup"><span data-stu-id="787f3-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="787f3-116">此圖顯示一個資料表包含三個資料列，每個資料列各有不同的版本。</span><span class="sxs-lookup"><span data-stu-id="787f3-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="787f3-117">![多重版本設定。](../../database-engine/media/hekaton-tables-1.gif "多重版本設定。")</span><span class="sxs-lookup"><span data-stu-id="787f3-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="787f3-118">該資料表具有三個資料列：r1、r2 和 r3。</span><span class="sxs-lookup"><span data-stu-id="787f3-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="787f3-119">r1 有三個版本、r2 有兩個版本，而 r3 有四個版本。</span><span class="sxs-lookup"><span data-stu-id="787f3-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="787f3-120">請注意，相同資料列的不同版本不一定佔用連續記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="787f3-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="787f3-121">不同的資料列版本可能分散在資料表資料結構中。</span><span class="sxs-lookup"><span data-stu-id="787f3-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="787f3-122">記憶體最佳化的資料表資料結構可以視為資料列版本的集合。</span><span class="sxs-lookup"><span data-stu-id="787f3-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="787f3-123">磁碟基礎的資料表中的資料列是以頁面與範圍方式組織，其中個別資料列使用頁碼和頁面位移來定址，而記憶體最佳化資料表中的資料列版本則是使用 8 位元組記憶體指標來定址。</span><span class="sxs-lookup"><span data-stu-id="787f3-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="787f3-124">持久性</span><span class="sxs-lookup"><span data-stu-id="787f3-124">Durability</span></span>  
 <span data-ttu-id="787f3-125">記憶體最佳化資料表預設為完全持久，而且就如同 (傳統) 磁碟資料表上的交易，記憶體最佳化資料表上的完全持久交易為完全不可部分完成、一致、隔離且持久 (atomic, consistent, isolated, and durable - ACID)。</span><span class="sxs-lookup"><span data-stu-id="787f3-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="787f3-126">記憶體最佳化資料表和原生編譯的預存程序都支援 [!INCLUDE[tsql](../../../includes/tsql-md.md)]的子集。</span><span class="sxs-lookup"><span data-stu-id="787f3-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="787f3-127">記憶體中 OLTP 支援延遲交易持久性的持久資料表。</span><span class="sxs-lookup"><span data-stu-id="787f3-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="787f3-128">延遲的持久交易會在認可交易之後，立即儲存至磁碟。</span><span class="sxs-lookup"><span data-stu-id="787f3-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="787f3-129">為了提升效能，付出的代價是在伺服器當機或容錯移轉時，遺失未儲存至磁碟的已認可交易。</span><span class="sxs-lookup"><span data-stu-id="787f3-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="787f3-130">除了預設持久的記憶體最佳化資料表之外， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 還支援非持久記憶體最佳化資料表，這些資料表不會記錄，且其資料不會保存在磁碟上。</span><span class="sxs-lookup"><span data-stu-id="787f3-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="787f3-131">這表示，這些資料表上的交易不需要任何磁碟 IO，但其資料在伺服器當機或容錯移轉後，將無法復原。</span><span class="sxs-lookup"><span data-stu-id="787f3-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="787f3-132">存取記憶體最佳化資料表中的資料</span><span class="sxs-lookup"><span data-stu-id="787f3-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="787f3-133">記憶體最佳化資料表中的資料，可使用下列兩種方式的其中一種進行存取：</span><span class="sxs-lookup"><span data-stu-id="787f3-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="787f3-134">透過解譯的 [!INCLUDE[tsql](../../../includes/tsql-md.md)] (位於原生編譯預存程序外部)。</span><span class="sxs-lookup"><span data-stu-id="787f3-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="787f3-135">這些 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 陳述式可以位於解譯的預存程序內，也可以是特定 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 陳述式。</span><span class="sxs-lookup"><span data-stu-id="787f3-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="787f3-136">透過原生編譯的預存程序。</span><span class="sxs-lookup"><span data-stu-id="787f3-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="787f3-137">從原生編譯的預存程序可以最有效率地存取記憶體最佳化資料表 ([原生編譯預存程序](natively-compiled-stored-procedures.md))。</span><span class="sxs-lookup"><span data-stu-id="787f3-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="787f3-138">使用 (傳統) 解譯的 [!INCLUDE[tsql](../../../includes/tsql-md.md)]也可以存取記憶體最佳化資料表。</span><span class="sxs-lookup"><span data-stu-id="787f3-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="787f3-139">解譯的 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 是指在不使用原生編譯之預存程序的情況下存取記憶體最佳化資料表。</span><span class="sxs-lookup"><span data-stu-id="787f3-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="787f3-140">解譯的 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 存取範例包括從 DML 觸發程序、特定 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 批次、檢視和資料表值函式，存取記憶體最佳化資料表。</span><span class="sxs-lookup"><span data-stu-id="787f3-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="787f3-141">下表摘要說明各種物件的原生和解譯 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 存取。</span><span class="sxs-lookup"><span data-stu-id="787f3-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="787f3-142">功能</span><span class="sxs-lookup"><span data-stu-id="787f3-142">Feature</span></span>|<span data-ttu-id="787f3-143">使用原生編譯的預存程序存取</span><span class="sxs-lookup"><span data-stu-id="787f3-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="787f3-144">解譯的 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 存取</span><span class="sxs-lookup"><span data-stu-id="787f3-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="787f3-145">CLR 存取</span><span class="sxs-lookup"><span data-stu-id="787f3-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="787f3-146">記憶體最佳化的資料表</span><span class="sxs-lookup"><span data-stu-id="787f3-146">Memory-optimized tables</span></span>|<span data-ttu-id="787f3-147">是</span><span class="sxs-lookup"><span data-stu-id="787f3-147">Yes</span></span>|<span data-ttu-id="787f3-148">是</span><span class="sxs-lookup"><span data-stu-id="787f3-148">Yes</span></span>|<span data-ttu-id="787f3-149">否 <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="787f3-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="787f3-150">記憶體最佳化資料表變數</span><span class="sxs-lookup"><span data-stu-id="787f3-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="787f3-151">是</span><span class="sxs-lookup"><span data-stu-id="787f3-151">Yes</span></span>|<span data-ttu-id="787f3-152">是</span><span class="sxs-lookup"><span data-stu-id="787f3-152">Yes</span></span>|<span data-ttu-id="787f3-153">否</span><span class="sxs-lookup"><span data-stu-id="787f3-153">No</span></span>|  
|[<span data-ttu-id="787f3-154">原生編譯的預存程序</span><span class="sxs-lookup"><span data-stu-id="787f3-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="787f3-155">您無法使用 EXECUTE 陳述式從原生編譯的預存程序執行任何預存程序。</span><span class="sxs-lookup"><span data-stu-id="787f3-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="787f3-156">是</span><span class="sxs-lookup"><span data-stu-id="787f3-156">Yes</span></span>|<span data-ttu-id="787f3-157">否 <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="787f3-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="787f3-158"><sup>1</sup>您無法從內容連接存取記憶體優化資料表或原生編譯預存程式， (從 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]) 執行 CLR 模組時的連接。</span><span class="sxs-lookup"><span data-stu-id="787f3-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="787f3-159">不過，您可以建立及開啟另一個連接，並從中存取記憶體最佳化資料表和原生編譯預存程序。</span><span class="sxs-lookup"><span data-stu-id="787f3-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="787f3-160">如需詳細資訊，請參閱[一般與內容連接](../clr-integration/data-access/context-connections-vs-regular-connections.md)。</span><span class="sxs-lookup"><span data-stu-id="787f3-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="787f3-161">效能和延展性</span><span class="sxs-lookup"><span data-stu-id="787f3-161">Performance and Scalability</span></span>  
 <span data-ttu-id="787f3-162">下列因素會影響記憶體中 OLTP 可達到的效能提升：</span><span class="sxs-lookup"><span data-stu-id="787f3-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="787f3-163">溝通</span><span class="sxs-lookup"><span data-stu-id="787f3-163">Communication</span></span>  
 <span data-ttu-id="787f3-164">相較於具有較少呼叫而且每個預存程序中實作更多功能的應用程式，具有簡短預存程序的許多呼叫的應用程式可能會看到較少的效能增益。</span><span class="sxs-lookup"><span data-stu-id="787f3-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="787f3-165">執行</span><span class="sxs-lookup"><span data-stu-id="787f3-165">Execution</span></span>  
 <span data-ttu-id="787f3-166">記憶體中 OLTP 使用原生編譯的預存程序時可達到最佳效能，而不是使用解譯的預存程序或查詢執行。</span><span class="sxs-lookup"><span data-stu-id="787f3-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="787f3-167">執行其他預存程序的預存程序，便不可用原生方式編譯，但從這類預存程序存取記憶體最佳化的資料表有其優勢。</span><span class="sxs-lookup"><span data-stu-id="787f3-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="787f3-168">範圍掃描和點查閱的比較</span><span class="sxs-lookup"><span data-stu-id="787f3-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="787f3-169">記憶體最佳化的非叢集索引可支援範圍掃描和排序掃描。</span><span class="sxs-lookup"><span data-stu-id="787f3-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="787f3-170">對於點查閱而言，記憶體最佳化雜湊索引的效能比記憶體最佳化的非叢集索引更好。</span><span class="sxs-lookup"><span data-stu-id="787f3-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="787f3-171">記憶體最佳化非叢集索引的效能比以磁碟為基礎的索引更好。</span><span class="sxs-lookup"><span data-stu-id="787f3-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="787f3-172">索引作業不會記錄下來，且只存在於記憶體中。</span><span class="sxs-lookup"><span data-stu-id="787f3-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="787f3-173">並行</span><span class="sxs-lookup"><span data-stu-id="787f3-173">Concurrency</span></span>  
 <span data-ttu-id="787f3-174">效能受到引擎層級並行 (例如閂鎖競爭或封鎖) 影響的應用程式改用記憶體中 OLTP 之後，將可大幅改善其效能。</span><span class="sxs-lookup"><span data-stu-id="787f3-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="787f3-175">下表列出關聯式資料庫中經常發現的效能和延展性問題，以及記憶體中 OLTP 如何改善效能。</span><span class="sxs-lookup"><span data-stu-id="787f3-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="787f3-176">問題</span><span class="sxs-lookup"><span data-stu-id="787f3-176">Issue</span></span>|<span data-ttu-id="787f3-177">記憶體中 OLTP 影響</span><span class="sxs-lookup"><span data-stu-id="787f3-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="787f3-178">效能</span><span class="sxs-lookup"><span data-stu-id="787f3-178">Performance</span></span><br /><br /> <span data-ttu-id="787f3-179">高資源 (CPU、I/O、網路或記憶體) 使用量。</span><span class="sxs-lookup"><span data-stu-id="787f3-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="787f3-180">CPU</span><span class="sxs-lookup"><span data-stu-id="787f3-180">CPU</span></span><br /> <span data-ttu-id="787f3-181">原生編譯的預存程序可大幅降低 CPU 使用量，因為它們執行 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 陳述式所需的指令比 (傳統) 解譯的預存程序少了許多。</span><span class="sxs-lookup"><span data-stu-id="787f3-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="787f3-182">記憶體中 OLTP 有助於減少向外延展的工作負載中的硬體投資，因為一部伺服器具有提供五到十部伺服器輸送量的潛力。</span><span class="sxs-lookup"><span data-stu-id="787f3-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="787f3-183">I/O</span><span class="sxs-lookup"><span data-stu-id="787f3-183">I/O</span></span><br /> <span data-ttu-id="787f3-184">如果處理資料或索引頁面時遭遇 I/O 瓶頸，記憶體中 OLTP 可減少瓶頸。</span><span class="sxs-lookup"><span data-stu-id="787f3-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="787f3-185">此外，記憶體中 OLTP 物件的檢查點是連續的，不會導致 I/O 作業突然增加。</span><span class="sxs-lookup"><span data-stu-id="787f3-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="787f3-186">不過，如果效能嚴重不足資料表的工作集無法納入記憶體中，記憶體中 OLTP 將無法改善效能，因為它要求資料必須是記憶體駐留。</span><span class="sxs-lookup"><span data-stu-id="787f3-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="787f3-187">如果在記錄時遭遇 I/O 瓶頸，記憶體中 OLTP 可減少瓶頸，因為它進行的記錄較少。</span><span class="sxs-lookup"><span data-stu-id="787f3-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="787f3-188">如果將一個或多個記憶體最佳化資料表設為非持久資料表，就可以消除記錄資料的作業。</span><span class="sxs-lookup"><span data-stu-id="787f3-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="787f3-189">記憶體</span><span class="sxs-lookup"><span data-stu-id="787f3-189">Memory</span></span><br /> <span data-ttu-id="787f3-190">記憶體中 OLTP 並未提供任何效能優勢。</span><span class="sxs-lookup"><span data-stu-id="787f3-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="787f3-191">此外，記憶體中 OLTP 可能會對記憶體造成額外的壓力，因為物件需駐留在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="787f3-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="787f3-192">網路</span><span class="sxs-lookup"><span data-stu-id="787f3-192">Network</span></span><br /> <span data-ttu-id="787f3-193">記憶體中 OLTP 並未提供任何效能優勢。</span><span class="sxs-lookup"><span data-stu-id="787f3-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="787f3-194">資料需要從資料層到應用程式層之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="787f3-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="787f3-195">延展性</span><span class="sxs-lookup"><span data-stu-id="787f3-195">Scalability</span></span><br /><br /> <span data-ttu-id="787f3-196">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 應用程式中大多數的擴充問題都是由並行問題所造成，例如競爭鎖定、閂鎖和執行緒同步鎖定。</span><span class="sxs-lookup"><span data-stu-id="787f3-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="787f3-197">閂鎖競爭</span><span class="sxs-lookup"><span data-stu-id="787f3-197">Latch Contention</span></span><br /> <span data-ttu-id="787f3-198">典型的案例是以索引鍵順序並行插入資料列時，競爭索引的最後一頁。</span><span class="sxs-lookup"><span data-stu-id="787f3-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="787f3-199">由於記憶體中 OLTP 存取資料時不會採用閂鎖，因此可完全消除與執行緒同步鎖定競爭相關的延展性問題。</span><span class="sxs-lookup"><span data-stu-id="787f3-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="787f3-200">執行緒同步鎖定競爭</span><span class="sxs-lookup"><span data-stu-id="787f3-200">Spinlock Contention</span></span><br /> <span data-ttu-id="787f3-201">由於記憶體中 OLTP 存取資料時不會採用閂鎖，因此可完全消除與同步鎖定競爭相關的延展性問題。</span><span class="sxs-lookup"><span data-stu-id="787f3-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="787f3-202">鎖定相關的競爭</span><span class="sxs-lookup"><span data-stu-id="787f3-202">Locking Related Contention</span></span><br /> <span data-ttu-id="787f3-203">如果資料庫應用程式在讀取和寫入作業之間發生封鎖問題，記憶體中 OLTP 可解決封鎖問題，因為它使用新的開放式並行控制形式來實作所有交易隔離層級。</span><span class="sxs-lookup"><span data-stu-id="787f3-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="787f3-204">記憶體中 OLTP 不會使用 TempDB 儲存資料列版本。</span><span class="sxs-lookup"><span data-stu-id="787f3-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="787f3-205">如果由於兩項寫入作業之間的衝突導致延展問題發生，例如兩項並行交易嘗試更新同一個資料列，記憶體中 OLTP 會讓其中一項交易成功，而讓另一項交易失敗。</span><span class="sxs-lookup"><span data-stu-id="787f3-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="787f3-206">失敗的交易必須以明確或隱含的方式重新送出，以重試交易。</span><span class="sxs-lookup"><span data-stu-id="787f3-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="787f3-207">不論是哪一種情況，您都必須變更應用程式。</span><span class="sxs-lookup"><span data-stu-id="787f3-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="787f3-208">如果您的應用程式在兩個寫入作業之間遇到常見的衝突，開放式鎖定的值會減少。</span><span class="sxs-lookup"><span data-stu-id="787f3-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="787f3-209">此應用程式不適用 In-Memory OLTP。</span><span class="sxs-lookup"><span data-stu-id="787f3-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="787f3-210">大部分的 OLTP 應用程式都沒有寫入衝突，除非衝突是由鎖定擴大所引發。</span><span class="sxs-lookup"><span data-stu-id="787f3-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="787f3-211">另請參閱</span><span class="sxs-lookup"><span data-stu-id="787f3-211">See Also</span></span>  
 [<span data-ttu-id="787f3-212">記憶體內部 OLTP &#40;記憶體內部最佳化&#41;</span><span class="sxs-lookup"><span data-stu-id="787f3-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
