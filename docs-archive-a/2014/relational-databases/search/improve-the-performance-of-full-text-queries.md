---
title: 改善全文檢索查詢的效能 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
ms.assetid: 0658dc74-25eb-4486-bbd6-e85c1f92c272
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: a1437f710725df5c87d31f6a80939a5d7869b412
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87702634"
---
# <a name="improve-the-performance-of-full-text-queries"></a><span data-ttu-id="b7311-102">改善全文檢索查詢的效能</span><span class="sxs-lookup"><span data-stu-id="b7311-102">Improve the Performance of Full-Text Queries</span></span>
  <span data-ttu-id="b7311-103">以下是有助於提升全文檢索查詢效能的建議事項清單。</span><span class="sxs-lookup"><span data-stu-id="b7311-103">The following is a list of recommendations that will help to improve the performance of full-text queries.</span></span>  
  
 <span data-ttu-id="b7311-104">全文檢索查詢的效能也會受到硬體資源的影響，例如記憶體、磁碟速度、CPU 速度和電腦架構。</span><span class="sxs-lookup"><span data-stu-id="b7311-104">The performance of full-text queries is also influenced by hardware resources, such as memory, disk speed, CPU speed, and machine architecture.</span></span>  
  
-   <span data-ttu-id="b7311-105">使用 [ALTER INDEX REORGANIZE](/sql/t-sql/statements/alter-index-transact-sql)來重組基底資料表的索引。</span><span class="sxs-lookup"><span data-stu-id="b7311-105">Defragment the index of the base table by using [ALTER INDEX REORGANIZE](/sql/t-sql/statements/alter-index-transact-sql).</span></span>  
  
-   <span data-ttu-id="b7311-106">使用 [ALTER FULLTEXT CATALOG REORGANIZE](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)來重新組織全文檢索目錄。</span><span class="sxs-lookup"><span data-stu-id="b7311-106">Reorganize the full-text catalog by using [ALTER FULLTEXT CATALOG REORGANIZE](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql).</span></span> <span data-ttu-id="b7311-107">在進行效能測試之前，請確定完成此動作，因為執行此陳述式會造成該目錄中之全文檢索的主要合併。</span><span class="sxs-lookup"><span data-stu-id="b7311-107">Make sure that you do this before performance testing because running this statement causes a master merge of the full-text indexes in that catalog.</span></span>  
  
-   <span data-ttu-id="b7311-108">請將您選擇的全文檢索索引鍵資料行限制為小資料行。</span><span class="sxs-lookup"><span data-stu-id="b7311-108">Restrict your choice of full-text key columns to a small column.</span></span> <span data-ttu-id="b7311-109">雖然支援 900 位元組的資料行，但是我們建議您在全文檢索索引中使用較小的索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="b7311-109">Although a 900-byte column is supported, we recommend using a smaller key column in a full-text index.</span></span> <span data-ttu-id="b7311-110">`int` 和 `bigint` 會提供最佳效能。</span><span class="sxs-lookup"><span data-stu-id="b7311-110">`int` and `bigint` provide the best performance.</span></span>  
  
-   <span data-ttu-id="b7311-111">使用整數全文檢索索引鍵可避免與 **docid** 對應資料表發生聯結。</span><span class="sxs-lookup"><span data-stu-id="b7311-111">Using an integer full-text key avoids a join with the **docid** mapping table.</span></span> <span data-ttu-id="b7311-112">因此，整數全文檢索索引鍵會依據重要性順序改善查詢效能並改善搜耙效能。</span><span class="sxs-lookup"><span data-stu-id="b7311-112">Therefore, an integer full-text key improves query performance by an order of magnitude and improves crawl performance.</span></span> <span data-ttu-id="b7311-113">如果全文檢索索引鍵也是叢集索引索引鍵，可能會產生額外效能優勢。</span><span class="sxs-lookup"><span data-stu-id="b7311-113">Additional performance benefits might result if the full-text key is also the clustered index key.</span></span>  
  
-   <span data-ttu-id="b7311-114">將多個 [CONTAINS](/sql/t-sql/queries/contains-transact-sql) 述詞結合為一個 CONTAINS 述詞。</span><span class="sxs-lookup"><span data-stu-id="b7311-114">Combine multiple [CONTAINS](/sql/t-sql/queries/contains-transact-sql) predicates into one CONTAINS predicate.</span></span> <span data-ttu-id="b7311-115">在 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 中，您可以在 CONTAINS 查詢中指定資料行清單。</span><span class="sxs-lookup"><span data-stu-id="b7311-115">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] you can specify a list of columns in the CONTAINS query.</span></span>  
  
-   <span data-ttu-id="b7311-116">如果您只需要全文檢索索引鍵或次序資訊，請分別使用 [CONTAINSTABLE](/sql/relational-databases/system-functions/containstable-transact-sql) 或 [FREETEXTTABLE](/sql/relational-databases/system-functions/freetexttable-transact-sql) ，而不要使用 CONTAINS 或 FREETEXT。</span><span class="sxs-lookup"><span data-stu-id="b7311-116">If you only require full-text key or rank information, use [CONTAINSTABLE](/sql/relational-databases/system-functions/containstable-transact-sql) or [FREETEXTTABLE](/sql/relational-databases/system-functions/freetexttable-transact-sql) instead of CONTAINS or FREETEXT, respectively.</span></span>  
  
-   <span data-ttu-id="b7311-117">若要限制結果並提升效能，請使用 FREETEXTTABLE 和 CONTAINSTABLE 函數的 *top_n_by_rank* 參數。</span><span class="sxs-lookup"><span data-stu-id="b7311-117">To limit results and increase performance, use the *top_n_by_rank* parameter of the FREETEXTTABLE and CONTAINSTABLE functions.</span></span> <span data-ttu-id="b7311-118">*top_n_by_rank* 可讓您僅重新叫用最相關的叫用。</span><span class="sxs-lookup"><span data-stu-id="b7311-118">*top_n_by_rank* allows you to recall only the most relevant hits.</span></span> <span data-ttu-id="b7311-119">只有當您的商務狀況不需要重新叫用所有可能的叫用 (亦即，不需要「全部重新叫用」  ) 時，才應該使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="b7311-119">Use this parameter only if your business scenario does not require recalling all possible hits (that is, it does not require *total recall*).</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="b7311-120">全部重新叫用通常是法律狀況的必要項目，但是其重要性可能低於商務狀況的效能，例如電子商務。</span><span class="sxs-lookup"><span data-stu-id="b7311-120">Total recall is typically necessary for legal scenarios but might be less important than performance for business scenarios such as an e-business.</span></span>  
  
-   <span data-ttu-id="b7311-121">請檢查全文檢索查詢計畫，確定已選擇適當的聯結計畫。</span><span class="sxs-lookup"><span data-stu-id="b7311-121">Check the full-text query plan to make sure that the appropriate join plan is chosen.</span></span> <span data-ttu-id="b7311-122">必要的話，請使用聯結提示或查詢提示。</span><span class="sxs-lookup"><span data-stu-id="b7311-122">Use a join hint or query hint if you have to.</span></span> <span data-ttu-id="b7311-123">如果在全文檢索查詢中使用某個參數，該參數的首次值就會決定查詢計畫。</span><span class="sxs-lookup"><span data-stu-id="b7311-123">If a parameter is used in the full-text query, the first-time value of the parameter determines the query plan.</span></span> <span data-ttu-id="b7311-124">您可以使用 OPTIMIZE FOR [查詢提示](/sql/t-sql/queries/hints-transact-sql-query) ，強制查詢使用您想要的值進行編譯。</span><span class="sxs-lookup"><span data-stu-id="b7311-124">You can use the OPTIMIZE FOR [query hint](/sql/t-sql/queries/hints-transact-sql-query) to force the query to compile with the value you want.</span></span> <span data-ttu-id="b7311-125">這有助於達成決定性的查詢計畫和更佳的效能。</span><span class="sxs-lookup"><span data-stu-id="b7311-125">This helps achieve a deterministic query plan and better performance.</span></span>  
  
-   <span data-ttu-id="b7311-126">如果全文檢索索引包含過多全文檢索索引片段，可能會導致查詢效能大幅降低。</span><span class="sxs-lookup"><span data-stu-id="b7311-126">Too many full-text index fragments in the full-text index, can lead to substantial degradation in query performance.</span></span> <span data-ttu-id="b7311-127">若要減少片段的數目，請使用 [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] 陳述式的 REORGANIZE 選項來重新組織全文檢索目錄。</span><span class="sxs-lookup"><span data-stu-id="b7311-127">To reduce the number of fragments, reorganize the full-text catalog by using the REORGANIZE option of the [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] statement.</span></span> <span data-ttu-id="b7311-128">這個陳述式基本上會將所有片段合併成較大的單一片段，然後從全文檢索索引中移除所有已過時的項目。</span><span class="sxs-lookup"><span data-stu-id="b7311-128">This statement essentially merges all the fragments into a single larger fragment and removes all obsolete entries from the full-text index.</span></span>  
  
-   <span data-ttu-id="b7311-129">在全文檢索搜尋中，CONTAINSTABLE (AND, OR) 中指定的邏輯運算子可以實作成 SQL 聯結或在全文檢索執行資料流資料表值函式 (STVF) 內部實作。</span><span class="sxs-lookup"><span data-stu-id="b7311-129">In  full-text search, logical operators specified in CONTAINSTABLE (AND, OR) can be implemented either as SQL joins or inside the full-text execution streaming table-valued functions (STVF).</span></span> <span data-ttu-id="b7311-130">一般而言，只有一種邏輯運算子類型的查詢是完全由全文檢索執行實作，而混合使用邏輯運算子的查詢也會擁有 SQL 聯結。</span><span class="sxs-lookup"><span data-stu-id="b7311-130">Typically, queries with only one type of logical operators are implemented purely by full-text execution, whereas queries that mix logical operators also possess SQL joins.</span></span> <span data-ttu-id="b7311-131">在全文檢索執行 STVF 內部實作邏輯運算子會使用一些特殊索引屬性，讓它的速度比 SQL 聯結更快。</span><span class="sxs-lookup"><span data-stu-id="b7311-131">Implementation of a logical operator inside the full-text execution STVF uses some special index properties that make it much faster than SQL joins.</span></span> <span data-ttu-id="b7311-132">因此，我們建議您盡可能只使用單一邏輯運算子類型來設計查詢。</span><span class="sxs-lookup"><span data-stu-id="b7311-132">For this reason, we recommend that, where possible, you frame queries using only a single type of logical operator.</span></span>  
  
-   <span data-ttu-id="b7311-133">若為包含選擇性關聯述詞的應用程式，當使用選擇性關聯式述詞與非選擇性全文檢索述詞的查詢撰寫成使用查詢最佳化工具時，這些查詢可能會具有最佳效能。</span><span class="sxs-lookup"><span data-stu-id="b7311-133">For applications that contain selective-relation predications, queries that use selective relational predicates and unselective full-text predicates might perform best when they are written to use the query optimizer.</span></span> <span data-ttu-id="b7311-134">這樣做可讓查詢最佳化工具決定它是否可利用述詞或範圍下推來產生有效的查詢計畫。</span><span class="sxs-lookup"><span data-stu-id="b7311-134">This allows the query optimizer to decide whether it can exploit predicate or range pushdown to produce an effective query plan.</span></span> <span data-ttu-id="b7311-135">這種方法比較簡單，而且通常會比將關聯式資料當做全文檢索資料進行索引更有效率。</span><span class="sxs-lookup"><span data-stu-id="b7311-135">This approach is simpler and often more efficient than indexing relational data as full-text data.</span></span>  
  
## <a name="related-resources"></a><span data-ttu-id="b7311-136">相關資源</span><span class="sxs-lookup"><span data-stu-id="b7311-136">Related Resources</span></span>  
 [<span data-ttu-id="b7311-137">SQL Server 2008 全文檢索搜尋：內部和增強功能</span><span class="sxs-lookup"><span data-stu-id="b7311-137">SQL Server 2008 Full-Text Search: Internals and Enhancements</span></span>](https://go.microsoft.com/fwlink/?LinkId=129544)  
  
## <a name="see-also"></a><span data-ttu-id="b7311-138">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b7311-138">See Also</span></span>  
 <span data-ttu-id="b7311-139">[sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="b7311-139">[sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span></span>  
 [<span data-ttu-id="b7311-140">sys.dm_fts_memory_pools &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="b7311-140">sys.dm_fts_memory_pools &#40;Transact-SQL&#41;</span></span>](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-pools-transact-sql)  
  
  
