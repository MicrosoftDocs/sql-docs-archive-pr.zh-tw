---
title: 準備命令 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQL Server Native Client OLE DB provider, commands
- prepared statements [SQL Server Native Client]
- commands [OLE DB]
- command preparation [SQL Server Native Client]
ms.assetid: 09ec0c6c-0a44-4766-b9b7-5092f676ee54
author: rothja
ms.author: jroth
ms.openlocfilehash: e06e6afab622953452a00751e3a55d49fc7b8ec7
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87687878"
---
# <a name="preparing-commands"></a><span data-ttu-id="b7365-102">準備命令</span><span class="sxs-lookup"><span data-stu-id="b7365-102">Preparing Commands</span></span>
  <span data-ttu-id="b7365-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者支援針對單一命令的最佳化多次執行進行命令準備。不過，命令準備會產生負擔，而且取用者不需要準備命令，即可多次執行命令。</span><span class="sxs-lookup"><span data-stu-id="b7365-103">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB provider supports command preparation for optimized multiple execution of a single command; however, command preparation generates overhead, and a consumer does not need to prepare a command to execute it more than once.</span></span> <span data-ttu-id="b7365-104">一般而言，如果某個命令將執行三次以上，您就應該準備此命令。</span><span class="sxs-lookup"><span data-stu-id="b7365-104">In general, a command should be prepared if it will be executed more than three times.</span></span>  
  
 <span data-ttu-id="b7365-105">基於效能的考量，命令準備會延遲到執行命令為止。</span><span class="sxs-lookup"><span data-stu-id="b7365-105">For performance reasons, the command preparation is deferred until the command is executed.</span></span> <span data-ttu-id="b7365-106">此為預設行為。</span><span class="sxs-lookup"><span data-stu-id="b7365-106">This is the default behavior.</span></span> <span data-ttu-id="b7365-107">在執行命令或執行中繼屬性作業之前，無法得知正在準備之命令中的任何錯誤。</span><span class="sxs-lookup"><span data-stu-id="b7365-107">Any errors in the command being prepared are not known until the command is executed or a metaproperty operation is performed.</span></span> <span data-ttu-id="b7365-108">將 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 屬性 SSPROP_DEFERPREPARE 設定為 FALSE 可以關閉此預設行為。</span><span class="sxs-lookup"><span data-stu-id="b7365-108">Setting the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] property SSPROP_DEFERPREPARE to FALSE can turn off this default behavior.</span></span>  
  
 <span data-ttu-id="b7365-109">在 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 中，直接執行命令 (但不先準備命令) 時，系統會建立並快取執行計畫。</span><span class="sxs-lookup"><span data-stu-id="b7365-109">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], when a command is executed directly (without preparing it first), an execution plan is created and cached.</span></span> <span data-ttu-id="b7365-110">如果再次執行了 SQL 陳述式，[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 就會具有高效率演算法，可比對新的陳述式與快取中的現有執行計畫，然後針對該陳述式重複使用此執行計畫。</span><span class="sxs-lookup"><span data-stu-id="b7365-110">If the SQL statement is executed again, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] has an efficient algorithm to match the new statement with the existing execution plan in the cache, and reuses the execution plan for that statement.</span></span>  
  
 <span data-ttu-id="b7365-111">若為準備的命令，[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 會針對準備和執行命令陳述式提供原生支援。</span><span class="sxs-lookup"><span data-stu-id="b7365-111">For prepared commands, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] provides native support for preparing and executing command statements.</span></span> <span data-ttu-id="b7365-112">當您準備陳述式時，[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 會建立執行計畫、快取此計畫，並且將此執行計畫的控制代碼傳回給提供者。</span><span class="sxs-lookup"><span data-stu-id="b7365-112">When you prepare a statement, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] creates an execution plan, caches it, and returns a handle to this execution plan to the provider.</span></span> <span data-ttu-id="b7365-113">然後，提供者會使用此控制代碼來重複執行陳述式。</span><span class="sxs-lookup"><span data-stu-id="b7365-113">The provider then uses this handle to execute the statement repeatedly.</span></span> <span data-ttu-id="b7365-114">此時，系統不會建立任何預存程序。</span><span class="sxs-lookup"><span data-stu-id="b7365-114">No stored procedures are created.</span></span> <span data-ttu-id="b7365-115">因為此控制代碼會直接識別 SQL 陳述式的執行計畫，而非比對陳述式與快取中的執行計畫 (如同直接執行的情況)，所以如果您知道陳述式將執行許多次，準備陳述式會比直接執行更有效率。</span><span class="sxs-lookup"><span data-stu-id="b7365-115">Because the handle directly identifies the execution plan for an SQL statement instead of matching the statement to the execution plan in the cache (as is the case for direct execution), it is more efficient to prepare a statement than to execute it directly, if you know the statement will be executed more than a few times.</span></span>  
  
 <span data-ttu-id="b7365-116">在 [!INCLUDE[ssVersion2005](../../includes/ssversion2005-md.md)] 中，準備的陳述式無法用來建立暫存物件，而且無法參考建立暫存物件 (例如暫存資料表) 的系統預存程序。</span><span class="sxs-lookup"><span data-stu-id="b7365-116">In [!INCLUDE[ssVersion2005](../../includes/ssversion2005-md.md)], the prepared statements cannot be used to create temporary objects and cannot reference system stored procedures that create temporary objects, such as temporary tables.</span></span> <span data-ttu-id="b7365-117">這些程序必須直接執行。</span><span class="sxs-lookup"><span data-stu-id="b7365-117">These procedures must be executed directly.</span></span>  
  
 <span data-ttu-id="b7365-118">您永遠都不應該準備某些命令。</span><span class="sxs-lookup"><span data-stu-id="b7365-118">Some commands should never be prepared.</span></span> <span data-ttu-id="b7365-119">例如，您不應該準備指定預存程序執行或針對 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 預存程序建立包含無效文字的命令。</span><span class="sxs-lookup"><span data-stu-id="b7365-119">For example, commands that specify stored procedure execution or include invalid text for [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] stored procedure creation should not be prepared.</span></span>  
  
 <span data-ttu-id="b7365-120">如果建立了暫存預存程序，[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者就會執行此暫存預存程序，並傳回結果 (如同執行陳述式本身一樣)。</span><span class="sxs-lookup"><span data-stu-id="b7365-120">If a temporary stored procedure is created, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB provider executes the temporary stored procedure, returning results as if the statement itself was executed.</span></span>  
  
 <span data-ttu-id="b7365-121">暫存預存程序建立是由 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者特有的初始化屬性 SSPROP_INIT_USEPROCFORPREP 所控制。</span><span class="sxs-lookup"><span data-stu-id="b7365-121">Temporary stored procedure creation is controlled by the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB provider -specific initialization property SSPROP_INIT_USEPROCFORPREP.</span></span> <span data-ttu-id="b7365-122">如果屬性值為 SSPROPVAL_USEPROCFORPREP_ON 或 SSPROPVAL_USEPROCFORPREP_ON_DROP，[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者就會在準備命令時嘗試建立預存程序。</span><span class="sxs-lookup"><span data-stu-id="b7365-122">If the property value is either SSPROPVAL_USEPROCFORPREP_ON or SSPROPVAL_USEPROCFORPREP_ON_DROP, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB provider attempts to create a stored procedure when a command is prepared.</span></span> <span data-ttu-id="b7365-123">如果應用程式使用者具有足夠的 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 權限，預存程序建立就會成功。</span><span class="sxs-lookup"><span data-stu-id="b7365-123">Stored procedure creation succeeds if the application user has sufficient [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] permissions.</span></span>  
  
 <span data-ttu-id="b7365-124">若為不常中斷連接的取用者，建立暫存預存程序可能會需要 **tempdb** (在其中建立暫存物件的 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 系統資料庫) 的大量資源。</span><span class="sxs-lookup"><span data-stu-id="b7365-124">For consumers that infrequently disconnect, creation of temporary stored procedures can require significant resources of **tempdb**, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] system database in which temporary objects are created.</span></span> <span data-ttu-id="b7365-125">如果 SSPROP_INIT_USEPROCFORPREP 的值為 SSPROPVAL_USEPROCFORPREP_ ON，只有當建立此命令的工作階段中斷與 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 執行個體的連接時，才會卸除 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者所建立的暫存預存程序。</span><span class="sxs-lookup"><span data-stu-id="b7365-125">When the value of SSPROP_INIT_USEPROCFORPREP is SSPROPVAL_USEPROCFORPREP_ ON, temporary stored procedures created by the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB provider are dropped only when the session that created the command loses its connection to the instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="b7365-126">如果該連接是針對資料來源初始化所建立的預設連接，只有當資料來源成為未初始化時，才會卸除暫存預存程序。</span><span class="sxs-lookup"><span data-stu-id="b7365-126">If that connection is the default connection created on data source initialization, the temporary stored procedure is dropped only when the data source becomes uninitialized.</span></span>  
  
 <span data-ttu-id="b7365-127">如果 SSPROP_INIT_USEPROCFORPREP 的值為 SSPROPVAL_USEPROCFORPREP_ON_DROP，發生下列其中一種狀況時，就會卸除 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者的暫存預存程序：</span><span class="sxs-lookup"><span data-stu-id="b7365-127">When the value of SSPROP_INIT_USEPROCFORPREP is SSPROPVAL_USEPROCFORPREP_ON_DROP, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client OLE DB provider temporary stored procedures are dropped when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="b7365-128">取用者使用 **ICommandText::SetCommandText** 來表示新的命令。</span><span class="sxs-lookup"><span data-stu-id="b7365-128">The consumer uses **ICommandText::SetCommandText** to indicate a new command.</span></span>  
  
-   <span data-ttu-id="b7365-129">取用者使用 **ICommandPrepare::Unprepare** 來表示它不再需要命令文字。</span><span class="sxs-lookup"><span data-stu-id="b7365-129">The consumer uses **ICommandPrepare::Unprepare** to indicate that it no longer requires the command text.</span></span>  
  
-   <span data-ttu-id="b7365-130">取用者使用暫存預存程序來釋放命令物件的所有參考。</span><span class="sxs-lookup"><span data-stu-id="b7365-130">The consumer releases all references to the command object using the temporary stored procedure.</span></span>  
  
 <span data-ttu-id="b7365-131">命令物件最多在 **tempdb** 中具有一個暫存預存程序。</span><span class="sxs-lookup"><span data-stu-id="b7365-131">A command object has at most one temporary stored procedure in **tempdb**.</span></span> <span data-ttu-id="b7365-132">任何現有的暫存預存程序都代表特定命令物件的目前命令文字。</span><span class="sxs-lookup"><span data-stu-id="b7365-132">Any existing temporary stored procedure represents the current command text of a specific command object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b7365-133">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b7365-133">See Also</span></span>  
 [<span data-ttu-id="b7365-134">命令</span><span class="sxs-lookup"><span data-stu-id="b7365-134">Commands</span></span>](commands.md)  
  
  
