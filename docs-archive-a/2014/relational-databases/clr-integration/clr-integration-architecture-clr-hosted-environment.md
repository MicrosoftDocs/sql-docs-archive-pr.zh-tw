---
title: CLR 託管環境 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- type-safe code [CLR integration]
- UNSAFE permission set
- run-time environments [CLR integration]
- common language runtime [SQL Server], about CLR integration
- application domains [CLR integration]
- host protection attributes [CLR integration]
- managed code [SQL Server], common language runtime
- permission sets [CLR integration]
- reliability [CLR integration]
- SAFE permission set
- code access security [CLR integration]
- EXTERNAL_ACCESS permission set
- verifying type safety
- scalability [CLR integration]
- hosted environments [CLR integration]
- HPAs [CLR integration]
ms.assetid: d280d359-08f0-47b5-a07e-67dd2a58ad73
author: rothja
ms.author: jroth
ms.openlocfilehash: bd04536d1dfb8a4657fbe116cdfd38a6639a6327
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87704158"
---
# <a name="clr-hosted-environment"></a><span data-ttu-id="436b3-102">CLR 主控環境</span><span class="sxs-lookup"><span data-stu-id="436b3-102">CLR Hosted Environment</span></span>
  <span data-ttu-id="436b3-103">[!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework Common Language Runtime (CLR) 是一個執行許多新式程式語言的環境，包括 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#、[!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic 和 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++。</span><span class="sxs-lookup"><span data-stu-id="436b3-103">The [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR) is an environment that executes many modern programming languages, including [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#, [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic, and [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++.</span></span> <span data-ttu-id="436b3-104">CLR 具備記憶體回收的記憶體、先佔式執行緒、中繼資料服務 (類型反映)、程式碼可驗證性以及程式碼存取安全性。</span><span class="sxs-lookup"><span data-stu-id="436b3-104">The CLR features garbage-collected memory, pre-emptive threading, metadata services (type reflection), code verifiability, and code access security.</span></span> <span data-ttu-id="436b3-105">CLR 會使用中繼資料來找出並載入類別、配置記憶體中的執行個體、解析方法引動過程、產生機器碼、強制使用安全性，和設定執行階段內容界限。</span><span class="sxs-lookup"><span data-stu-id="436b3-105">The CLR uses metadata to locate and load classes, lay out instances in memory, resolve method invocations, generate native code, enforce security, and set run-time context boundaries.</span></span>  
  
 <span data-ttu-id="436b3-106">CLR 與 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 的執行階段環境不同之處在於處理記憶體、執行緒與同步的方式。</span><span class="sxs-lookup"><span data-stu-id="436b3-106">The CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] differ as run-time environments in the way they handle memory, threads, and synchronization.</span></span> <span data-ttu-id="436b3-107">本主題描述整合這兩個執行階段的方式，讓所有系統資源都可以用統一的方式受到管理。</span><span class="sxs-lookup"><span data-stu-id="436b3-107">This topic describes the way in which these two run times are integrated so that all system resources are managed uniformly.</span></span> <span data-ttu-id="436b3-108">本主題也包含整合 CLR 程式碼存取安全性 (CAS) 與 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 安全性的方式，以便提供可靠而安全的執行環境給使用者程式碼。</span><span class="sxs-lookup"><span data-stu-id="436b3-108">This topic also covers the way in which CLR code access security (CAS) and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] security are integrated to provide a reliable and secure execution environment for user code.</span></span>  
  
## <a name="basic-concepts-of-clr-architecture"></a><span data-ttu-id="436b3-109">CLR 架構的基本概念</span><span class="sxs-lookup"><span data-stu-id="436b3-109">Basic Concepts of CLR Architecture</span></span>  
 <span data-ttu-id="436b3-110">在 .NET Framework 中，程式設計人員會以高階語言撰寫，實作定義其結構 (例如，類別的欄位或屬性) 和方法的類別。</span><span class="sxs-lookup"><span data-stu-id="436b3-110">In the .NET Framework, a programmer writes in a high-level language that implements a class defining its structure (for example, the fields or properties of the class) and methods.</span></span> <span data-ttu-id="436b3-111">這些方法中有部分可以是靜態函數。</span><span class="sxs-lookup"><span data-stu-id="436b3-111">Some of these methods can be static functions.</span></span> <span data-ttu-id="436b3-112">編譯程式會產生一個稱為組件的檔案，其中包含利用 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] 中繼語言 (MSIL) 編譯的程式碼，以及包含相依組件所有參考的資訊清單。</span><span class="sxs-lookup"><span data-stu-id="436b3-112">The compilation of the program produces a file called an assembly that contains the compiled code in the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL), and a manifest that contains all references to dependent assemblies.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="436b3-113">組件是 CLR 架構中的重要元素。</span><span class="sxs-lookup"><span data-stu-id="436b3-113">Assemblies are a vital element in the architecture of the CLR.</span></span> <span data-ttu-id="436b3-114">它們是 .NET Framework 中，應用程式程式碼之封裝、部署與版本控制的單位。</span><span class="sxs-lookup"><span data-stu-id="436b3-114">They are the units of packaging, deployment, and versioning of application code in the .NET Framework.</span></span> <span data-ttu-id="436b3-115">您可以使用組件來部署資料庫內部的應用程式程式碼，並提供一個統一的方式來管理、備份與還原完整資料庫應用程式。</span><span class="sxs-lookup"><span data-stu-id="436b3-115">Using assemblies, you can deploy application code inside the database and provide a uniform way to administer, back up, and restore complete database applications.</span></span>  
  
 <span data-ttu-id="436b3-116">組件資訊清單包含組件的相關中繼資料，描述程式中定義的所有結構、欄位、屬性、類別、繼承關聯性、函數以及方法。</span><span class="sxs-lookup"><span data-stu-id="436b3-116">The assembly manifest contains metadata about the assembly, describing all of the structures, fields, properties, classes, inheritance relationships, functions, and methods defined in the program.</span></span> <span data-ttu-id="436b3-117">資訊清單會建立組件識別、指定組成組件實作的檔案、指定組成組件的類型和資源、列舉對其他組件的編譯時間相依性，並且指定組件正確執行所需的權限集合。</span><span class="sxs-lookup"><span data-stu-id="436b3-117">The manifest establishes the assembly identity, specifies the files that make up the assembly implementation, specifies the types and resources that make up the assembly, itemizes the compile-time dependencies on other assemblies, and specifies the set of permissions required for the assembly to run properly.</span></span> <span data-ttu-id="436b3-118">執行階段時會使用這個資訊來解析參考、強制執行版本繫結原則，以及驗證載入組件的完整性。</span><span class="sxs-lookup"><span data-stu-id="436b3-118">This information is used at run time to resolve references, enforce version binding policy, and validate the integrity of loaded assemblies.</span></span>  
  
 <span data-ttu-id="436b3-119">.NET Framework 支援註解類別、屬性 (Property)、函數和方法的自訂屬性 (Attribute)，以及應用程式可以在中繼資料中擷取的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="436b3-119">The .NET Framework supports custom attributes for annotating classes, properties, functions, and methods with additional information the application may capture in metadata.</span></span> <span data-ttu-id="436b3-120">所有 .NET Framework 編譯器都可以在不解譯的情況下使用這些註解，並將其當做組件中繼資料儲存。</span><span class="sxs-lookup"><span data-stu-id="436b3-120">All .NET Framework compilers consume these annotations without interpretation and store them as assembly metadata.</span></span> <span data-ttu-id="436b3-121">這些註解可以使用與其他任何中繼資料相同的方式檢查。</span><span class="sxs-lookup"><span data-stu-id="436b3-121">These annotations can be examined in the same way as any other metadata.</span></span>  
  
 <span data-ttu-id="436b3-122">Managed 程式碼是在 CLR 中以 MSIL 執行，而非直接由作業系統執行。</span><span class="sxs-lookup"><span data-stu-id="436b3-122">Managed code is MSIL executed in the CLR, rather than directly by the operating system.</span></span> <span data-ttu-id="436b3-123">Managed 程式碼應用程式會取得自動記憶體回收、執行階段類型檢查和安全性支援等 CLR 服務。</span><span class="sxs-lookup"><span data-stu-id="436b3-123">Managed code applications acquire CLR services, such as automatic garbage collection, run-time type checking, and security support.</span></span> <span data-ttu-id="436b3-124">這些服務會協助提供統一的 Managed 程式碼應用程式行為 (與平台和語言無關)。</span><span class="sxs-lookup"><span data-stu-id="436b3-124">These services help provide uniform platform- and language-independent behavior of managed code applications.</span></span>  
  
## <a name="design-goals-of-clr-integration"></a><span data-ttu-id="436b3-125">CLR 整合的設計目標</span><span class="sxs-lookup"><span data-stu-id="436b3-125">Design Goals of CLR Integration</span></span>  
 <span data-ttu-id="436b3-126">當使用者程式碼在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] (稱為 CLR 整合) 之 CLR 主控環境內部執行時，適用下列設計目標：</span><span class="sxs-lookup"><span data-stu-id="436b3-126">When user code runs inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] (called CLR integration), the following design goals apply:</span></span>  
  
###### <a name="reliability-safety"></a><span data-ttu-id="436b3-127">可靠性 (安全性)</span><span class="sxs-lookup"><span data-stu-id="436b3-127">Reliability (Safety)</span></span>  
 <span data-ttu-id="436b3-128">系統不允許使用者程式碼執行危害 Database Engine 程序完整性的作業，例如，彈出要求使用者回應或結束程序的訊息方塊。</span><span class="sxs-lookup"><span data-stu-id="436b3-128">User code should not be allowed to perform operations that compromise the integrity of the Database Engine process, such as popping a message box requesting a user response or exiting the process.</span></span> <span data-ttu-id="436b3-129">使用者程式碼應該無法覆寫 Database Engine 記憶體緩衝區或內部資料結構。</span><span class="sxs-lookup"><span data-stu-id="436b3-129">User code should not be able to overwrite Database Engine memory buffers or internal data structures.</span></span>  
  
###### <a name="scalability"></a><span data-ttu-id="436b3-130">延展性</span><span class="sxs-lookup"><span data-stu-id="436b3-130">Scalability</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="436b3-131">和 CLR 針對排程和記憶體管理，擁有不同的內部模型。</span><span class="sxs-lookup"><span data-stu-id="436b3-131">and the CLR have different internal models for scheduling and memory management.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="436b3-132">會在執行緒主動產生定期執行的情況下，或它們要等待鎖定或 I/O 時，支援合作式、非先佔式執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="436b3-132">supports a cooperative, non-preemptive threading model in which the threads voluntarily yield execution periodically, or when they are waiting on locks or I/O.</span></span> <span data-ttu-id="436b3-133">CLR 支援先佔式執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="436b3-133">The CLR supports a preemptive threading model.</span></span> <span data-ttu-id="436b3-134">如果在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 內部執行的使用者程式碼可以直接呼叫作業系統執行緒原始物件，則它不會完整整合到 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 工作排程器，而且可能會降低系統的延展性。</span><span class="sxs-lookup"><span data-stu-id="436b3-134">If user code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can directly call the operating system threading primitives, then it does not integrate well into the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] task scheduler and can degrade the scalability of the system.</span></span> <span data-ttu-id="436b3-135">CLR 不會區別虛擬記憶體和實體記憶體，但是 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 會直接管理實體記憶體，而且需要在可設定的限制內使用實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="436b3-135">The CLR does not distinguish between virtual and physical memory, but [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] directly manages physical memory and is required to use physical memory within a configurable limit.</span></span>  
  
 <span data-ttu-id="436b3-136">用於執行緒、排序和記憶體管理的不同模型對於調整為支援數千個並行使用者工作階段的關聯式資料庫管理系統 (RDBMS) 會呈現整合性問題。</span><span class="sxs-lookup"><span data-stu-id="436b3-136">The different models for threading, scheduling, and memory management present an integration challenge for a relational database management system (RDBMS) that scales to support thousands of concurrent user sessions.</span></span> <span data-ttu-id="436b3-137">此架構應該確認針對執行緒、記憶體和同步處理原始物件直接呼叫應用程式開發介面 (API) 的使用者程式碼不會危害系統的延展性。</span><span class="sxs-lookup"><span data-stu-id="436b3-137">The architecture should ensure that the scalability of the system is not compromised by user code calling application programming interfaces (APIs) for threading, memory, and synchronization primitives directly.</span></span>  
  
###### <a name="security"></a><span data-ttu-id="436b3-138">安全性</span><span class="sxs-lookup"><span data-stu-id="436b3-138">Security</span></span>  
 <span data-ttu-id="436b3-139">存取資料表或資料行之類的資料庫物件時，在資料庫中執行的使用者程式碼必須遵循 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 驗證和授權規則。</span><span class="sxs-lookup"><span data-stu-id="436b3-139">User code running in the database must follow [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] authentication and authorization rules when accessing database objects such as tables and columns.</span></span> <span data-ttu-id="436b3-140">此外，資料庫管理員應該能夠從資料庫中執行的使用者程式碼控制作業系統資源的存取權，例如檔案和網路存取權。</span><span class="sxs-lookup"><span data-stu-id="436b3-140">In addition, database administrators should be able to control access to operating system resources, such as files and network access, from user code running in the database.</span></span> <span data-ttu-id="436b3-141">由於 Managed 程式語言 (不像 Transact-SQL 之類的非 Managed 語言) 提供 API 來存取這類資源，因此這變得相當重要。</span><span class="sxs-lookup"><span data-stu-id="436b3-141">This becomes important as managed programming languages (unlike non-managed languages such as Transact-SQL) provide APIs to access such resources.</span></span> <span data-ttu-id="436b3-142">系統必須為使用者程式碼提供一個安全的方式來存取 [!INCLUDE[ssDE](../../../includes/ssde-md.md)] 處理序外部的電腦資源。</span><span class="sxs-lookup"><span data-stu-id="436b3-142">The system must provide a secure way for user code to access machine resources outside the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] process.</span></span> <span data-ttu-id="436b3-143">如需相關資訊，請參閱 [CLR Integration Security](security/clr-integration-security.md)。</span><span class="sxs-lookup"><span data-stu-id="436b3-143">For more information, see [CLR Integration Security](security/clr-integration-security.md).</span></span>  
  
###### <a name="performance"></a><span data-ttu-id="436b3-144">效能</span><span class="sxs-lookup"><span data-stu-id="436b3-144">Performance</span></span>  
 <span data-ttu-id="436b3-145">在 [!INCLUDE[ssDE](../../../includes/ssde-md.md)] 中執行的 Managed 使用者程式碼應該擁有可與在伺服器外部執行之相同程式碼相比的計算效能。</span><span class="sxs-lookup"><span data-stu-id="436b3-145">Managed user code running in the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] should have computational performance comparable to the same code run outside the server.</span></span> <span data-ttu-id="436b3-146">從 Managed 使用者程式碼進行資料庫存取的速度不如原生 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 快。</span><span class="sxs-lookup"><span data-stu-id="436b3-146">Database access from managed user code is not as fast as native [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="436b3-147">如需詳細資訊，請參閱[CLR 整合的效能](clr-integration-architecture-performance.md)。</span><span class="sxs-lookup"><span data-stu-id="436b3-147">For more information, see [Performance of CLR Integration](clr-integration-architecture-performance.md).</span></span>  
  
## <a name="clr-services"></a><span data-ttu-id="436b3-148">CLR Services</span><span class="sxs-lookup"><span data-stu-id="436b3-148">CLR Services</span></span>  
 <span data-ttu-id="436b3-149">CLR 提供數種服務協助達成 CLR 與 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 整合的設計目標。</span><span class="sxs-lookup"><span data-stu-id="436b3-149">The CLR provides a number of services to help achieve the design goals of CLR integration with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
###### <a name="type-safety-verification"></a><span data-ttu-id="436b3-150">類型安全性驗證</span><span class="sxs-lookup"><span data-stu-id="436b3-150">Type safety verification</span></span>  
 <span data-ttu-id="436b3-151">類型安全程式碼是只以妥善定義的方式存取記憶體結構的程式碼。</span><span class="sxs-lookup"><span data-stu-id="436b3-151">Type-safe code is code that accesses memory structures only in well-defined ways.</span></span> <span data-ttu-id="436b3-152">例如，在有一個有效的物件參考上，類型安全程式碼可以存取和實際欄位成員對應的固定位移上的記憶體。</span><span class="sxs-lookup"><span data-stu-id="436b3-152">For example, given a valid object reference, type-safe code can access memory at fixed offsets corresponding to actual field members.</span></span> <span data-ttu-id="436b3-153">然而，如果程式碼存取的記憶體，是位於該物件所屬記憶體範圍以內或以外的任意位移時，即不是類型安全。</span><span class="sxs-lookup"><span data-stu-id="436b3-153">However, if the code accesses memory at arbitrary offsets inside or outside the range of memory that belongs to the object, then it is not type-safe.</span></span> <span data-ttu-id="436b3-154">當組件載入 CLR 時，在要使用 Just-In-Time (JIT) 編譯來編譯的 MSIL 前，執行階段會執行一個檢查程式碼來判斷其類型安全性的驗證階段。</span><span class="sxs-lookup"><span data-stu-id="436b3-154">When assemblies are loaded in the CLR, prior to the MSIL being compiled using just-in-time (JIT) compilation, the runtime performs a verification phase that examines code to determine its type-safety.</span></span> <span data-ttu-id="436b3-155">成功通過此驗證的程式碼稱為可驗證類型安全 (verifiably type-safe) 的程式碼。</span><span class="sxs-lookup"><span data-stu-id="436b3-155">Code that successfully passes this verification is called verifiably type-safe code.</span></span>  
  
###### <a name="application-domains"></a><span data-ttu-id="436b3-156">應用程式網域</span><span class="sxs-lookup"><span data-stu-id="436b3-156">Application domains</span></span>  
 <span data-ttu-id="436b3-157">CLR 支援應用程式網域的概念，做為主機處理序內的執行區域，其中可以載入與執行 Managed 程式碼組件。</span><span class="sxs-lookup"><span data-stu-id="436b3-157">The CLR supports the notion of application domains as execution zones within a host process where managed code assemblies can be loaded and executed.</span></span> <span data-ttu-id="436b3-158">應用程式網域界限提供組件間的隔離。</span><span class="sxs-lookup"><span data-stu-id="436b3-158">The application domain boundary provides isolation between assemblies.</span></span> <span data-ttu-id="436b3-159">組件會透過靜態變數與資料成員的可見性，以及動態呼叫程式碼的能力隔離。</span><span class="sxs-lookup"><span data-stu-id="436b3-159">The assemblies are isolated in terms of visibility of static variables and data members and the ability to call code dynamically.</span></span> <span data-ttu-id="436b3-160">應用程式網域也是載入和卸載程式碼的機制。</span><span class="sxs-lookup"><span data-stu-id="436b3-160">Application domains are also the mechanism for loading and unloading code.</span></span> <span data-ttu-id="436b3-161">程式碼只能透過卸載應用程式網域來從記憶體卸載。</span><span class="sxs-lookup"><span data-stu-id="436b3-161">Code can be unloaded from memory only by unloading the application domain.</span></span> <span data-ttu-id="436b3-162">如需詳細資訊，請參閱[應用程式域和 CLR 整合安全性](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md)。</span><span class="sxs-lookup"><span data-stu-id="436b3-162">For more information, see [Application Domains and CLR Integration Security](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md).</span></span>  
  
###### <a name="code-access-security-cas"></a><span data-ttu-id="436b3-163">程式碼存取安全性 (CAS)</span><span class="sxs-lookup"><span data-stu-id="436b3-163">Code Access Security (CAS)</span></span>  
 <span data-ttu-id="436b3-164">CLR 安全性系統提供一種方式來控制 Managed 程式碼可以透過指派權限給程式碼來執行的作業種類。</span><span class="sxs-lookup"><span data-stu-id="436b3-164">The CLR security system provides a way to control what kinds of operations managed code can perform by assigning permissions to code.</span></span> <span data-ttu-id="436b3-165">程式碼存取權限是根據程式碼識別指派的 (例如，組件的簽章或程式碼的來源)。</span><span class="sxs-lookup"><span data-stu-id="436b3-165">Code access permissions are assigned based on code identity (for example, the signature of the assembly or the origin of the code).</span></span>  
  
 <span data-ttu-id="436b3-166">CLR 會提供電腦管理員可以設定的電腦通用原則。</span><span class="sxs-lookup"><span data-stu-id="436b3-166">The CLR provides for a computer-wide policy that can be set by the computer administrator.</span></span> <span data-ttu-id="436b3-167">此原則會針對在電腦上執行的任何 Managed 程式碼定義權限授權。</span><span class="sxs-lookup"><span data-stu-id="436b3-167">This policy defines the permission grants for any managed code running on the machine.</span></span> <span data-ttu-id="436b3-168">此外，在 Managed 程式碼上有一個主機 (例如 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]) 可以使用的主機層級安全性原則來指定額外的限制。</span><span class="sxs-lookup"><span data-stu-id="436b3-168">In addition, there is a host-level security policy that can be used by hosts such as [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to specify additional restrictions on managed code.</span></span>  
  
 <span data-ttu-id="436b3-169">如果 .NET Framework 中的 Managed API 會公開受程式碼存取權限保護之資源的作業，則 API 將會在存取資源前要求權限。</span><span class="sxs-lookup"><span data-stu-id="436b3-169">If a managed API in the .NET Framework exposes operations on resources that are protected by a code access permission, the API will demand that permission before accessing the resource.</span></span> <span data-ttu-id="436b3-170">此要求會使 CLR 安全性系統在呼叫堆疊中觸發每個程式碼單位 (組件) 的完整檢查。</span><span class="sxs-lookup"><span data-stu-id="436b3-170">This demand causes the CLR security system to trigger a comprehensive check of every unit of code (assembly) in the call stack.</span></span> <span data-ttu-id="436b3-171">只有在整個呼叫鏈結都有權限時，才會存取要授與的資源。</span><span class="sxs-lookup"><span data-stu-id="436b3-171">Only if the entire call chain has permission will access to the resource be granted.</span></span>  
  
 <span data-ttu-id="436b3-172">請注意，在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 的 CLR 主控環境內部，不支援使用 Reflection.Emit API 動態產生 Managed 程式碼的功能。</span><span class="sxs-lookup"><span data-stu-id="436b3-172">Note that the ability to generate managed code dynamically, using the Reflection.Emit API, is not supported inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="436b3-173">此種程式碼將沒有要執行的 CAS 權限，因此會在執行階段失敗。</span><span class="sxs-lookup"><span data-stu-id="436b3-173">Such code would not have the CAS permissions to run and would therefore fail at run time.</span></span> <span data-ttu-id="436b3-174">如需詳細資訊，請參閱[CLR 整合代碼啟用安全性](security/clr-integration-code-access-security.md)。</span><span class="sxs-lookup"><span data-stu-id="436b3-174">For more information, see [CLR Integration Code Access Security](security/clr-integration-code-access-security.md).</span></span>  
  
###### <a name="host-protection-attributes-hpas"></a><span data-ttu-id="436b3-175">主機保護屬性 (HPA)</span><span class="sxs-lookup"><span data-stu-id="436b3-175">Host Protection Attributes (HPAs)</span></span>  
 <span data-ttu-id="436b3-176">CLR 會提供一個機制來使用 CLR 主機可能需要的某些屬性，為屬於 .NET Framework 之一部分的 Managed API 加註。</span><span class="sxs-lookup"><span data-stu-id="436b3-176">The CLR provides a mechanism to annotate managed APIs that are part of the .NET Framework with certain attributes that may be of interest to a host of the CLR.</span></span> <span data-ttu-id="436b3-177">這類屬性的範例包括：</span><span class="sxs-lookup"><span data-stu-id="436b3-177">Examples of such attributes include:</span></span>  
  
-   <span data-ttu-id="436b3-178">SharedState，它可指出 API 是否會公開建立或管理共用狀態 (如靜態類別欄位) 的功能。</span><span class="sxs-lookup"><span data-stu-id="436b3-178">SharedState, which indicates whether the API exposes the ability to create or manage shared state (for example, static class fields).</span></span>  
  
-   <span data-ttu-id="436b3-179">Synchronization，它可指出 API 是否會公開執行執行緒之間之同步處理的功能。</span><span class="sxs-lookup"><span data-stu-id="436b3-179">Synchronization, which indicates whether the API exposes the ability to perform synchronization between threads.</span></span>  
  
-   <span data-ttu-id="436b3-180">ExternalProcessMgmt，它可指出 API 是否會公開控制主機處理序的方法。</span><span class="sxs-lookup"><span data-stu-id="436b3-180">ExternalProcessMgmt, which indicates whether the API exposes a way to control the host process.</span></span>  
  
 <span data-ttu-id="436b3-181">當提供了這些屬性時，主機可以指定 HPA (如 SharedState 屬性) 的清單，在主控環境內應該不允許使用這些 HPA。</span><span class="sxs-lookup"><span data-stu-id="436b3-181">Given these attributes, the host can specify a list of HPAs, such as the SharedState attribute, that should be disallowed in the hosted environment.</span></span> <span data-ttu-id="436b3-182">在此情況下，CLR 會拒絕使用者程式碼嘗試呼叫 HPA 在禁止清單中加註的 API。</span><span class="sxs-lookup"><span data-stu-id="436b3-182">In this case, the CLR denies attempts by user code to call APIs that are annotated by the HPAs in the prohibited list.</span></span> <span data-ttu-id="436b3-183">如需詳細資訊，請參閱[主控制項保護屬性和 CLR 整合程式設計](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="436b3-183">For more information, see [Host Protection Attributes and CLR Integration Programming](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md).</span></span>  
  
## <a name="how-sql-server-and-the-clr-work-together"></a><span data-ttu-id="436b3-184">SQL Server 和 CLR 如何一起運作</span><span class="sxs-lookup"><span data-stu-id="436b3-184">How SQL Server and the CLR Work Together</span></span>  
 <span data-ttu-id="436b3-185">本節討論 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 如何整合 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 和 CLR 的執行緒、排程、同步處理以及記憶體管理模型。</span><span class="sxs-lookup"><span data-stu-id="436b3-185">This section discusses how [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integrates the threading, scheduling, synchronization, and memory management models of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR.</span></span> <span data-ttu-id="436b3-186">特別是，本節會按照延展性、可靠性以及安全性目標來檢查整合效果。</span><span class="sxs-lookup"><span data-stu-id="436b3-186">In particular, this section examines the integration in light of scalability, reliability, and security goals.</span></span> <span data-ttu-id="436b3-187">當 CLR 裝載到 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 內部時，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 實質上會當做它的作業系統。</span><span class="sxs-lookup"><span data-stu-id="436b3-187">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] essentially acts as the operating system for the CLR when it is hosted inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="436b3-188">CLR 會針對執行緒、排程、同步處理與記憶體管理，呼叫 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 所實作的低階常式。</span><span class="sxs-lookup"><span data-stu-id="436b3-188">The CLR calls low-level routines implemented by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for threading, scheduling, synchronization, and memory management.</span></span> <span data-ttu-id="436b3-189">這些是其餘 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 引擎所使用的相同原始物件。</span><span class="sxs-lookup"><span data-stu-id="436b3-189">These are the same primitives that the rest of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] engine uses.</span></span> <span data-ttu-id="436b3-190">此方法提供數個延展性、可靠性與安全性優勢。</span><span class="sxs-lookup"><span data-stu-id="436b3-190">This approach provides several scalability, reliability, and security benefits.</span></span>  
  
###### <a name="scalability-common-threading-scheduling-and-synchronization"></a><span data-ttu-id="436b3-191">延展性：一般執行緒、排程與同步處理</span><span class="sxs-lookup"><span data-stu-id="436b3-191">Scalability: Common threading, scheduling, and synchronization</span></span>  
 <span data-ttu-id="436b3-192">CLR 會呼叫 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] API 來建立執行緒，以便同時用於執行中的使用者程式碼和自己的內部用途。</span><span class="sxs-lookup"><span data-stu-id="436b3-192">CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] APIs for creating threads, both for running user code and for its own internal use.</span></span> <span data-ttu-id="436b3-193">若要在多個執行緒之間同步處理，CLR 會呼叫 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="436b3-193">In order to synchronize between multiple threads, the CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] synchronization objects.</span></span> <span data-ttu-id="436b3-194">當執行緒正在等待同步處理物件時，這可讓 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 排程器來排程其他工作。</span><span class="sxs-lookup"><span data-stu-id="436b3-194">This allows the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler to schedule other tasks when a thread is waiting on a synchronization object.</span></span> <span data-ttu-id="436b3-195">例如，當 CLR 起始記憶體回收時，其所有執行緒都會等待記憶體回收完成。</span><span class="sxs-lookup"><span data-stu-id="436b3-195">For example, when the CLR initiates garbage collection, all of its threads wait for garbage collection to finish.</span></span> <span data-ttu-id="436b3-196">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 排程器知道它們所等待的 CLR 執行緒與同步處理物件，因此，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以排程正在執行與 CLR 無關之其他資料庫工作的執行緒。</span><span class="sxs-lookup"><span data-stu-id="436b3-196">Because the CLR threads and the synchronization objects they are waiting on are known to the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can schedule threads that are running other database tasks not involving the CLR.</span></span> <span data-ttu-id="436b3-197">這也可以讓 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 偵測到包含 CLR 同步處理物件所採用之鎖定的死結，並採用傳統的技術來移除死結。</span><span class="sxs-lookup"><span data-stu-id="436b3-197">This also enables [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to detect deadlocks that involve locks taken by CLR synchronization objects and employ traditional techniques for deadlock removal.</span></span>  
  
 <span data-ttu-id="436b3-198">Managed 程式在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中會以先佔式執行。</span><span class="sxs-lookup"><span data-stu-id="436b3-198">Managed code runs preemptively in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="436b3-199">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 排程器可以偵測和停止需要大量時間產生的執行緒。</span><span class="sxs-lookup"><span data-stu-id="436b3-199">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler has the ability to detect and stop threads that have not yielded for a significant amount of time.</span></span> <span data-ttu-id="436b3-200">能夠將 CLR 執行緒攔截到 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 執行緒意味著 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 排程器可以在 CLR 中識別「失控的」執行緒，並管理其優先順序。</span><span class="sxs-lookup"><span data-stu-id="436b3-200">The ability to hook CLR threads to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] threads implies that the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler can identify "runaway" threads in the CLR and manage their priority.</span></span> <span data-ttu-id="436b3-201">這種失控的執行緒會暫停，並放回到佇列中。</span><span class="sxs-lookup"><span data-stu-id="436b3-201">Such runaway threads are suspended and put back in the queue.</span></span> <span data-ttu-id="436b3-202">系統不允許重複識別為失控執行緒的執行緒在給定的期間內執行，讓其他執行中的工作者得以執行。</span><span class="sxs-lookup"><span data-stu-id="436b3-202">Threads that are repeatedly identified as runaway threads are not allowed to run for a given period of time so that other executing workers can run.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="436b3-203">存取資料或配置足夠記憶體來觸發記憶體回收之長時間執行的 Managed 程式碼將會自動產生。</span><span class="sxs-lookup"><span data-stu-id="436b3-203">Long-running managed code that accesses data or allocates enough memory to trigger garbage collection will yield automatically.</span></span> <span data-ttu-id="436b3-204">不會存取資料或配置足夠的 Managed 記憶體來觸發記憶體回收之長時間執行的 Managed 程式碼應該透過呼叫 .NET Framework 的 System.Thread.Sleep() 函數來明確地產生。</span><span class="sxs-lookup"><span data-stu-id="436b3-204">Long-running managed code that does not access data or allocate enough managed memory to trigger garbage collection should explicitly yield by calling the System.Thread.Sleep() function of the .NET Framework.</span></span>  
  
###### <a name="scalability-common-memory-management"></a><span data-ttu-id="436b3-205">延展性：一般記憶體管理</span><span class="sxs-lookup"><span data-stu-id="436b3-205">Scalability: Common memory management</span></span>  
 <span data-ttu-id="436b3-206">CLR 會呼叫 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 原始物件來配置與取消配置其記憶體。</span><span class="sxs-lookup"><span data-stu-id="436b3-206">The CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] primitives for allocating and de-allocating its memory.</span></span> <span data-ttu-id="436b3-207">在系統的記憶體總使用量中包含 CLR 所使用的記憶體，因此，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以維持在其設定的記憶體限制內，而且可以確保 CLR 和 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 不會爭用彼此的記憶體。</span><span class="sxs-lookup"><span data-stu-id="436b3-207">Because the memory used by the CLR is accounted for in the total memory usage of the system, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can stay within its configured memory limits and ensure the CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] are not competing with each other for memory.</span></span> <span data-ttu-id="436b3-208">當系統記憶體受到限制時，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 也可以拒絕 CLR 記憶體要求，而且在其他工作需要記憶體時，可以要求 CLR 減少其記憶體的使用量。</span><span class="sxs-lookup"><span data-stu-id="436b3-208">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can also reject CLR memory requests when system memory is constrained, and ask CLR to reduce its memory use when other tasks need memory.</span></span>  
  
###### <a name="reliability-application-domains-and-unrecoverable-exceptions"></a><span data-ttu-id="436b3-209">可靠性：應用程式網域和無法復原的例外狀況</span><span class="sxs-lookup"><span data-stu-id="436b3-209">Reliability: Application domains and unrecoverable exceptions</span></span>  
 <span data-ttu-id="436b3-210">當 .NET Framework API 中的 Managed 程式碼遇到嚴重的例外狀況 (例如，記憶體不足或堆疊溢位) 時，不一定能夠從這類的失敗復原，也不一定能夠確保其實作的一致且正確的語意。</span><span class="sxs-lookup"><span data-stu-id="436b3-210">When managed code in the .NET Framework APIs encounters critical exceptions, such as out-of-memory or stack overflow, it is not always possible to recover from such failures and ensure consistent and correct semantics for their implementation.</span></span> <span data-ttu-id="436b3-211">這些 API 會引發執行緒中止的例外狀況來回應這些失敗。</span><span class="sxs-lookup"><span data-stu-id="436b3-211">These APIs raise a thread abort exception in response to these failures.</span></span>  
  
 <span data-ttu-id="436b3-212">在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中主控時，此類執行緒中止的處理方式如下：CLR 會在執行緒中止發生所在的應用程式網域中偵測任何共用狀態。</span><span class="sxs-lookup"><span data-stu-id="436b3-212">When hosted in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], such thread aborts are handled as follows: the CLR detects any shared state in the application domain in which the thread abort occurs.</span></span> <span data-ttu-id="436b3-213">CLR 會透過檢查同步處理物件是否存在來進行。</span><span class="sxs-lookup"><span data-stu-id="436b3-213">The CLR does this by checking for the presence of synchronization objects.</span></span> <span data-ttu-id="436b3-214">如果在應用程式網域中有共用狀態，則會卸載應用程式網域本身。</span><span class="sxs-lookup"><span data-stu-id="436b3-214">If there is shared state in the application domain, then the application domain itself is unloaded.</span></span> <span data-ttu-id="436b3-215">卸載應用程式網域時，會停止目前正在該應用程式網域中執行的資料庫交易。</span><span class="sxs-lookup"><span data-stu-id="436b3-215">The unloading of the application domain stops database transactions that are currently running in that application domain.</span></span> <span data-ttu-id="436b3-216">因為共用狀態的存在可能會擴大此類嚴重例外狀況對於使用者工作階段的影響，而非觸發例外狀況的影響，因此，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 和 CLR 已經採取步驟來降低共用狀態的可能性。</span><span class="sxs-lookup"><span data-stu-id="436b3-216">Because the presence of shared state can widen the impact of such critical exceptions to user sessions other than the one triggering the exception, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR have taken steps to reduce the likelihood of shared state.</span></span> <span data-ttu-id="436b3-217">如需詳細資訊，請參閱 .NET Framework 文件集。</span><span class="sxs-lookup"><span data-stu-id="436b3-217">For more information, see the .NET Framework documentation.</span></span>  
  
###### <a name="security-permission-sets"></a><span data-ttu-id="436b3-218">安全性：權限集合</span><span class="sxs-lookup"><span data-stu-id="436b3-218">Security: Permission sets</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="436b3-219">可讓使用者針對資料庫中部署的程式碼指定可靠性和安全性需求。</span><span class="sxs-lookup"><span data-stu-id="436b3-219">allows users to specify the reliability and security requirements for code deployed into the database.</span></span> <span data-ttu-id="436b3-220">當組件上傳到資料庫中時，組件的作者可以為該組件指定以下三個使用權限集合當中的一個：SAFE、EXTERNAL_ACCESS 和 UNSAFE。</span><span class="sxs-lookup"><span data-stu-id="436b3-220">When assemblies are uploaded into the database, the author of the assembly can specify one of three permission sets for that assembly: SAFE, EXTERNAL_ACCESS and UNSAFE.</span></span>  
  
|||||  
|-|-|-|-|  
|<span data-ttu-id="436b3-221">權限集合</span><span class="sxs-lookup"><span data-stu-id="436b3-221">Permission set</span></span>|<span data-ttu-id="436b3-222">SAFE</span><span class="sxs-lookup"><span data-stu-id="436b3-222">SAFE</span></span>|<span data-ttu-id="436b3-223">EXTERNAL_ACCESS</span><span class="sxs-lookup"><span data-stu-id="436b3-223">EXTERNAL_ACCESS</span></span>|<span data-ttu-id="436b3-224">UNSAFE</span><span class="sxs-lookup"><span data-stu-id="436b3-224">UNSAFE</span></span>|  
|<span data-ttu-id="436b3-225">程式碼存取安全性</span><span class="sxs-lookup"><span data-stu-id="436b3-225">Code Access Security</span></span>|<span data-ttu-id="436b3-226">僅限 Execute</span><span class="sxs-lookup"><span data-stu-id="436b3-226">Execute only</span></span>|<span data-ttu-id="436b3-227">對外部資源的 Execute + 存取權</span><span class="sxs-lookup"><span data-stu-id="436b3-227">Execute + access to external resources</span></span>|<span data-ttu-id="436b3-228">不受限制</span><span class="sxs-lookup"><span data-stu-id="436b3-228">Unrestricted</span></span>|  
|<span data-ttu-id="436b3-229">程式設計模型限制</span><span class="sxs-lookup"><span data-stu-id="436b3-229">Programming model restrictions</span></span>|<span data-ttu-id="436b3-230">是</span><span class="sxs-lookup"><span data-stu-id="436b3-230">Yes</span></span>|<span data-ttu-id="436b3-231">是</span><span class="sxs-lookup"><span data-stu-id="436b3-231">Yes</span></span>|<span data-ttu-id="436b3-232">沒有限制</span><span class="sxs-lookup"><span data-stu-id="436b3-232">No restrictions</span></span>|  
|<span data-ttu-id="436b3-233">可驗證性需求</span><span class="sxs-lookup"><span data-stu-id="436b3-233">Verifiability requirement</span></span>|<span data-ttu-id="436b3-234">是</span><span class="sxs-lookup"><span data-stu-id="436b3-234">Yes</span></span>|<span data-ttu-id="436b3-235">是</span><span class="sxs-lookup"><span data-stu-id="436b3-235">Yes</span></span>|<span data-ttu-id="436b3-236">否</span><span class="sxs-lookup"><span data-stu-id="436b3-236">No</span></span>|  
|<span data-ttu-id="436b3-237">呼叫機器碼的能力</span><span class="sxs-lookup"><span data-stu-id="436b3-237">Ability to call native code</span></span>|<span data-ttu-id="436b3-238">否</span><span class="sxs-lookup"><span data-stu-id="436b3-238">No</span></span>|<span data-ttu-id="436b3-239">否</span><span class="sxs-lookup"><span data-stu-id="436b3-239">No</span></span>|<span data-ttu-id="436b3-240">是</span><span class="sxs-lookup"><span data-stu-id="436b3-240">Yes</span></span>|  
  
 <span data-ttu-id="436b3-241">SAFE 是最可靠及安全的模式，其包含了根據允許的程式設計模型的相關限制。</span><span class="sxs-lookup"><span data-stu-id="436b3-241">SAFE is the most reliable and secure mode with associated restrictions in terms of the allowed programming model.</span></span> <span data-ttu-id="436b3-242">SAFE 組件有被授與足夠的權限來執行、進行運算，以及存取本機資料庫。</span><span class="sxs-lookup"><span data-stu-id="436b3-242">SAFE assemblies are given enough permission to run, perform computations, and have access to the local database.</span></span> <span data-ttu-id="436b3-243">SAFE 組件需要是可驗證的類型安全，且不允許呼叫 Unmanaged 程式碼。</span><span class="sxs-lookup"><span data-stu-id="436b3-243">SAFE assemblies need to be verifiably type safe and are not allowed to call unmanaged code.</span></span>  
  
 <span data-ttu-id="436b3-244">UNSAFE 適用於高度信任的程式碼，這類程式碼只能由資料庫管理員建立；</span><span class="sxs-lookup"><span data-stu-id="436b3-244">UNSAFE is for highly trusted code that can only be created by database administrators.</span></span> <span data-ttu-id="436b3-245">此信任的程式碼沒有程式碼存取安全性的限制，且可以呼叫 Unmanaged 程式碼 (機器碼)。</span><span class="sxs-lookup"><span data-stu-id="436b3-245">This trusted code has no code access security restrictions, and it can call unmanaged (native) code.</span></span>  
  
 <span data-ttu-id="436b3-246">EXTERNAL_ACCESS 提供了中級安全性選項，可讓程式碼存取在資料庫外部的資源，但是仍然保有 SAFE 的可靠性保證。</span><span class="sxs-lookup"><span data-stu-id="436b3-246">EXTERNAL_ACCESS provides an intermediate security option, allowing code to access resources external to the database but still having the reliability guarantees of SAFE.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="436b3-247">使用主機層級的 CAS 原則層來設定主機原則，以根據 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 目錄中所儲存的權限集合來授與三個權限集合當中的一個。</span><span class="sxs-lookup"><span data-stu-id="436b3-247">uses the host-level CAS policy layer to set up a host policy that grants one of the three sets of permissions based on the permission set stored in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] catalogs.</span></span> <span data-ttu-id="436b3-248">在資料庫內執行的 Managed 程式碼一定會取得這些程式碼存取權限集合當中的一個。</span><span class="sxs-lookup"><span data-stu-id="436b3-248">Managed code running inside the database always gets one of these code access permission sets.</span></span>  
  
### <a name="programming-model-restrictions"></a><span data-ttu-id="436b3-249">程式設計模型限制</span><span class="sxs-lookup"><span data-stu-id="436b3-249">Programming Model Restrictions</span></span>  
 <span data-ttu-id="436b3-250">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中 Managed 程式碼的程式設計模型包含撰寫函數、程序和類型，而這些項目通常不需要使用跨多個引動過程之間所保有的狀態或是共用跨多個使用者工作階段的狀態。</span><span class="sxs-lookup"><span data-stu-id="436b3-250">The programming model for managed code in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] involves writing functions, procedures, and types which typically do not require the use of state held across multiple invocations or the sharing of state across multiple user sessions.</span></span> <span data-ttu-id="436b3-251">再者，如之前所述，共用狀態的存在可能會造成嚴重的例外狀況，而這些例外狀況會影響應用程式的延展性和可靠性。</span><span class="sxs-lookup"><span data-stu-id="436b3-251">Further, as described earlier, the presence of shared state can cause critical exceptions that impact the scalability and the reliability of the application.</span></span>  
  
 <span data-ttu-id="436b3-252">基於這些考量，我們不鼓勵使用 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中所使用之類別的靜態變數和靜態資料成員。</span><span class="sxs-lookup"><span data-stu-id="436b3-252">Given these considerations, we discourage the use of static variables and static data members of classes used in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="436b3-253">對於 SAFE 和 EXTERNAL_ACCESS 組件而言，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 會在 CREATE ASSEMBLY 時檢查組件的中繼資料；如果發現有使用靜態資料成員和變數，則會讓這類組件的建立作業失敗。</span><span class="sxs-lookup"><span data-stu-id="436b3-253">For SAFE and EXTERNAL_ACCESS assemblies, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] examines the metadata of the assembly at CREATE ASSEMBLY time and fails the creation of such assemblies if it finds the use of static data members and variables.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="436b3-254">也不允許呼叫利用 `SharedState`、`Synchronization` 和 `ExternalProcessMgmt` 主機保護屬性加註的 .NET Framework API。</span><span class="sxs-lookup"><span data-stu-id="436b3-254">also disallows calls to .NET Framework APIs that are annotated with the `SharedState`, `Synchronization` and `ExternalProcessMgmt` host protection attributes.</span></span> <span data-ttu-id="436b3-255">這會讓 SAFE 和 EXTERNAL_ACCESS 組件無法呼叫可啟用共用狀態、執行同步處理，以及影響 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 處理序完整性的任何 API。</span><span class="sxs-lookup"><span data-stu-id="436b3-255">This prevents SAFE and EXTERNAL_ACCESS assemblies from calling any APIs that enable sharing state, performing synchronization, and affecting the integrity of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] process.</span></span> <span data-ttu-id="436b3-256">如需詳細資訊，請參閱[CLR 整合程式設計模型限制](database-objects/clr-integration-programming-model-restrictions.md)。</span><span class="sxs-lookup"><span data-stu-id="436b3-256">For more information, see [CLR Integration Programming Model Restrictions](database-objects/clr-integration-programming-model-restrictions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="436b3-257">另請參閱</span><span class="sxs-lookup"><span data-stu-id="436b3-257">See Also</span></span>  
 <span data-ttu-id="436b3-258">[CLR 整合安全性](security/clr-integration-security.md) </span><span class="sxs-lookup"><span data-stu-id="436b3-258">[CLR Integration Security](security/clr-integration-security.md) </span></span>  
 [<span data-ttu-id="436b3-259">CLR 整合的效能</span><span class="sxs-lookup"><span data-stu-id="436b3-259">Performance of CLR Integration</span></span>](clr-integration-architecture-performance.md)  
  
  
