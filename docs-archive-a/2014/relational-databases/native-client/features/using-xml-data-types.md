---
title: 使用 XML 資料類型 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- IRowsetChange interface
- IRowsetUpdate interface
- data access [SQL Server Native Client], xml data type
- SQL Server Native Client OLE DB schema rowsets
- PROVIDER_TYPES rowset
- IColumnsInfo interface
- IRowsetFind interface
- IColumnsRowset interface
- PROCEDURE_PARAMETERS rowset
- SQLNCLI, XML
- xml data type [SQL Server], SQL Server Native Client
- SQL Server Native Client, XML
- IRowset interface
- ISequentialStream interface
- ISSCommandWithParameters interface
- SS_XMLSCHEMA rowset
- SQL Server Native Client OLE DB interfaces
- XML [SQL Server], SQL Server Native Client
- COLUMNS rowset
ms.assetid: a7af5b72-c5c2-418d-a636-ae4ac6270ee5
author: rothja
ms.author: jroth
ms.openlocfilehash: 3d0dcc8cf7259a24e53281724d8440c6ff2209f1
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87598322"
---
# <a name="using-xml-data-types"></a><span data-ttu-id="68a27-102">使用 XML 資料類型</span><span class="sxs-lookup"><span data-stu-id="68a27-102">Using XML Data Types</span></span>
  [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] <span data-ttu-id="68a27-103">推出的 **xml** 資料類型可讓您將 XML 文件和片段儲存在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 資料庫中。</span><span class="sxs-lookup"><span data-stu-id="68a27-103">introduced an **xml** data type that enables you to store XML documents and fragments in a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] database.</span></span> <span data-ttu-id="68a27-104">**xml** 資料類型是 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中的內建資料類型，而且在某些狀況下類似於其他內建類型，例如 **int** 和 **varchar**。</span><span class="sxs-lookup"><span data-stu-id="68a27-104">The **xml** data type is a built-in data type in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], and is in some ways similar to other built-in types, such as **int** and **varchar**.</span></span> <span data-ttu-id="68a27-105">如果是其他內建類型，當您建立資料表作為變數類型、參數類型、函式傳回型別，或是在 CAST 和 CONVERT 函式中時，可以使用 **xml** 資料類型作為資料行類型。</span><span class="sxs-lookup"><span data-stu-id="68a27-105">As with other built-in types, you can use the **xml** data type as a column type when creating a table; as a variable type, a parameter type, or a function-return type; or in CAST and CONVERT functions.</span></span>  
  
## <a name="programming-considerations"></a><span data-ttu-id="68a27-106">程式設計考量</span><span class="sxs-lookup"><span data-stu-id="68a27-106">Programming Considerations</span></span>  
 <span data-ttu-id="68a27-107">XML 可以是自我描述的，因為它可以選擇性地包含指定文件編碼的 XML 標頭，例如：</span><span class="sxs-lookup"><span data-stu-id="68a27-107">XML can be self-describing in that it can optionally include an XML header that specifies the encoding of the document, for example:</span></span>  
  
 `<?xml version="1.0" encoding="windows-1252"?><doc/>`  
  
 <span data-ttu-id="68a27-108">XML 標準描述 XML 處理器如何透過檢查文件的前幾個位元組來偵測用於文件的編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-108">The XML standard describes how an XML processor can detect the encoding used for a document by examining the first few bytes of the document.</span></span> <span data-ttu-id="68a27-109">應用程式所指定的編碼有時候會與文件所指定的編碼產生衝突。</span><span class="sxs-lookup"><span data-stu-id="68a27-109">There are opportunities for the encoding specified by the application to conflict with the encoding specified by the document.</span></span> <span data-ttu-id="68a27-110">對於當做繫結參數傳遞的文件，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 會將 XML 視為二進位資料，因此不需要進行轉換，而且 XML 剖析器可以毫無問題地使用在文件中指定的編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-110">For documents passed as bound parameters, XML is treated as binary data by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], so no conversions are made and the XML parser can use the encoding specified within the document without problems.</span></span> <span data-ttu-id="68a27-111">不過，對於繫結為 WSTR 的 XML 資料，則應用程式必須確認文件的編碼為 Unicode。</span><span class="sxs-lookup"><span data-stu-id="68a27-111">However, for XML data that is bound as WSTR, then the application must ensure that the document is encoded as Unicode.</span></span> <span data-ttu-id="68a27-112">這可能需要將文件載入到 DOM、將編碼變更為 Unicode，然後將文件序列化。</span><span class="sxs-lookup"><span data-stu-id="68a27-112">This may entail loading the document into a DOM, changing the encoding to Unicode and serializing the document.</span></span> <span data-ttu-id="68a27-113">如果尚未完成，可能會發生資料轉換，這會導致 XML 無效或損毀。</span><span class="sxs-lookup"><span data-stu-id="68a27-113">If this is not done, data conversions may occur, resulting in invalid or corrupt XML.</span></span>  
  
 <span data-ttu-id="68a27-114">以常值指定 XML 時，也有可能發生衝突。</span><span class="sxs-lookup"><span data-stu-id="68a27-114">There is also potential for conflict when XML is specified in literals.</span></span> <span data-ttu-id="68a27-115">例如，下列內容無效：</span><span class="sxs-lookup"><span data-stu-id="68a27-115">For example the following are invalid:</span></span>  
  
 `INSERT INTO xmltable(xmlcol) VALUES('<?xml version="1.0" encoding="UTF-16"?><doc/>')`  
  
 `INSERT INTO xmltable(xmlcol) VALUES(N'<?xml version="1.0" encoding="UTF-8"?><doc/>')`  
  
## <a name="sql-server-native-client-ole-db-provider"></a><span data-ttu-id="68a27-116">SQL Server Native Client OLE DB 提供者</span><span class="sxs-lookup"><span data-stu-id="68a27-116">SQL Server Native Client OLE DB Provider</span></span>  
 <span data-ttu-id="68a27-117">DBTYPE_XML 是在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者中，專用於 XML 的新資料類型。</span><span class="sxs-lookup"><span data-stu-id="68a27-117">DBTYPE_XML is a new data type specific to XML in the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider.</span></span> <span data-ttu-id="68a27-118">此外，XML 資料可以透過 DBTYPE_BYTES、DBTYPE_WSTR、DBTYPE_BSTR、DBTYPE_XML、DBTYPE_STR、DBTYPE_VARIANT 和 DBTYPE_IUNKNOWN 的現有 OLE DB 類型進行存取。</span><span class="sxs-lookup"><span data-stu-id="68a27-118">In addition, XML data can be accessed through the existing OLE DB types of DBTYPE_BYTES, DBTYPE_WSTR, DBTYPE_BSTR, DBTYPE_XML, DBTYPE_STR, DBTYPE_VARIANT, and DBTYPE_IUNKNOWN.</span></span> <span data-ttu-id="68a27-119">儲存在 XML 類型資料行中的資料可以使用下列格式，從 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者資料列集的資料行中擷取：</span><span class="sxs-lookup"><span data-stu-id="68a27-119">Data stored in columns of type XML can be retrieved from a column in a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider rowset in the following formats:</span></span>  
  
-   <span data-ttu-id="68a27-120">文字字串</span><span class="sxs-lookup"><span data-stu-id="68a27-120">A text string</span></span>  
  
-   <span data-ttu-id="68a27-121">**ISequentialStream**</span><span class="sxs-lookup"><span data-stu-id="68a27-121">An **ISequentialStream**</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="68a27-122">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native Client OLE DB 提供者不包含 SAX 讀取器，但是**ISequentialStream**可以輕鬆地傳遞到 MSXML 中的 sax 和 DOM 物件。</span><span class="sxs-lookup"><span data-stu-id="68a27-122">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider does not include a SAX reader, but the **ISequentialStream** can be easily passed to SAX and DOM objects in MSXML.</span></span>  
  
 <span data-ttu-id="68a27-123">**ISequentialStream**應該用來抓取大型 XML 檔。</span><span class="sxs-lookup"><span data-stu-id="68a27-123">**ISequentialStream** should be use used for retrieval of large XML documents.</span></span> <span data-ttu-id="68a27-124">用於其他大數值類型的相同技術也適用於 XML。</span><span class="sxs-lookup"><span data-stu-id="68a27-124">The same techniques used for other large value types also apply to XML.</span></span> <span data-ttu-id="68a27-125">如需詳細資訊，請參閱[使用大數值類型](using-large-value-types.md)。</span><span class="sxs-lookup"><span data-stu-id="68a27-125">For more information, see [Using Large Value Types](using-large-value-types.md).</span></span>  
  
 <span data-ttu-id="68a27-126">儲存在資料列集之 XML 類型資料行中的資料也可以由應用程式，透過 **IRow::GetColumns**、**IRowChange::SetColumns** 和 **ICommand::Execute** 之類的一般介面擷取、插入或更新。</span><span class="sxs-lookup"><span data-stu-id="68a27-126">Data stored in columns of type XML in a rowset can also be retrieved, inserted, or updated by an application via the usual interfaces such as **IRow::GetColumns**, **IRowChange::SetColumns**, and **ICommand::Execute**.</span></span> <span data-ttu-id="68a27-127">與抓取案例類似，應用程式可以將文字字串或**ISequentialStream**傳遞給 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB 提供者。</span><span class="sxs-lookup"><span data-stu-id="68a27-127">Similarly to the retrieval case, an application program can pass either a text string or an **ISequentialStream** to the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="68a27-128">若要透過 **ISequentialStream** 介面傳送字串格式的 XML 資料，您必須指定 DBTYPE_IUNKNOWN 來取得 **ISequentialStream**，並在繫結中，將其 *pObject* 引數設定為 Null。</span><span class="sxs-lookup"><span data-stu-id="68a27-128">To send XML data in string format through the **ISequentialStream** interface, you must obtain **ISequentialStream** by specifying DBTYPE_IUNKNOWN and set its *pObject* argument to null in the binding.</span></span>  
  
 <span data-ttu-id="68a27-129">當擷取的 XML 資料因為取用者緩衝區太小而遭到截斷時，可以會將長度傳回為 0xffffffff，這表示長度不明。</span><span class="sxs-lookup"><span data-stu-id="68a27-129">When retrieved XML data is truncated due to the consumer buffer being too small, the length may be returned as 0xffffffff, which means that the length is unknown.</span></span> <span data-ttu-id="68a27-130">這與當做串流至用戶端，而不先傳送實際資料長度資訊之資料類型的實作一致。</span><span class="sxs-lookup"><span data-stu-id="68a27-130">This is consistent with its implementation as a data type that is streamed to the client without sending length information ahead of the actual data.</span></span> <span data-ttu-id="68a27-131">在某些情況下，當提供者已緩衝處理整個值（例如**IRowset：：** 的執行檔和資料轉換的位置）時，可能會傳回實際長度。</span><span class="sxs-lookup"><span data-stu-id="68a27-131">In some cases the actual length may be returned when the provider has buffered the whole value, such as **IRowset::GetData** and where data conversion is performed.</span></span>  
  
 <span data-ttu-id="68a27-132">伺服器會將傳送到 SQL Server 的 XML 資料視為二進位資料。</span><span class="sxs-lookup"><span data-stu-id="68a27-132">XML data sent to SQL Server is treated as binary data by the server.</span></span> <span data-ttu-id="68a27-133">這樣可以防止發生任何轉換，並允許 XML 剖析器自動偵測 XML 編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-133">This prevents any conversions occurring and allows the XML parser to auto-detect the XML encoding.</span></span> <span data-ttu-id="68a27-134">這樣可以接受各種 XML 文件 (例如，以 UTF-8 編碼的文件) 做為 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 的輸入。</span><span class="sxs-lookup"><span data-stu-id="68a27-134">This allows a wider range of XML documents (for example those encoded in UTF-8) to be accepted as input to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="68a27-135">如果輸入 XML 繫結為 DBTYPE_WSTR，應用程式必須確定它已經使用 Unicode 編碼，才能避免因為不需要的資料轉換造成損毀的可能性。</span><span class="sxs-lookup"><span data-stu-id="68a27-135">If input XML is bound as DBTYPE_WSTR, the application must ensure it is already Unicode encoded to avoid any possibility of corruption by unwanted data conversions.</span></span>  
  
### <a name="data-bindings-and-coercions"></a><span data-ttu-id="68a27-136">資料繫結和強制型轉</span><span class="sxs-lookup"><span data-stu-id="68a27-136">Data Bindings and Coercions</span></span>  
 <span data-ttu-id="68a27-137">下表描述搭配 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] **xml** 資料類型使用列出的資料類型時，所發生的繫結和強制型轉。</span><span class="sxs-lookup"><span data-stu-id="68a27-137">The following table describes the binding and coercion that occurs when using the listed data types with the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] **xml** data type.</span></span>  
  
|<span data-ttu-id="68a27-138">資料類型</span><span class="sxs-lookup"><span data-stu-id="68a27-138">Data type</span></span>|<span data-ttu-id="68a27-139">到伺服器</span><span class="sxs-lookup"><span data-stu-id="68a27-139">To Server</span></span><br /><br /> <span data-ttu-id="68a27-140">**XML**</span><span class="sxs-lookup"><span data-stu-id="68a27-140">**XML**</span></span>|<span data-ttu-id="68a27-141">到伺服器</span><span class="sxs-lookup"><span data-stu-id="68a27-141">To Server</span></span><br /><br /> <span data-ttu-id="68a27-142">**非 XML**</span><span class="sxs-lookup"><span data-stu-id="68a27-142">**Non-XML**</span></span>|<span data-ttu-id="68a27-143">從伺服器</span><span class="sxs-lookup"><span data-stu-id="68a27-143">From Server</span></span><br /><br /> <span data-ttu-id="68a27-144">**XML**</span><span class="sxs-lookup"><span data-stu-id="68a27-144">**XML**</span></span>|<span data-ttu-id="68a27-145">從伺服器</span><span class="sxs-lookup"><span data-stu-id="68a27-145">From Server</span></span><br /><br /> <span data-ttu-id="68a27-146">**非 XML**</span><span class="sxs-lookup"><span data-stu-id="68a27-146">**Non-XML**</span></span>|  
|---------------|---------------------------|--------------------------------|-----------------------------|----------------------------------|  
|<span data-ttu-id="68a27-147">DBTYPE_XML</span><span class="sxs-lookup"><span data-stu-id="68a27-147">DBTYPE_XML</span></span>|<span data-ttu-id="68a27-148">通過<sup>6,7</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-148">Pass through<sup>6,7</sup></span></span>|<span data-ttu-id="68a27-149">錯誤<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-149">Error<sup>1</sup></span></span>|<span data-ttu-id="68a27-150">沒有問題<sup>11, 6</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-150">OK<sup>11, 6</sup></span></span>|<span data-ttu-id="68a27-151">錯誤<sup>8</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-151">Error<sup>8</sup></span></span>|  
|<span data-ttu-id="68a27-152">DBTYPE_BYTES</span><span class="sxs-lookup"><span data-stu-id="68a27-152">DBTYPE_BYTES</span></span>|<span data-ttu-id="68a27-153">通過<sup>6,7</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-153">Pass through<sup>6,7</sup></span></span>|<span data-ttu-id="68a27-154">N/A<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-154">N/A<sup>2</sup></span></span>|<span data-ttu-id="68a27-155">沒有問題 <sup>11, 6</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-155">OK <sup>11, 6</sup></span></span>|<span data-ttu-id="68a27-156">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-156">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="68a27-157">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-157">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-158">通過<sup>6,10</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-158">Pass through<sup>6,10</sup></span></span>|<span data-ttu-id="68a27-159">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-159">N/A <sup>2</sup></span></span>|<span data-ttu-id="68a27-160">沒有問題<sup>4, 6, 12</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-160">OK<sup>4, 6, 12</sup></span></span>|<span data-ttu-id="68a27-161">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-161">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="68a27-162">DBTYPE_BSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-162">DBTYPE_BSTR</span></span>|<span data-ttu-id="68a27-163">通過<sup>6,10</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-163">Pass through<sup>6,10</sup></span></span>|<span data-ttu-id="68a27-164">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-164">N/A <sup>2</sup></span></span>|<span data-ttu-id="68a27-165">沒有問題 <sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-165">OK <sup>3</sup></span></span>|<span data-ttu-id="68a27-166">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-166">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="68a27-167">DBTYPE_STR</span><span class="sxs-lookup"><span data-stu-id="68a27-167">DBTYPE_STR</span></span>|<span data-ttu-id="68a27-168">沒有問題<sup>6, 9, 10</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-168">OK<sup>6, 9, 10</sup></span></span>|<span data-ttu-id="68a27-169">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-169">N/A <sup>2</sup></span></span>|<span data-ttu-id="68a27-170">沒有問題<sup>5, 6, 12</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-170">OK<sup>5, 6, 12</sup></span></span>|<span data-ttu-id="68a27-171">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-171">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="68a27-172">DBTYPE_IUNKNOWN</span><span class="sxs-lookup"><span data-stu-id="68a27-172">DBTYPE_IUNKNOWN</span></span>|<span data-ttu-id="68a27-173">透過 **ISequentialStream** 的位元組資料流<sup>7</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-173">Byte stream via **ISequentialStream**<sup>7</sup></span></span>|<span data-ttu-id="68a27-174">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-174">N/A <sup>2</sup></span></span>|<span data-ttu-id="68a27-175">透過 **ISequentialStream** 的位元組資料流<sup>11</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-175">Byte stream via **ISequentialStream**<sup>11</sup></span></span>|<span data-ttu-id="68a27-176">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-176">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="68a27-177">DBTYPE_VARIANT (VT_UI1 &#124; VT_ARRAY)</span><span class="sxs-lookup"><span data-stu-id="68a27-177">DBTYPE_VARIANT (VT_UI1 &#124; VT_ARRAY)</span></span>|<span data-ttu-id="68a27-178">通過<sup>6,7</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-178">Pass through<sup>6,7</sup></span></span>|<span data-ttu-id="68a27-179">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-179">N/A <sup>2</sup></span></span>|<span data-ttu-id="68a27-180">N/A</span><span class="sxs-lookup"><span data-stu-id="68a27-180">N/A</span></span>|<span data-ttu-id="68a27-181">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-181">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="68a27-182">DBTYPE_VARIANT (VT_BSTR)</span><span class="sxs-lookup"><span data-stu-id="68a27-182">DBTYPE_VARIANT (VT_BSTR)</span></span>|<span data-ttu-id="68a27-183">通過<sup>6,10</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-183">Pass through<sup>6,10</sup></span></span>|<span data-ttu-id="68a27-184">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-184">N/A <sup>2</sup></span></span>|<span data-ttu-id="68a27-185">沒有問題<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-185">OK<sup>3</sup></span></span>|<span data-ttu-id="68a27-186">N/A <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="68a27-186">N/A <sup>2</sup></span></span>|  
  
 <span data-ttu-id="68a27-187"><sup>1</sup>如果使用**ICommandWithParameters：： SetParameterInfo**指定了 DBTYPE_XML 以外的伺服器類型，且存取子類型為 DBTYPE_XML，則在 (DB_E_ERRORSOCCURRED 執行語句時，會發生錯誤，參數狀態為 DBSTATUS_E_BADACCESSOR) ;否則，資料會傳送至伺服器，但是伺服器會傳回錯誤，指出沒有從 XML 到參數資料類型的隱含轉換。</span><span class="sxs-lookup"><span data-stu-id="68a27-187"><sup>1</sup>If a server type other than DBTYPE_XML is specified with **ICommandWithParameters::SetParameterInfo** and the accessor type is DBTYPE_XML, an error occurs when the statement is executed (DB_E_ERRORSOCCURRED, the parameter status is DBSTATUS_E_BADACCESSOR); otherwise the data is sent to the server, but the server returns an error indicating that there is no implicit conversion from XML to the parameter's data type.</span></span>  
  
 <span data-ttu-id="68a27-188"><sup>2</sup>超出本主題的範圍。</span><span class="sxs-lookup"><span data-stu-id="68a27-188"><sup>2</sup>Beyond the scope of this topic.</span></span>  
  
 <span data-ttu-id="68a27-189"><sup>3</sup>格式為 UTF-16，無位元組順序標示 (BOM)，無編碼規格，無 Null 結束。</span><span class="sxs-lookup"><span data-stu-id="68a27-189"><sup>3</sup>Format is UTF-16, no bye-order mark (BOM), no encoding specification, no null termination.</span></span>  
  
 <span data-ttu-id="68a27-190"><sup>4</sup>格式為 UTF-16，無 BOM，無編碼規格，Null 結束。</span><span class="sxs-lookup"><span data-stu-id="68a27-190"><sup>4</sup>Format is UTF-16, no BOM, no encoding specification, null termination.</span></span>  
  
 <span data-ttu-id="68a27-191"><sup>5</sup>格式為以用戶端字碼頁搭配 Null 結束字元編碼的多位元組字元。</span><span class="sxs-lookup"><span data-stu-id="68a27-191"><sup>5</sup>Format is multibyte characters encoded in client code page with null terminator.</span></span> <span data-ttu-id="68a27-192">從伺服器提供的 Unicode 進行轉換可能會造成資料損毀，因此，強烈建議您不要使用此繫結。</span><span class="sxs-lookup"><span data-stu-id="68a27-192">Conversion from server supplied Unicode may cause data corruption, so this binding is strongly discouraged.</span></span>  
  
 <span data-ttu-id="68a27-193"><sup>6</sup>可能會使用 BY_REF。</span><span class="sxs-lookup"><span data-stu-id="68a27-193"><sup>6</sup>BY_REF may be used.</span></span>  
  
 <span data-ttu-id="68a27-194"><sup>7</sup>UTF-16 資料必須以 BOM 開頭。</span><span class="sxs-lookup"><span data-stu-id="68a27-194"><sup>7</sup>UTF-16 data must start with a BOM.</span></span> <span data-ttu-id="68a27-195">如果不是，伺服器可能無法正確辨識編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-195">If it does not, the encoding may not be correctly recognized by the server.</span></span>  
  
 <span data-ttu-id="68a27-196"><sup>8</sup>建立存取子時，或提取時，可能會進行驗證。</span><span class="sxs-lookup"><span data-stu-id="68a27-196"><sup>8</sup>Validation can happen at create accessor time, or at fetch time.</span></span> <span data-ttu-id="68a27-197">錯誤為 DB_E_ERRORSOCCURRED，繫結狀態設定為 DBBINDSTATUS_UNSUPPORTEDCONVERSION。</span><span class="sxs-lookup"><span data-stu-id="68a27-197">The error is DB_E_ERRORSOCCURRED, binding status set to DBBINDSTATUS_UNSUPPORTEDCONVERSION.</span></span>  
  
 <span data-ttu-id="68a27-198"><sup>9</sup>資料會先使用用戶端字碼頁轉換為 Unicode，然後再傳送到伺服器。</span><span class="sxs-lookup"><span data-stu-id="68a27-198"><sup>9</sup>Data is converted to Unicode using the client codepage before being sent to the server.</span></span> <span data-ttu-id="68a27-199">如果文件編碼與用戶端字碼頁不符，這可能會導致資料損毀，因此，強烈建議您不要使用此繫結。</span><span class="sxs-lookup"><span data-stu-id="68a27-199">If the document encoding does not match the client codepage, this can result in data corruption, so this binding is strongly discouraged.</span></span>  
  
 <span data-ttu-id="68a27-200"><sup>10</sup>BOM 一律會新增到傳送至伺服器的資料中。</span><span class="sxs-lookup"><span data-stu-id="68a27-200"><sup>10</sup>A BOM is always added to data sent to the server.</span></span> <span data-ttu-id="68a27-201">如果資料已經以 BOM 開頭，這會在緩衝區的開頭產生兩個 BOM。</span><span class="sxs-lookup"><span data-stu-id="68a27-201">If the data already started with a BOM, this results in two BOMs at the start of the buffer.</span></span> <span data-ttu-id="68a27-202">伺服器會使用第一個 BOM 將編碼識別為 UTF-16，然後再捨棄它。</span><span class="sxs-lookup"><span data-stu-id="68a27-202">The server uses the first BOM to recognize the encoding as UTF-16 and then discards it.</span></span> <span data-ttu-id="68a27-203">第二個 BOM 會解譯為零寬度的不分行空格字元。</span><span class="sxs-lookup"><span data-stu-id="68a27-203">The second BOM is interpreted as a zero-width nonbreaking space character.</span></span>  
  
 <span data-ttu-id="68a27-204"><sup>11</sup>格式為 UTF-16，無編碼規格，BOM 會加入到接收自伺服器的資料中。</span><span class="sxs-lookup"><span data-stu-id="68a27-204"><sup>11</sup>Format is UTF-16, no encoding specification, a BOM is added to data received from the server.</span></span> <span data-ttu-id="68a27-205">如果伺服器傳回空字串，仍然會將 BOM 傳回到應用程式。</span><span class="sxs-lookup"><span data-stu-id="68a27-205">If an empty string is returned by the server, a BOM is still returned to the application.</span></span> <span data-ttu-id="68a27-206">如果緩衝區長度為奇數位元組，則會正確地截斷資料。</span><span class="sxs-lookup"><span data-stu-id="68a27-206">If the buffer length is an odd number of bytes, the data is truncated correctly.</span></span> <span data-ttu-id="68a27-207">如果在區塊中傳回整個值，可以串連這些區塊以重新組成正確的值。</span><span class="sxs-lookup"><span data-stu-id="68a27-207">If the whole value is returned in chunks, they can be concatenated to reconstitute the correct value.</span></span>  
  
 <span data-ttu-id="68a27-208"><sup>12</sup>如果緩衝區長度小於兩個字元（也就是沒有足夠的空間來進行 null 終止），則會報告溢位錯誤。</span><span class="sxs-lookup"><span data-stu-id="68a27-208"><sup>12</sup>If the buffer length is less than two characters--that is, not enough space for null termination--an overflow error is reported.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="68a27-209">NULL XML 值不會傳回任何資料。</span><span class="sxs-lookup"><span data-stu-id="68a27-209">No data is returned for NULL XML values.</span></span>  
  
 <span data-ttu-id="68a27-210">XML 標準需要以 UTF-16 編碼的 XML 來開始位元組順序標示 (BOM)，UTF-16 字元程式碼 0xFEFF。</span><span class="sxs-lookup"><span data-stu-id="68a27-210">The XML standard requires UTF-16 encoded XML to start with a byte-order mark (BOM), UTF-16 character code 0xFEFF.</span></span> <span data-ttu-id="68a27-211">使用 WSTR 和 BSTR 系結時， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client 不需要或新增 BOM，因為系結會隱含編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-211">When working with WSTR and BSTR bindings, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client does not require or add a BOM as the encoding is implied by the binding.</span></span> <span data-ttu-id="68a27-212">使用 BYTES、XML 或 IUNKNOWN 繫結時，其用意在於提供處理其他 XML 處理器和儲存系統的單純性。</span><span class="sxs-lookup"><span data-stu-id="68a27-212">When working with BYTES, XML, or IUNKNOWN bindings, the intent is to provide simplicity in dealing with other XML processors and storage systems.</span></span> <span data-ttu-id="68a27-213">在此情況下，BOM 應該以 UTF-16 編碼的 XML 呈現，而且應用程式不需要在意實際編碼，因為多數 XML 處理器 (包括 SQL Server) 都會檢查值的前幾個位元組來推算編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-213">In this case a BOM should be present with UTF-16 encoded XML, and the application need not be concerned with the actual encoding, since the majority of XML processors (including SQL Server) deduces the encoding by inspecting the first few bytes of the value.</span></span> <span data-ttu-id="68a27-214">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]使用位元組、XML 或 IUNKNOWN 系結從 Native Client 接收的 XML 資料一律會以具有 BOM 的 utf-16 編碼，而且不會有內嵌的編碼宣告。</span><span class="sxs-lookup"><span data-stu-id="68a27-214">XML data received from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client using BYTES, XML, or IUNKNOWN bindings is always encoded in UTF-16 with a BOM and without an embedded encoding declaration.</span></span>  
  
 <span data-ttu-id="68a27-215">OLE DB 核心服務 (**IDataConvert**) 提供的資料轉換不適用於 DBTYPE_XML。</span><span class="sxs-lookup"><span data-stu-id="68a27-215">Data conversions supplied by OLE DB core services (**IDataConvert**) are not applicable to DBTYPE_XML.</span></span>  
  
 <span data-ttu-id="68a27-216">當資料傳送到伺服器時，會執行驗證。</span><span class="sxs-lookup"><span data-stu-id="68a27-216">Validation is done when data is sent to the server.</span></span> <span data-ttu-id="68a27-217">用戶端驗證與變碼變更應該由應用程式所處理，而且強烈建議您不要直接處理 XML 資料，但是應該改用 DOM 或 SAX 讀取器來處理該資料。</span><span class="sxs-lookup"><span data-stu-id="68a27-217">Client-side validation and encoding changes should be handled by your application, and it is strongly recommended that you not process the XML data directly, but should instead use a DOM or SAX reader to process it.</span></span>  
  
 <span data-ttu-id="68a27-218">可以繫結 DBTYPE_NULL 和 DBTYPE_EMPTY 用於輸入參數，但是不能用於輸出參數或結果。</span><span class="sxs-lookup"><span data-stu-id="68a27-218">DBTYPE_NULL and DBTYPE_EMPTY can be bound for input parameters but not for output parameters or results.</span></span> <span data-ttu-id="68a27-219">當針對輸入參數來繫結時，狀態必須設定為 DBSTATUS_S_ISNULL 或 DBSTATUS_S_DEFAULT。</span><span class="sxs-lookup"><span data-stu-id="68a27-219">When bound for input parameters the status must be set to DBSTATUS_S_ISNULL or DBSTATUS_S_DEFAULT.</span></span>  
  
 <span data-ttu-id="68a27-220">DBTYPE_XML 可以轉換成 DBTYPE_EMPTY，而 DBTYPE_NULL、DBTYPE_EMPTY 可以轉換成 DBTYPE_XML，但是 DBTYPE_NULL 無法轉換成 DBTYPE_XML。</span><span class="sxs-lookup"><span data-stu-id="68a27-220">DBTYPE_XML can be converted to DBTYPE_EMPTY and DBTYPE_NULL, DBTYPE_EMPTY can be converted to DBTYPE_XML, but DBTYPE_NULL cannot be converted to DBTYPE_XML.</span></span> <span data-ttu-id="68a27-221">這與 DBTYPE_WSTR 一致。</span><span class="sxs-lookup"><span data-stu-id="68a27-221">This is consistent with DBTYPE_WSTR.</span></span>  
  
 <span data-ttu-id="68a27-222">DBTYPE_IUNKNOWN 是支援的繫結 (如上表所示)，但是在 DBTYPE_XML 和 DBTYPE_IUNKNOWN 之間沒有進行任何轉換。</span><span class="sxs-lookup"><span data-stu-id="68a27-222">DBTYPE_IUNKNOWN is a supported binding (as shown in the above table), but there are no conversions between DBTYPE_XML and DBTYPE_IUNKNOWN.</span></span> <span data-ttu-id="68a27-223">DBTYPE_IUNKNOWN 可能無法搭配 DBTYPE_BYREF 使用。</span><span class="sxs-lookup"><span data-stu-id="68a27-223">DBTYPE_IUNKNOWN may not be used with DBTYPE_BYREF.</span></span>  
  
### <a name="ole-db-rowset-additions-and-changes"></a><span data-ttu-id="68a27-224">OLE DB 資料列集的加入和變更</span><span class="sxs-lookup"><span data-stu-id="68a27-224">OLE DB Rowset Additions and Changes</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="68a27-225">Native Client 會將新的值或變更加入到許多核心 OLE DB 架構資料列集。</span><span class="sxs-lookup"><span data-stu-id="68a27-225">Native Client adds new values or changes to many of the core OLE DB schema rowsets.</span></span>  
  
#### <a name="the-columns-and-procedure_parameters-schema-rowsets"></a><span data-ttu-id="68a27-226">COLUMNS 和 PROCEDURE_PARAMETERS 結構描述資料列集</span><span class="sxs-lookup"><span data-stu-id="68a27-226">The COLUMNS and PROCEDURE_PARAMETERS Schema Rowsets</span></span>  
 <span data-ttu-id="68a27-227">COLUMNS 和 PROCEDURE_PARAMETERS 結構描述資料列集的加入項目包含下列資料行。</span><span class="sxs-lookup"><span data-stu-id="68a27-227">Additions to the COLUMNS and PROCEDURE_PARAMETERS schema rowsets include the following columns.</span></span>  
  
|<span data-ttu-id="68a27-228">資料行名稱</span><span class="sxs-lookup"><span data-stu-id="68a27-228">Column name</span></span>|<span data-ttu-id="68a27-229">類型</span><span class="sxs-lookup"><span data-stu-id="68a27-229">Type</span></span>|<span data-ttu-id="68a27-230">描述</span><span class="sxs-lookup"><span data-stu-id="68a27-230">Description</span></span>|  
|-----------------|----------|-----------------|  
|<span data-ttu-id="68a27-231">SS_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-231">SS_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="68a27-232">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-232">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-233">定義 XML 結構描述集合所在目錄的名稱。</span><span class="sxs-lookup"><span data-stu-id="68a27-233">The name of a catalog in which an XML schema collection is defined.</span></span> <span data-ttu-id="68a27-234">對於非 XML 資料行或不具類型的 XML 資料行，此為 NULL。</span><span class="sxs-lookup"><span data-stu-id="68a27-234">NULL for a non-XML column or un-typed XML column.</span></span>|  
|<span data-ttu-id="68a27-235">SS_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="68a27-235">SS_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="68a27-236">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-236">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-237">定義 XML 結構描述集合所在結構描述的名稱。</span><span class="sxs-lookup"><span data-stu-id="68a27-237">The name of a schema in which an XML schema collection is defined.</span></span> <span data-ttu-id="68a27-238">對於非 XML 資料行或不具類型的 XML 資料行，此為 NULL。</span><span class="sxs-lookup"><span data-stu-id="68a27-238">NULL for a non-XML column or un-typed XML column.</span></span>|  
|<span data-ttu-id="68a27-239">SS_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-239">SS_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="68a27-240">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-240">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-241">XML 結構描述集合的名稱。</span><span class="sxs-lookup"><span data-stu-id="68a27-241">The name of XML schema collection.</span></span> <span data-ttu-id="68a27-242">對於非 XML 資料行或不具類型的 XML 資料行，此為 NULL。</span><span class="sxs-lookup"><span data-stu-id="68a27-242">NULL for a non-XML column or un-typed XML column.</span></span>|  
  
#### <a name="the-provider_types-schema-rowset"></a><span data-ttu-id="68a27-243">PROVIDER_TYPES 結構描述資料列集</span><span class="sxs-lookup"><span data-stu-id="68a27-243">The PROVIDER_TYPES Schema Rowset</span></span>  
 <span data-ttu-id="68a27-244">在 PROVIDER_TYPES 結構描述資料列集中，如果是 **xml** 資料類型，COLUMN_SIZE 值為 0，而 DATA_TYPE 為 DBTYPE_XML。</span><span class="sxs-lookup"><span data-stu-id="68a27-244">In the PROVIDER_TYPES schema rowset, the COLUMN_SIZE value is 0 for the **xml** data type, and the DATA_TYPE is DBTYPE_XML.</span></span>  
  
#### <a name="the-ss_xmlschema-schema-rowset"></a><span data-ttu-id="68a27-245">SS_XMLSCHEMA 結構描述資料列集</span><span class="sxs-lookup"><span data-stu-id="68a27-245">The SS_XMLSCHEMA Schema Rowset</span></span>  
 <span data-ttu-id="68a27-246">用戶端推出新的結構描述資料列集 SS_XMLSCHEMA 來擷取 XML 結構描述資訊。</span><span class="sxs-lookup"><span data-stu-id="68a27-246">A new schema rowset SS_XMLSCHEMA is introduced for clients to retrieve XML schema information.</span></span> <span data-ttu-id="68a27-247">SS_XMLSCHEMA 資料列集包含下列資料行。</span><span class="sxs-lookup"><span data-stu-id="68a27-247">The SS_XMLSCHEMA rowset contains the following columns.</span></span>  
  
|<span data-ttu-id="68a27-248">資料行名稱</span><span class="sxs-lookup"><span data-stu-id="68a27-248">Column name</span></span>|<span data-ttu-id="68a27-249">類型</span><span class="sxs-lookup"><span data-stu-id="68a27-249">Type</span></span>|<span data-ttu-id="68a27-250">描述</span><span class="sxs-lookup"><span data-stu-id="68a27-250">Description</span></span>|  
|-----------------|----------|-----------------|  
|<span data-ttu-id="68a27-251">SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-251">SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="68a27-252">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-252">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-253">XML 集合所屬的目錄。</span><span class="sxs-lookup"><span data-stu-id="68a27-253">The catalog an XML collection belongs to.</span></span>|  
|<span data-ttu-id="68a27-254">SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="68a27-254">SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="68a27-255">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-255">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-256">XML 集合所屬的結構描述。</span><span class="sxs-lookup"><span data-stu-id="68a27-256">The schema an XML collection belongs to.</span></span>|  
|<span data-ttu-id="68a27-257">SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-257">SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="68a27-258">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-258">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-259">具類型的 XML 資料行之 XML 結構描述集合的名稱，否則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="68a27-259">The name of an XML schema collection for typed XML columns, NULL otherwise.</span></span>|  
|<span data-ttu-id="68a27-260">TARGETNAMESPACEURI</span><span class="sxs-lookup"><span data-stu-id="68a27-260">TARGETNAMESPACEURI</span></span>|<span data-ttu-id="68a27-261">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-261">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-262">XML 結構描述的目標命名空間。</span><span class="sxs-lookup"><span data-stu-id="68a27-262">The target name space of an XML schema.</span></span>|  
|<span data-ttu-id="68a27-263">SCHEMACONTENT</span><span class="sxs-lookup"><span data-stu-id="68a27-263">SCHEMACONTENT</span></span>|<span data-ttu-id="68a27-264">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-264">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-265">XML 結構描述內容。</span><span class="sxs-lookup"><span data-stu-id="68a27-265">The XML schema content.</span></span>|  
  
 <span data-ttu-id="68a27-266">每個 XML 結構描述都是由目錄名稱、結構描述名稱、結構描述集合名稱，以及目標命名空間統一資源識別碼 (URI) 來限定範圍。</span><span class="sxs-lookup"><span data-stu-id="68a27-266">Each XML schema is scoped by catalog name, schema name, schema collection name, and target name space Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="68a27-267">此外，也會定義名稱為 DBSCHEMA_XML_COLLECTIONS 的新 GUID。</span><span class="sxs-lookup"><span data-stu-id="68a27-267">In addition, a new GUID with the name DBSCHEMA_XML_COLLECTIONS is also defined.</span></span> <span data-ttu-id="68a27-268">限制的數目以及限制的 SS_XMLSCHEMA 結構描述資料列集資料行定義如下。</span><span class="sxs-lookup"><span data-stu-id="68a27-268">The number of restrictions and restricted columns for the SS_XMLSCHEMA schema rowset are defined as follows.</span></span>  
  
|<span data-ttu-id="68a27-269">GUID</span><span class="sxs-lookup"><span data-stu-id="68a27-269">GUID</span></span>|<span data-ttu-id="68a27-270">限制的數目</span><span class="sxs-lookup"><span data-stu-id="68a27-270">Number of restrictions</span></span>|<span data-ttu-id="68a27-271">限制的資料行</span><span class="sxs-lookup"><span data-stu-id="68a27-271">Restricted columns</span></span>|  
|----------|----------------------------|------------------------|  
|<span data-ttu-id="68a27-272">DBSCHEMA_XML_COLLECTIONS</span><span class="sxs-lookup"><span data-stu-id="68a27-272">DBSCHEMA_XML_COLLECTIONS</span></span>|<span data-ttu-id="68a27-273">4</span><span class="sxs-lookup"><span data-stu-id="68a27-273">4</span></span>|<span data-ttu-id="68a27-274">SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-274">SCHEMACOLLECTION_CATALOGNAME</span></span><br /><br /> <span data-ttu-id="68a27-275">SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="68a27-275">SCHEMACOLLECTION_SCHEMANAME</span></span><br /><br /> <span data-ttu-id="68a27-276">SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-276">SCHEMACOLLECTIONNAME</span></span><br /><br /> <span data-ttu-id="68a27-277">TARGETNAMESPACEURI</span><span class="sxs-lookup"><span data-stu-id="68a27-277">TARGETNAMESPACEURI</span></span>|  
  
### <a name="ole-db-property-set-additions-and-changes"></a><span data-ttu-id="68a27-278">OLE DB 屬性集的加入和變更</span><span class="sxs-lookup"><span data-stu-id="68a27-278">OLE DB Property Set Additions and Changes</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="68a27-279">Native Client 會將新的值或變更加入到許多核心 OLE DB 的屬性集。</span><span class="sxs-lookup"><span data-stu-id="68a27-279">Native Client adds new values or changes to many of the core OLE DB property sets.</span></span>  
  
#### <a name="the-dbpropset_sqlserverparameter-property-set"></a><span data-ttu-id="68a27-280">DBPROPSET_SQLSERVERPARAMETER 屬性集</span><span class="sxs-lookup"><span data-stu-id="68a27-280">The DBPROPSET_SQLSERVERPARAMETER Property Set</span></span>  
 <span data-ttu-id="68a27-281">為了透過 OLE DB 支援**xml**資料類型， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client 會執行新的 DBPROPSET_SQLSERVERPARAMETER 屬性集，其中包含下列值。</span><span class="sxs-lookup"><span data-stu-id="68a27-281">In order to support the **xml** data type through OLE DB, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client implements the new DBPROPSET_SQLSERVERPARAMETER property set, which contains the following values.</span></span>  
  
|<span data-ttu-id="68a27-282">名稱</span><span class="sxs-lookup"><span data-stu-id="68a27-282">Name</span></span>|<span data-ttu-id="68a27-283">類型</span><span class="sxs-lookup"><span data-stu-id="68a27-283">Type</span></span>|<span data-ttu-id="68a27-284">描述</span><span class="sxs-lookup"><span data-stu-id="68a27-284">Description</span></span>|  
|----------|----------|-----------------|  
|<span data-ttu-id="68a27-285">SSPROP_PARAM_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-285">SSPROP_PARAM_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="68a27-286">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-286">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-287">定義 XML 結構描述集合所在目錄 (資料庫) 的名稱。</span><span class="sxs-lookup"><span data-stu-id="68a27-287">The name of a catalog (database) in which an XML schema collection is defined.</span></span> <span data-ttu-id="68a27-288">SQL 三部分名稱識別碼的一部分。</span><span class="sxs-lookup"><span data-stu-id="68a27-288">A part of the SQL three-part name identifier.</span></span>|  
|<span data-ttu-id="68a27-289">SSPROP_PARAM_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="68a27-289">SSPROP_PARAM_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="68a27-290">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-290">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-291">結構描述集合內，XML 結構描述的名稱。</span><span class="sxs-lookup"><span data-stu-id="68a27-291">The name of an XML schema within the schema collection.</span></span> <span data-ttu-id="68a27-292">SQL 三部分名稱識別碼的一部分。</span><span class="sxs-lookup"><span data-stu-id="68a27-292">A part of the SQL three -part name identifier.</span></span>|  
|<span data-ttu-id="68a27-293">SSPROP_PARAM_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-293">SSPROP_PARAM_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="68a27-294">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-294">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-295">在 SQL 三部分名稱識別碼的目錄 A 部分中，XML 結構描述集合的名稱。</span><span class="sxs-lookup"><span data-stu-id="68a27-295">The name of the XML schema collection within the catalog A part of the SQL three -part name identifier.</span></span>|  
  
#### <a name="the-dbpropset_sqlservercolumn-property-set"></a><span data-ttu-id="68a27-296">DBPROPSET_SQLSERVERCOLUMN 屬性集</span><span class="sxs-lookup"><span data-stu-id="68a27-296">The DBPROPSET_SQLSERVERCOLUMN Property Set</span></span>  
 <span data-ttu-id="68a27-297">為了支援**ITableDefinition**介面中的資料表建立， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client 會將三個新的資料行加入 DBPROPSET_SQLSERVERCOLUMN 屬性集。</span><span class="sxs-lookup"><span data-stu-id="68a27-297">To support the creation of tables in the **ITableDefinition** interface, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client adds three new columns to the DBPROPSET_SQLSERVERCOLUMN property set.</span></span>  
  
|<span data-ttu-id="68a27-298">名稱</span><span class="sxs-lookup"><span data-stu-id="68a27-298">Name</span></span>|<span data-ttu-id="68a27-299">類型</span><span class="sxs-lookup"><span data-stu-id="68a27-299">Type</span></span>|<span data-ttu-id="68a27-300">描述</span><span class="sxs-lookup"><span data-stu-id="68a27-300">Description</span></span>|  
|----------|----------|-----------------|  
|<span data-ttu-id="68a27-301">SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-301">SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="68a27-302">VT_BSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-302">VT_BSTR</span></span>|<span data-ttu-id="68a27-303">如果是具類型的 XML 資料行，這個屬性是指定儲存 XML 結構描述所在之目錄名稱的字串。</span><span class="sxs-lookup"><span data-stu-id="68a27-303">For typed XML columns, this property is a string specifying the name of the catalog where the XML schema is stored.</span></span> <span data-ttu-id="68a27-304">如果是其他資料行類型，這個屬性會傳回空字串。</span><span class="sxs-lookup"><span data-stu-id="68a27-304">For other column types this property returns an empty string.</span></span>|  
|<span data-ttu-id="68a27-305">SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="68a27-305">SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="68a27-306">VT_BSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-306">VT_BSTR</span></span>|<span data-ttu-id="68a27-307">如果是具類型的 XML 資料行，這個屬性是指定定義此資料行之 XML 結構描述名稱的字串。</span><span class="sxs-lookup"><span data-stu-id="68a27-307">For typed XML columns, this property is a string specifying the name of XML schema that defines this column.</span></span>|  
|<span data-ttu-id="68a27-308">SSPROP_COL_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-308">SSPROP_COL_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="68a27-309">VT_BSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-309">VT_BSTR</span></span>|<span data-ttu-id="68a27-310">如果是具類型的 XML 資料行，這個屬性是指定定義值之結構描述 XML 結構描述集合名稱的字串。</span><span class="sxs-lookup"><span data-stu-id="68a27-310">For typed XML columns, this property is a string specifying the name of the schema XML schema collection defining the value.</span></span>|  
  
 <span data-ttu-id="68a27-311">如同 SSPROP_PARAM 值，這些所有屬性都是選擇性的，而且預設為空。</span><span class="sxs-lookup"><span data-stu-id="68a27-311">Like the SSPROP_PARAM values, all of these properties are optional and default to empty.</span></span> <span data-ttu-id="68a27-312">只有在指定 SSPROP_COL_XML_SCHEMACOLLECTIONNAME 時，才可能指定 SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME 和 SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME。</span><span class="sxs-lookup"><span data-stu-id="68a27-312">SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME and SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME may only be specified if SSPROP_COL_XML_SCHEMACOLLECTIONNAME is specified.</span></span> <span data-ttu-id="68a27-313">將 XML 傳遞到伺服器時，如果包含這些值，系統會針對目前的資料庫檢查這些值是否存在 (有效性)，並針對結構描述檢查執行個體資料。</span><span class="sxs-lookup"><span data-stu-id="68a27-313">When passing XML to the server, if these values are included they are checked for existence (validity) against the current database and the instance data is checked against the schema.</span></span> <span data-ttu-id="68a27-314">在所有情況下，這些值必須全部為空或全部填入，才會有效。</span><span class="sxs-lookup"><span data-stu-id="68a27-314">In all cases, to be valid they are either all empty or all filled in.</span></span>  
  
### <a name="ole-db-interface-additions-and-changes"></a><span data-ttu-id="68a27-315">OLE DB 介面的加入和變更</span><span class="sxs-lookup"><span data-stu-id="68a27-315">OLE DB Interface Additions and Changes</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="68a27-316">Native Client 會將新的值或變更加入到許多核心 OLE DB 介面。</span><span class="sxs-lookup"><span data-stu-id="68a27-316">Native Client adds new values or changes to many of the core OLE DB interfaces.</span></span>  
  
#### <a name="the-isscommandwithparameters-interface"></a><span data-ttu-id="68a27-317">ISSCommandWithParameters 介面</span><span class="sxs-lookup"><span data-stu-id="68a27-317">The ISSCommandWithParameters Interface</span></span>  
 <span data-ttu-id="68a27-318">為了透過 OLE DB 支援**xml**資料類型， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client 會執行一些變更，包括新增[ISSCommandWithParameters](../../native-client-ole-db-interfaces/isscommandwithparameters-ole-db.md)介面。</span><span class="sxs-lookup"><span data-stu-id="68a27-318">In order to support the **xml** data type through OLE DB, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client implements a number of changes including the addition of the [ISSCommandWithParameters](../../native-client-ole-db-interfaces/isscommandwithparameters-ole-db.md) interface.</span></span> <span data-ttu-id="68a27-319">這個新的介面繼承自核心的 OLE DB 介面 **ICommandWithParameters**。</span><span class="sxs-lookup"><span data-stu-id="68a27-319">This new interface inherits from the core OLE DB interface **ICommandWithParameters**.</span></span> <span data-ttu-id="68a27-320">除了繼承自**ICommandWithParameters**的三個方法以外，**GetParameterInfo**、 **MapParameterNames**和**SetParameterInfo**;**ISSCommandWithParameters**提供用來處理伺服器特定資料類型的[GetParameterProperties](../../native-client-ole-db-interfaces/isscommandwithparameters-getparameterproperties-ole-db.md)和[SetParameterProperties](../../native-client-ole-db-interfaces/isscommandwithparameters-setparameterproperties-ole-db.md)方法。</span><span class="sxs-lookup"><span data-stu-id="68a27-320">In addition to the three methods inherited from **ICommandWithParameters**; **GetParameterInfo**, **MapParameterNames**, and **SetParameterInfo**; **ISSCommandWithParameters** provides the [GetParameterProperties](../../native-client-ole-db-interfaces/isscommandwithparameters-getparameterproperties-ole-db.md) and [SetParameterProperties](../../native-client-ole-db-interfaces/isscommandwithparameters-setparameterproperties-ole-db.md) methods that are used to handle server specific data types.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="68a27-321">**ISSCommandWithParameters** 介面也會使用新的 SSPARAMPROPS 結構。</span><span class="sxs-lookup"><span data-stu-id="68a27-321">The **ISSCommandWithParameters** interface also makes use of the new SSPARAMPROPS structure.</span></span>  
  
#### <a name="the-icolumnsrowset-interface"></a><span data-ttu-id="68a27-322">IColumnsRowset 介面</span><span class="sxs-lookup"><span data-stu-id="68a27-322">The IColumnsRowset Interface</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="68a27-323">Native Client 會將下列 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 特定的資料行加入至**IColumnRowset：： GetColumnsRowset**方法所傳回的資料列集。</span><span class="sxs-lookup"><span data-stu-id="68a27-323">Native Client adds the following [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]-specific columns to the rowset returned by the **IColumnRowset::GetColumnsRowset** method.</span></span> <span data-ttu-id="68a27-324">這些資料行包含 XML 結構描述集合的三部分名稱。</span><span class="sxs-lookup"><span data-stu-id="68a27-324">These columns contain the three-part name of an XML schema collection.</span></span> <span data-ttu-id="68a27-325">對於非 XML 資料行或不具類型的 XML 資料行，所有三個資料行都會使用 NULL 的預設值。</span><span class="sxs-lookup"><span data-stu-id="68a27-325">For non-XML columns or untyped XML columns, all three columns take the default value of NULL.</span></span>  
  
|<span data-ttu-id="68a27-326">資料行名稱</span><span class="sxs-lookup"><span data-stu-id="68a27-326">Column name</span></span>|<span data-ttu-id="68a27-327">類型</span><span class="sxs-lookup"><span data-stu-id="68a27-327">Type</span></span>|<span data-ttu-id="68a27-328">描述</span><span class="sxs-lookup"><span data-stu-id="68a27-328">Description</span></span>|  
|-----------------|----------|-----------------|  
|<span data-ttu-id="68a27-329">DBCOLUMN_SS_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-329">DBCOLUMN_SS_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="68a27-330">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-330">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-331">XML 結構描述集合所屬的目錄，</span><span class="sxs-lookup"><span data-stu-id="68a27-331">The catalog an XML schema collection belongs to,</span></span><br /><br /> <span data-ttu-id="68a27-332">否則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="68a27-332">NULL otherwise.</span></span>|  
|<span data-ttu-id="68a27-333">DBCOLUMN_SS_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="68a27-333">DBCOLUMN_SS_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="68a27-334">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-334">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-335">XML 結構描述集合所屬的結構描述，</span><span class="sxs-lookup"><span data-stu-id="68a27-335">The schema an XML schema collection belongs to.</span></span> <span data-ttu-id="68a27-336">否則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="68a27-336">NULL otherwise.</span></span>|  
|<span data-ttu-id="68a27-337">DBCOLUMN_SS_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="68a27-337">DBCOLUMN_SS_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="68a27-338">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="68a27-338">DBTYPE_WSTR</span></span>|<span data-ttu-id="68a27-339">具類型的 XML 資料行之 XML 結構描述集合的名稱，否則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="68a27-339">The name of XML schema collection for typed XML column, NULL otherwise.</span></span>|  
  
#### <a name="the-irowset-interface"></a><span data-ttu-id="68a27-340">IRowset 介面</span><span class="sxs-lookup"><span data-stu-id="68a27-340">The IRowset Interface</span></span>  
 <span data-ttu-id="68a27-341">XML 資料行中的 XML 執行個體會透過 **IRowset::GetData** 方法擷取。</span><span class="sxs-lookup"><span data-stu-id="68a27-341">An XML instance in an XML column is retrieved through the **IRowset::GetData** method.</span></span> <span data-ttu-id="68a27-342">根據用戶端所指定的繫結，可以將 XML 執行個體當做 DBTYPE_BSTR、DBTYPE_WSTR、DBTYPE_VARIANT、DBTYPE_XML、DBTYPE_STR、DBTYPE_BYTES 擷取，或透過 DBTYPE_IUNKNOWN，當做介面擷取。</span><span class="sxs-lookup"><span data-stu-id="68a27-342">Depending on the binding specified by the client, an XML instance can be retrieved as DBTYPE_BSTR, DBTYPE_WSTR, DBTYPE_VARIANT, DBTYPE_XML, DBTYPE_STR, DBTYPE_BYTES, or as an interface via DBTYPE_IUNKNOWN.</span></span> <span data-ttu-id="68a27-343">如果取用者指定 DBTYPE_BSTR、DBTYPE_WSTR 或 DBTYPE_VARIANT，提供者會將 XML 執行個體轉換為使用者要求的類型，並將其放入對應繫結中所指定的位置。</span><span class="sxs-lookup"><span data-stu-id="68a27-343">If the consumer specifies DBTYPE_BSTR, DBTYPE_WSTR, or DBTYPE_VARIANT, the provider converts the XML instance to the user requested type and put it into the location specified in the corresponding binding.</span></span>  
  
 <span data-ttu-id="68a27-344">如果取用者指定 DBTYPE_IUNKNOWN，並將 *pObject* 引數設定為 NULL，或將 *pObject* 引數設定為 IID_IsequentialStream，提供者會將 **ISequentialStream** 介面傳回到取用者，讓取用者可以用資料流的形式，將 XML 資料傳出資料行。</span><span class="sxs-lookup"><span data-stu-id="68a27-344">If the consumer specifies DBTYPE_IUNKNOWN and sets the *pObject* argument to NULL, or sets the *pObject* argument to IID_ISequentialStream, the provider returns an **ISequentialStream** interface to the consumer so that the consumer can stream the XML data out of the column.</span></span> <span data-ttu-id="68a27-345">**ISequentialStream** 接著會傳回 XML 資料，作為 Unicode 字元資料流。</span><span class="sxs-lookup"><span data-stu-id="68a27-345">**ISequentialStream** then returns the XML data as a Unicode character stream.</span></span>  
  
 <span data-ttu-id="68a27-346">傳回繫結至 DBTYPE_IUNKNOWN 的 XML 值時，提供者會報告 `sizeof (IUnknown *)` 的大小值。</span><span class="sxs-lookup"><span data-stu-id="68a27-346">When returning an XML value bound to DBTYPE_IUNKNOWN, the provider reports a size value of `sizeof (IUnknown *)`.</span></span> <span data-ttu-id="68a27-347">請注意，這與資料行繫結為 DBTYPE_IUnknown 或 DBTYPE_IDISPATCH 時所採取的方法一致，而且在無法判斷確實的資料行大小時，夠過 DBTYPE_IUNKNOWN/ISequentialStream 所採取的方法一致。</span><span class="sxs-lookup"><span data-stu-id="68a27-347">Note that this is consistent with the approach taken when a column is bound as DBTYPE_IUnknown or DBTYPE_IDISPATCH, and by DBTYPE_IUNKNOWN/ISequentialStream when the exact column size cannot be determined.</span></span>  
  
#### <a name="the-irowsetchange-interface"></a><span data-ttu-id="68a27-348">IRowsetChange 介面</span><span class="sxs-lookup"><span data-stu-id="68a27-348">The IRowsetChange Interface</span></span>  
 <span data-ttu-id="68a27-349">取用者可以在資料行中更新 XML 結構描述的方式有兩種。</span><span class="sxs-lookup"><span data-stu-id="68a27-349">There are two ways a consumer can update an XML instance in a column.</span></span> <span data-ttu-id="68a27-350">第一種方式是透過提供者所建立的儲存物件 **ISequentialStream**。</span><span class="sxs-lookup"><span data-stu-id="68a27-350">The first one is through the storage object **ISequentialStream** created by the provider.</span></span> <span data-ttu-id="68a27-351">取用者可以呼叫 **ISequentialStream::Write** 方法來直接更新提供者所傳回的 XML 執行個體。</span><span class="sxs-lookup"><span data-stu-id="68a27-351">The consumer can call the **ISequentialStream::Write** method to directly update the XML instance returned by the provider.</span></span>  
  
 <span data-ttu-id="68a27-352">第二個方式是透過 **IRowsetChange::SetData** 或 **IRowsetChange::InsertRow** 方法。</span><span class="sxs-lookup"><span data-stu-id="68a27-352">The second approach is through **IRowsetChange::SetData** or **IRowsetChange::InsertRow** methods.</span></span> <span data-ttu-id="68a27-353">利用這個方式，取用者緩衝區中的 XML 執行個體可以在類型 DBTYPE_BSTR、DBTYPE_WSTR、DBTYPE_VARIANT、DBTYPE_XML 或 DBTYPE_IUNKNOWN 的繫結中指定。</span><span class="sxs-lookup"><span data-stu-id="68a27-353">In this approach, an XML instance in the consumer's buffer can be specified in a binding of type DBTYPE_BSTR, DBTYPE_WSTR, DBTYPE_VARIANT, DBTYPE_XML or DBTYPE_IUNKNOWN.</span></span>  
  
 <span data-ttu-id="68a27-354">如果是 DBTYPE_BSTR、DBTYPE_WSTR 或 DBTYPE_VARIANT，提供者會將位於取用者緩衝區中的 XML 執行個體儲存到適當的資料行中。</span><span class="sxs-lookup"><span data-stu-id="68a27-354">In case of DBTYPE_BSTR, DBTYPE_WSTR, or DBTYPE_VARIANT, the provider stores the XML instance residing in the consumer buffer into the proper column.</span></span>  
  
 <span data-ttu-id="68a27-355">在 DBTYPE_IUNKNOWN/ISequentialStream 的案例中，如果取用者沒有指定任何儲存物件，取用者必須事先建立**ISequentialStream**物件、使用物件系結 XML 檔，然後透過**IRowsetChange：： SetData**方法將物件傳遞給提供者。</span><span class="sxs-lookup"><span data-stu-id="68a27-355">In the case of DBTYPE_IUNKNOWN/ISequentialStream, if the consumer does not specify any storage object, the consumer must create an **ISequentialStream** object in advance, bind the XML document with the object, and then pass the object to the provider through the **IRowsetChange::SetData** method.</span></span> <span data-ttu-id="68a27-356">取用者也可以建立儲存物件、將 pObject 引數設定為 IID_IsequentialStream、建立 **ISequentialStream** 物件，然後將 **ISequentialStream** 物件傳遞到 **IRowsetChange::SetData** 方法。</span><span class="sxs-lookup"><span data-stu-id="68a27-356">The consumer can also create a storage object, set the pObject argument to IID_ISequentialStream, create an **ISequentialStream** object and then pass the **ISequentialStream** object to the **IRowsetChange::SetData** method.</span></span> <span data-ttu-id="68a27-357">在兩種情況下，提供者可以透過 **ISequentialStream** 物件擷取 XML 物件，並將其插入到適當的資料行中。</span><span class="sxs-lookup"><span data-stu-id="68a27-357">In both cases, the provider can retrieve the XML object through the **ISequentialStream** object and insert it into a proper column.</span></span>  
  
#### <a name="the-irowsetupdate-interface"></a><span data-ttu-id="68a27-358">IRowsetUpdate 介面</span><span class="sxs-lookup"><span data-stu-id="68a27-358">The IRowsetUpdate Interface</span></span>  
 <span data-ttu-id="68a27-359">**IRowsetUpdate** 介面提供延遲更新的功能。</span><span class="sxs-lookup"><span data-stu-id="68a27-359">**IRowsetUpdate** interface provides functionality for delayed updates.</span></span> <span data-ttu-id="68a27-360">在取用者呼叫**IRowsetUpdate： Update**方法之前，資料列集所提供的資料不會提供給其他交易使用。</span><span class="sxs-lookup"><span data-stu-id="68a27-360">The data made available to the rowsets is not made available to other transactions until the consumer calls the **IRowsetUpdate:Update** method.</span></span>  
  
#### <a name="the-irowsetfind-interface"></a><span data-ttu-id="68a27-361">IRowsetFind 介面</span><span class="sxs-lookup"><span data-stu-id="68a27-361">The IRowsetFind Interface</span></span>  
 <span data-ttu-id="68a27-362">**IRowsetFind::FindNextRow** 方法無法搭配 **xml** 資料類型使用。</span><span class="sxs-lookup"><span data-stu-id="68a27-362">The **IRowsetFind::FindNextRow** method does not work with the **xml** data type.</span></span> <span data-ttu-id="68a27-363">呼叫 **IRowsetFind::FindNextRow** 而且 *hAccessor* 引數指定 DBTYPE_XML 的資料行時，會傳回 DB_E_BADBINDINFO。</span><span class="sxs-lookup"><span data-stu-id="68a27-363">When **IRowsetFind::FindNextRow** is called and the *hAccessor* argument specifies a column of DBTYPE_XML, DB_E_BADBINDINFO is returned.</span></span> <span data-ttu-id="68a27-364">不管要搜尋的是什麼資料行類型，都會發生這個狀況。</span><span class="sxs-lookup"><span data-stu-id="68a27-364">This occurs regardless of the type of column that is being searched.</span></span> <span data-ttu-id="68a27-365">對於其他任何繫結類型，如果要搜尋的資料行屬於 **xml** 資料類型，**FindNextRow** 會失敗並傳回 DB_E_BADCOMPAREOP。</span><span class="sxs-lookup"><span data-stu-id="68a27-365">For any other binding type, the **FindNextRow** fails with DB_E_BADCOMPAREOP if the column to be searched is of the **xml** data type.</span></span>  
  
## <a name="sql-server-native-client-odbc-driver"></a><span data-ttu-id="68a27-366">SQL Server Native Client ODBC 驅動程式</span><span class="sxs-lookup"><span data-stu-id="68a27-366">SQL Server Native Client ODBC Driver</span></span>  
 <span data-ttu-id="68a27-367">在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native CLIENT ODBC 驅動程式中，已對各種函數進行一些變更，以支援**xml**資料類型。</span><span class="sxs-lookup"><span data-stu-id="68a27-367">In the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver, a number of changes have been made to various functions to support the **xml** data type.</span></span>  
  
### <a name="sqlcolattribute"></a><span data-ttu-id="68a27-368">SQLColAttribute</span><span class="sxs-lookup"><span data-stu-id="68a27-368">SQLColAttribute</span></span>  
 <span data-ttu-id="68a27-369">[SQLColAttribute](../../native-client-odbc-api/sqlcolattribute.md)函數有三個新的欄位識別碼，包括 SQL_CA_SS_XML_SCHEMACOLLECTION_CATALOG_NAME、SQL_CA_SS_XML_SCHEMACOLLECTION_SCHEMA_NAME 和 SQL_CA_SS _XML_SCHEMACOLLECTION_NAME。</span><span class="sxs-lookup"><span data-stu-id="68a27-369">The [SQLColAttribute](../../native-client-odbc-api/sqlcolattribute.md) function has three new field identifiers, including SQL_CA_SS_XML_SCHEMACOLLECTION_CATALOG_NAME, SQL_CA_SS_XML_SCHEMACOLLECTION_SCHEMA_NAME, and SQL_CA_SS _XML_SCHEMACOLLECTION_NAME.</span></span>  
  
 <span data-ttu-id="68a27-370">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 驅動程式會針對 SQL_DESC_DISPLAY_SIZE 和 SQL_DESC_LENGTH 資料行報告 SQL_SS_LENGTH_UNLIMITED。</span><span class="sxs-lookup"><span data-stu-id="68a27-370">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED for the SQL_DESC_DISPLAY_SIZE and SQL_DESC_LENGTH columns.</span></span>  
  
### <a name="sqlcolumns"></a><span data-ttu-id="68a27-371">SQLColumns</span><span class="sxs-lookup"><span data-stu-id="68a27-371">SQLColumns</span></span>  
 <span data-ttu-id="68a27-372">[SQLColumns](../../native-client-odbc-api/sqlcolumns.md)函數有三個新的資料行，包括 SS_XML_SCHEMACOLLECTION_CATALOG_NAME、SS_XML_SCHEMACOLLECTION_SCHEMA_NAME 和 SS_XML_SCHEMACOLLECTION_NAME。</span><span class="sxs-lookup"><span data-stu-id="68a27-372">The [SQLColumns](../../native-client-odbc-api/sqlcolumns.md) function has three new columns including SS_XML_SCHEMACOLLECTION_CATALOG_NAME, SS_XML_SCHEMACOLLECTION_SCHEMA_NAME, and SS_XML_SCHEMACOLLECTION_NAME.</span></span> <span data-ttu-id="68a27-373">現有的 TYPE_NAME 資料行用於指示 XML 類型的名稱，而且 XML 類型資料行或參數的 DATA_TYPE 為 SQL_SS_XML。</span><span class="sxs-lookup"><span data-stu-id="68a27-373">The existing TYPE_NAME column is used to indicate the name of the XML type, and the DATA_TYPE for a XML type column or parameter is SQL_SS_XML.</span></span>  
  
 <span data-ttu-id="68a27-374">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 驅動程式會報告 COLUMN_SIZE 和 CHAR_OCTET_LENGTH 值的 SQL_SS_LENGTH_UNLIMITED。</span><span class="sxs-lookup"><span data-stu-id="68a27-374">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED for the COLUMN_SIZE and CHAR_OCTET_LENGTH values.</span></span>  
  
### <a name="sqldescribecol"></a><span data-ttu-id="68a27-375">SQLDescribeCol</span><span class="sxs-lookup"><span data-stu-id="68a27-375">SQLDescribeCol</span></span>  
 <span data-ttu-id="68a27-376">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]當[SQLDescribeCol](../../native-client-odbc-api/sqldescribecol.md)函數中無法判斷資料行大小時，Native Client ODBC 驅動程式會報告 SQL_SS_LENGTH_UNLIMITED。</span><span class="sxs-lookup"><span data-stu-id="68a27-376">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED when the column size cannot be determined in the [SQLDescribeCol](../../native-client-odbc-api/sqldescribecol.md) function.</span></span>  
  
### <a name="sqlgettypeinfo"></a><span data-ttu-id="68a27-377">SQLGetTypeInfo</span><span class="sxs-lookup"><span data-stu-id="68a27-377">SQLGetTypeInfo</span></span>  
 <span data-ttu-id="68a27-378">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 驅動程式會將 SQL_SS_LENGTH_UNLIMITED 報告為[SQLGetTypeInfo](../../native-client-odbc-api/sqlgettypeinfo.md)函數中**xml**資料類型的最大 COLUMN_SIZE。</span><span class="sxs-lookup"><span data-stu-id="68a27-378">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED as the maximum COLUMN_SIZE for the **xml** data type in the [SQLGetTypeInfo](../../native-client-odbc-api/sqlgettypeinfo.md) function.</span></span>  
  
### <a name="sqlprocedurecolumns"></a><span data-ttu-id="68a27-379">SQLProcedureColumns</span><span class="sxs-lookup"><span data-stu-id="68a27-379">SQLProcedureColumns</span></span>  
 <span data-ttu-id="68a27-380">[SQLProcedureColumns](../../native-client-odbc-api/sqlprocedurecolumns.md)函數具有與**SQLColumns**函數相同的資料行新增專案。</span><span class="sxs-lookup"><span data-stu-id="68a27-380">The [SQLProcedureColumns](../../native-client-odbc-api/sqlprocedurecolumns.md) function has the same column additions as the **SQLColumns** function.</span></span>  
  
 <span data-ttu-id="68a27-381">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 驅動程式會將 SQL_SS_LENGTH_UNLIMITED 報告為**xml**資料類型的最大 COLUMN_SIZE。</span><span class="sxs-lookup"><span data-stu-id="68a27-381">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED as the maximum COLUMN_SIZE for the **xml** data type.</span></span>  
  
### <a name="supported-conversions"></a><span data-ttu-id="68a27-382">支援的轉換</span><span class="sxs-lookup"><span data-stu-id="68a27-382">Supported Conversions</span></span>  
 <span data-ttu-id="68a27-383">從 SQL 轉換成 C 資料類型時，SQL_C_WCHAR、SQL_C_BINARY 和 SQL_C_CHAR 全都可以轉換成 SQL_SS_XML，其條件如下：</span><span class="sxs-lookup"><span data-stu-id="68a27-383">When converting from SQL to C data types, SQL_C_WCHAR, SQL_C_BINARY, and SQL_C_CHAR can all be converted to SQL_SS_XML, with the following stipulations:</span></span>  
  
-   <span data-ttu-id="68a27-384">SQL_C_WCHAR：格式為 UTF-16，無位元組順序標示 (BOM)，有 Null 結束。</span><span class="sxs-lookup"><span data-stu-id="68a27-384">SQL_C_WCHAR: Format is UTF-16, no byte-order mark (BOM), with null termination.</span></span>  
  
-   <span data-ttu-id="68a27-385">SQL_C_BINARY：格式為 UTF-16，無 Null 結束。</span><span class="sxs-lookup"><span data-stu-id="68a27-385">SQL_C_BINARY: Format is UTF-16, with no null termination.</span></span> <span data-ttu-id="68a27-386">BOM 會加入到接收自伺服器的資料中。</span><span class="sxs-lookup"><span data-stu-id="68a27-386">A BOM is added to data received from the server.</span></span> <span data-ttu-id="68a27-387">如果伺服器傳回空字串，仍然會將 BOM 傳回到應用程式。</span><span class="sxs-lookup"><span data-stu-id="68a27-387">If an empty string is returned by the server a BOM is still returned to the application.</span></span> <span data-ttu-id="68a27-388">如果緩衝區長度為奇數位元組，則會正確地截斷資料。</span><span class="sxs-lookup"><span data-stu-id="68a27-388">If the buffer length is an odd number of bytes the data ise truncated correctly.</span></span> <span data-ttu-id="68a27-389">如果在區塊中傳回整個值，可以串連這些區塊以重新組成正確的值。</span><span class="sxs-lookup"><span data-stu-id="68a27-389">If the whole value is returned in chunks they can be concatenated to re-constitute the correct value</span></span>  
  
-   <span data-ttu-id="68a27-390">SQL_C_CHAR：格式為以用戶端字碼頁搭配 Null 結束編碼的多位元組字元。</span><span class="sxs-lookup"><span data-stu-id="68a27-390">SQL_C_CHAR: Format is multibyte characters encoded in client code page with null termination.</span></span> <span data-ttu-id="68a27-391">從伺服器提供的 UTF-16 進行轉換可能會造成資料損毀，因此，強烈建議您不要使用此繫結。</span><span class="sxs-lookup"><span data-stu-id="68a27-391">Conversion from server supplied UTF-16 may cause data corruption, so this binding is strongly discouraged.</span></span>  
  
 <span data-ttu-id="68a27-392">當從 C 轉換成 SQL 資料類型時，SQL_C_WCHAR、SQL_C_BINARY 和 SQL_C_CHAR 全都可以轉換成 SQL_SS_XML，其條件如下：</span><span class="sxs-lookup"><span data-stu-id="68a27-392">When converting from C to SQL data types, SQL_C_WCHAR, SQL_C_BINARY, and SQL_C_CHAR can all be converted to SQL_SS_XML, with the following stipulations:</span></span>  
  
-   <span data-ttu-id="68a27-393">SQL_C_WCHAR：BOM 永遠會加入到傳送至伺服器的資料中。</span><span class="sxs-lookup"><span data-stu-id="68a27-393">SQL_C_WCHAR: A BOM is always be added to data sent to the server.</span></span> <span data-ttu-id="68a27-394">如果資料已經以 BOM 開頭，這會在緩衝區的開頭產生兩個 BOM。</span><span class="sxs-lookup"><span data-stu-id="68a27-394">If the data already started with a BOM, this results in two BOMs at the start of the buffer.</span></span> <span data-ttu-id="68a27-395">伺服器會使用第一個 BOM 將編碼識別為 UTF-16，然後再捨棄它。</span><span class="sxs-lookup"><span data-stu-id="68a27-395">The server uses the first BOM to recognize the encoding as UTF-16 and then discard it.</span></span> <span data-ttu-id="68a27-396">第二個 BOM 會解譯為零寬度的不分行空格字元。</span><span class="sxs-lookup"><span data-stu-id="68a27-396">The second BOM is interpreted as a zero-width nonbreaking space character.</span></span>  
  
-   <span data-ttu-id="68a27-397">SQL_C_BINARY：沒有執行任何轉換，而且資料會以「現況」傳遞到伺服器。</span><span class="sxs-lookup"><span data-stu-id="68a27-397">SQL_C_BINARY: No conversion is performed, and the data is passed to the server "as is."</span></span> <span data-ttu-id="68a27-398">UTF-16 資料必須以 BOM 開頭；如果不是，伺服器可能無法正確辨識編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-398">UTF-16 data must start with a BOM; if it does not, the encoding may not be correctly recognized by the server.</span></span>  
  
-   <span data-ttu-id="68a27-399">SQL_C_CHAR：用戶端上的資料會轉換為 UTF-16，並傳送到伺服器，做為 SQL_C_WCHAR (包括 BOM 的加入項目)。</span><span class="sxs-lookup"><span data-stu-id="68a27-399">SQL_C_CHAR: The data is converted to UTF-16 on the client and sent to the server just as SQL_C_WCHAR (including the addition of a BOM).</span></span> <span data-ttu-id="68a27-400">如果 XML 沒有在用戶端字碼頁中編碼，這可能會造成資料損毀。</span><span class="sxs-lookup"><span data-stu-id="68a27-400">If the XML is not encoded in the client code page this can cause data corruption.</span></span>  
  
 <span data-ttu-id="68a27-401">XML 標準需要以 UTF-16 編碼的 XML 來開始位元組順序標示 (BOM)，UTF-16 字元程式碼 0xFEFF。</span><span class="sxs-lookup"><span data-stu-id="68a27-401">The XML standard requires UTF-16 encoded XML to start with a byte-order mark (BOM), UTF-16 character code 0xFEFF.</span></span> <span data-ttu-id="68a27-402">使用 SQL_C_BINARY 系結時， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client 不需要或加入 BOM，因為系結會隱含編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-402">When working with a SQL_C_BINARY binding, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client does not require or add a BOM, as the encoding is implied by the binding.</span></span> <span data-ttu-id="68a27-403">其用意在於提供處理其他 XML 處理器和儲存系統的單純性。</span><span class="sxs-lookup"><span data-stu-id="68a27-403">The intent is to provide simplicity in dealing with other XML processors and storage systems.</span></span> <span data-ttu-id="68a27-404">在此情況下，BOM 應該以 UTF-16 編碼的 XML 呈現，而且應用程式不需要在意實際編碼，因為多數 XML 處理器 (包括 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]) 都會檢查值的前幾個位元組來推算編碼。</span><span class="sxs-lookup"><span data-stu-id="68a27-404">In this case a BOM should be present with UTF-16 encoded XML, and the application need not be concerned with the actual encoding, because the majority of XML processors (including [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]) deduce the encoding by inspecting the first few bytes of the value.</span></span> <span data-ttu-id="68a27-405">使用 SQL_C_BINARY 系結從 Native Client 接收的 XML 資料 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 一律會以具有 BOM 的 utf-16 編碼，而且不會有內嵌的編碼宣告。</span><span class="sxs-lookup"><span data-stu-id="68a27-405">XML data received from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client using SQL_C_BINARY bindings are always encoded in UTF-16 with a BOM and without an embedded encoding declaration.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="68a27-406">另請參閱</span><span class="sxs-lookup"><span data-stu-id="68a27-406">See Also</span></span>  
 <span data-ttu-id="68a27-407">[SQL Server Native Client 功能](sql-server-native-client-features.md) </span><span class="sxs-lookup"><span data-stu-id="68a27-407">[SQL Server Native Client Features](sql-server-native-client-features.md) </span></span>  
 [<span data-ttu-id="68a27-408">ISSCommandWithParameters &#40;OLE DB&#41;</span><span class="sxs-lookup"><span data-stu-id="68a27-408">ISSCommandWithParameters &#40;OLE DB&#41;</span></span>](../../native-client-ole-db-interfaces/isscommandwithparameters-ole-db.md)  
  
  
