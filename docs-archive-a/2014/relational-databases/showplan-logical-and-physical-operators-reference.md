---
title: 執行程序邏輯和實體運算子參考 | Microsoft 文件
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87702601"
---
# <a name="showplan-logical-and-physical-operators-reference"></a><span data-ttu-id="b26ba-102">執行程序邏輯和實體運算子參考</span><span class="sxs-lookup"><span data-stu-id="b26ba-102">Showplan Logical and Physical Operators Reference</span></span>
  <span data-ttu-id="b26ba-103">運算子說明 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 如何執行查詢或資料操作語言 (DML) 陳述式。</span><span class="sxs-lookup"><span data-stu-id="b26ba-103">Operators describe how [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement.</span></span> <span data-ttu-id="b26ba-104">查詢最佳化工具會使用運算子來建立查詢計畫，以便建立查詢所指定的結果，或執行 DML 陳述式所指定的作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-104">The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement.</span></span> <span data-ttu-id="b26ba-105">查詢計畫是由實體運算子所組成的樹狀目錄。</span><span class="sxs-lookup"><span data-stu-id="b26ba-105">The query plan is a tree consisting of physical operators.</span></span> <span data-ttu-id="b26ba-106">您可使用 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]中的圖形執行計畫選項 SET SHOWPLAN 陳述式，以及 SQL Server Profiler Showplan 事件類別，檢視查詢計畫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-106">You can view the query plan by using the SET SHOWPLAN statements, the graphical execution plan options in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the SQL Server Profiler Showplan event classes.</span></span>  
  
 <span data-ttu-id="b26ba-107">運算子可分為邏輯與實體運算子兩種。</span><span class="sxs-lookup"><span data-stu-id="b26ba-107">Operators are classified as logical and physical operators.</span></span>  
  
 <span data-ttu-id="b26ba-108">**邏輯運算子**</span><span class="sxs-lookup"><span data-stu-id="b26ba-108">**Logical Operators**</span></span>  
 <span data-ttu-id="b26ba-109">邏輯運算子說明用來處理陳述式的關聯式代數作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-109">Logical operators describe the relational algebraic operation used to process a statement.</span></span> <span data-ttu-id="b26ba-110">換句話說，邏輯運算子可就概念上說明需要執行哪項作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-110">In other words, logical operators describe conceptually what operation needs to be performed.</span></span>  
  
 <span data-ttu-id="b26ba-111">**實體運算子**</span><span class="sxs-lookup"><span data-stu-id="b26ba-111">**Physical Operators**</span></span>  
 <span data-ttu-id="b26ba-112">實體運算子會實作邏輯運算子所描述的作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-112">Physical operators implement the operation described by logical operators.</span></span> <span data-ttu-id="b26ba-113">每個實體運算子都是執行作業的物件或常式。</span><span class="sxs-lookup"><span data-stu-id="b26ba-113">Each physical operator is an object or routine that performs an operation.</span></span> <span data-ttu-id="b26ba-114">例如，有些實體運算子會從資料表、索引或檢視表中存取資料行或資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-114">For example, some physical operators access columns or rows from a table, index or view.</span></span> <span data-ttu-id="b26ba-115">其他實體運算子則會執行其他操作，如計算、彙總、資料完整性檢查或聯結。</span><span class="sxs-lookup"><span data-stu-id="b26ba-115">Other physical operators perform other operations such as calculations, aggregations, data integrity checks or joins.</span></span> <span data-ttu-id="b26ba-116">實體運算子會有上述項目的相關成本。</span><span class="sxs-lookup"><span data-stu-id="b26ba-116">Physical operators have costs associated with them.</span></span>  
  
 <span data-ttu-id="b26ba-117">實體運算子可進行初始化、收集資料及關閉。</span><span class="sxs-lookup"><span data-stu-id="b26ba-117">The physical operators initialize, collect data, and close.</span></span> <span data-ttu-id="b26ba-118">特別是，實體運算子可回應下列三種方法呼叫：</span><span class="sxs-lookup"><span data-stu-id="b26ba-118">Specifically, the physical operator can answer the following three method calls:</span></span>  
  
-   <span data-ttu-id="b26ba-119">**Init()** ：**Init()** 方法會使實體運算子自行初始化，並設定任何必要的資料結構。</span><span class="sxs-lookup"><span data-stu-id="b26ba-119">**Init()**: The **Init()** method causes a physical operator to initialize itself and set up any required data structures.</span></span> <span data-ttu-id="b26ba-120">實體運算子可接收許多 **Init()** 呼叫，但通常實體運算子只會接收一個。</span><span class="sxs-lookup"><span data-stu-id="b26ba-120">The physical operator may receive many **Init()** calls, though typically a physical operator receives only one.</span></span>  
  
-   <span data-ttu-id="b26ba-121">**GetNext()** ：**GetNext()** 方法會使實體運算子取得資料的第一個或下一個資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-121">**GetNext()**: The **GetNext()** method causes a physical operator to get the first, or subsequent row of data.</span></span> <span data-ttu-id="b26ba-122">實體運算子可能會接收零個或許多 **GetNext()** 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-122">The physical operator may receive zero or many **GetNext()** calls.</span></span>  
  
-   <span data-ttu-id="b26ba-123">**Close()** ：**Close()** 方法會使實體運算子執行某些清除作業並自行關閉。</span><span class="sxs-lookup"><span data-stu-id="b26ba-123">**Close()**: The **Close()** method causes a physical operator to perform some clean-up operations and shut itself down.</span></span> <span data-ttu-id="b26ba-124">實體運算子只會接收一個 **Close()** 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-124">A physical operator only receives one **Close()** call.</span></span>  
  
 <span data-ttu-id="b26ba-125">**GetNext()** 方法會傳回一列資料，而它被呼叫的次數會在使用 SET STATISTICS PROFILE ON or SET STATISTICS XML ON 所產生的「執行程序表」輸出中顯示為 **ActualRows**。</span><span class="sxs-lookup"><span data-stu-id="b26ba-125">The **GetNext()** method returns one row of data, and the number of times it is called appears as **ActualRows** in the Showplan output that is produced by using SET STATISTICS PROFILE ON or SET STATISTICS XML ON.</span></span> <span data-ttu-id="b26ba-126">如需這些 SET 選項的詳細資訊，請參閱 [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) 和 [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-126">For more information about these SET options, see [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) and [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span></span>  
  
 <span data-ttu-id="b26ba-127">「執行程序表」輸出中顯示的 **ActualRebinds** 和 **ActualRewinds** 計數代表 **Init()** 方法被呼叫的次數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-127">The **ActualRebinds** and **ActualRewinds** counts that appear in Showplan output refer to the number of times that the **Init()** method is called.</span></span> <span data-ttu-id="b26ba-128">除非運算子位於迴圈聯結的內部，否則 **ActualRebinds** 會等於一，而 **ActualRewinds** 會等於零。</span><span class="sxs-lookup"><span data-stu-id="b26ba-128">Unless an operator is on the inner side of a loop join, **ActualRebinds** equals one and **ActualRewinds** equals zero.</span></span> <span data-ttu-id="b26ba-129">如果運算子位於迴圈聯結的內部，重新繫結和倒轉數目的總和應該會等於聯結外部所處理的資料列數目。</span><span class="sxs-lookup"><span data-stu-id="b26ba-129">If an operator is on the inner side of a loop join, the sum of the number of rebinds and rewinds should equal the number of rows processed on the outer side of the join.</span></span> <span data-ttu-id="b26ba-130">重新繫結是指聯結中有一或多個相互關聯的參數發生變更，而必須重新評估內部。</span><span class="sxs-lookup"><span data-stu-id="b26ba-130">A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated.</span></span> <span data-ttu-id="b26ba-131">倒轉是指相互關聯的參數沒有發生變更，先前的內部結果集可供重複使用。</span><span class="sxs-lookup"><span data-stu-id="b26ba-131">A rewind means that none of the correlated parameters changed and the prior inner result set may be reused.</span></span>  
  
 <span data-ttu-id="b26ba-132">**ActualRebinds** 和 **ActualRewinds** 會顯示在使用 SET STATISTICS XML ON 產生的「XML 執行程序表」輸出中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-132">**ActualRebinds** and **ActualRewinds** are present in XML Showplan output produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="b26ba-133">它們只會填入非叢集**索引**多工緩衝處理、資料列計數多工緩衝處理、資料表多工緩衝處理 `Remote Query` **Row Count Spool** `Sort` 和**資料表值函數**運算子。 **Table Spool**</span><span class="sxs-lookup"><span data-stu-id="b26ba-133">They are only populated for the **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, and **Table-valued Function** operators.</span></span> <span data-ttu-id="b26ba-134">**ActualRebinds** **ActualRewinds** `Assert` 當**StartupExpression**屬性設定為 TRUE 時，ActualRebinds 和 ActualRewinds 也可能會填入和**篩選**運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-134">**ActualRebinds** and **ActualRewinds** may also be populated for the `Assert` and **Filter** operators when the **StartupExpression** attribute is set to TRUE.</span></span>  
  
 <span data-ttu-id="b26ba-135">「XML 執行程序表」中有 **ActualRebinds** 和 **ActualRewinds** 時，您可將它們與 **EstimateRebinds** 和 **EstimateRewinds** 做比較。</span><span class="sxs-lookup"><span data-stu-id="b26ba-135">When **ActualRebinds** and **ActualRewinds** are present in an XML Showplan, they are comparable to **EstimateRebinds** and **EstimateRewinds**.</span></span> <span data-ttu-id="b26ba-136">如果沒有，則可將估計的資料列數目 (**EstimateRows**) 和實際資料列數目 (**ActualRows**) 做比較。</span><span class="sxs-lookup"><span data-stu-id="b26ba-136">When they are absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**).</span></span> <span data-ttu-id="b26ba-137">請注意，如果沒有實際重新繫結和實際倒轉，實際圖形「執行程序表」輸出便會顯示零。</span><span class="sxs-lookup"><span data-stu-id="b26ba-137">Note that actual graphical Showplan output displays zeros for the actual rebinds and actual rewinds when they are absent.</span></span>  
  
 <span data-ttu-id="b26ba-138">只有當「執行程序表」輸出是以 SET STATISTICS XML ON 產生時，才可使用相關的計數器 **ActualEndOfScans**。</span><span class="sxs-lookup"><span data-stu-id="b26ba-138">A related counter, **ActualEndOfScans**, is available only when Showplan output is produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="b26ba-139">每當實體運算子存取至其資料流結尾時，此計數器就會累加 1。</span><span class="sxs-lookup"><span data-stu-id="b26ba-139">Whenever a physical operator reaches the end of its data stream, this counter is incremented by one.</span></span> <span data-ttu-id="b26ba-140">實體運算子可存取其資料流結尾零次、一次或多次。</span><span class="sxs-lookup"><span data-stu-id="b26ba-140">A physical operator can reach the end of its data stream zero, one, or multiple times.</span></span> <span data-ttu-id="b26ba-141">如同重新繫結和倒轉，只有當運算子位於迴圈聯結內部時，結尾掃描次數才能大於 1。</span><span class="sxs-lookup"><span data-stu-id="b26ba-141">As with rebinds and rewinds, the number of end of scans can be more than one only if the operator is on the inner side of a loop join.</span></span> <span data-ttu-id="b26ba-142">結尾掃描次數應小於或等於重新繫結和倒轉的數目總和。</span><span class="sxs-lookup"><span data-stu-id="b26ba-142">The number of end of scans should be less than or equal to the sum of the number of rebinds and rewinds.</span></span>  
  
## <a name="mapping-physical-and-logical-operators"></a><span data-ttu-id="b26ba-143">對應實體與邏輯運算子</span><span class="sxs-lookup"><span data-stu-id="b26ba-143">Mapping Physical and Logical Operators</span></span>  
 <span data-ttu-id="b26ba-144">查詢最佳化工具會將查詢計畫建立為由邏輯運算子所組成的樹狀目錄。</span><span class="sxs-lookup"><span data-stu-id="b26ba-144">The query optimizer creates a query plan as a tree consisting of logical operators.</span></span> <span data-ttu-id="b26ba-145">在查詢最佳化工具建立計畫之後，它會為每個邏輯運算子選擇最有效率的實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-145">After the query optimizer creates the plan, the query optimizer chooses the most efficient physical operator for each logical operator.</span></span> <span data-ttu-id="b26ba-146">查詢最佳化工具會使用以成本為基礎的方法，判斷哪個實體運算子將實作邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-146">The query optimizer uses a cost-based approach to determine which physical operator will implement a logical operator.</span></span>  
  
 <span data-ttu-id="b26ba-147">一個邏輯運算子通常可由多個實體運算子實作。</span><span class="sxs-lookup"><span data-stu-id="b26ba-147">Usually, a logical operation can be implemented by multiple physical operators.</span></span> <span data-ttu-id="b26ba-148">不過，在極少數的情況下，實體運算子也可以實作多個邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-148">However, in rare cases, a physical operator can implement multiple logical operations as well.</span></span>  
  
## <a name="operator-descriptions"></a><span data-ttu-id="b26ba-149">運算子描述</span><span class="sxs-lookup"><span data-stu-id="b26ba-149">Operator Descriptions</span></span>  
 <span data-ttu-id="b26ba-150">本節包含邏輯與實體運算子的說明：</span><span class="sxs-lookup"><span data-stu-id="b26ba-150">This section contains descriptions of the logical and physical operators.</span></span>  
  
|<span data-ttu-id="b26ba-151">圖形執行計畫圖示</span><span class="sxs-lookup"><span data-stu-id="b26ba-151">Graphical Execution Plan Icon</span></span>|<span data-ttu-id="b26ba-152">Showplan 運算子</span><span class="sxs-lookup"><span data-stu-id="b26ba-152">Showplan Operator</span></span>|<span data-ttu-id="b26ba-153">描述</span><span class="sxs-lookup"><span data-stu-id="b26ba-153">Description</span></span>|  
|-----------------------------------|-----------------------|-----------------|  
|<span data-ttu-id="b26ba-154">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-154">None</span></span>|`Aggregate`|<span data-ttu-id="b26ba-155">`Aggregate` 運算子會計算包含 MIN、MAX、SUM、COUNT 或 AVG 的運算式。</span><span class="sxs-lookup"><span data-stu-id="b26ba-155">The `Aggregate` operator calculates an expression containing MIN, MAX, SUM, COUNT or AVG.</span></span> <span data-ttu-id="b26ba-156">`Aggregate` 運算子可以是邏輯運算子或實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-156">The `Aggregate` operator can be a logical operator or a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-157">![算術運算式運算子圖示](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "算術運算式運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-157">![Arithmetic expression operator icon](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic expression operator icon")</span></span>|`Arithmetic Expression`|<span data-ttu-id="b26ba-158">`Arithmetic Expression` 運算子會從資料列中現有的值計算出新的值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-158">The `Arithmetic Expression` operator computes a new value from existing values in a row.</span></span> <span data-ttu-id="b26ba-159">`Arithmetic Expression` 無法用於 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-159">`Arithmetic Expression` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="b26ba-160">![判斷提示運算子圖示](../../2014/database-engine/media/assert-32x.gif "判斷提示運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-160">![Assert operator icon](../../2014/database-engine/media/assert-32x.gif "Assert operator icon")</span></span>|`Assert`|<span data-ttu-id="b26ba-161">`Assert` 運算子會驗證條件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-161">The `Assert` operator verifies a condition.</span></span> <span data-ttu-id="b26ba-162">例如，它會驗證參考完整性，或確定純量子查詢傳回一個資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-162">For example, it validates referential integrity or ensures that a scalar subquery returns one row.</span></span> <span data-ttu-id="b26ba-163">針對每個輸入資料 `Assert` 列，運算子會評估 `Argument` 執行計畫之資料行中的運算式。</span><span class="sxs-lookup"><span data-stu-id="b26ba-163">For each input row, the `Assert` operator evaluates the expression in the `Argument` column of the execution plan.</span></span> <span data-ttu-id="b26ba-164">如果這個運算式評估為 NULL，代表資料列通過 `Assert` 運算子的驗證，則查詢會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-164">If this expression evaluates to NULL, the row is passed through the `Assert` operator and the query execution continues.</span></span> <span data-ttu-id="b26ba-165">如果這個運算式得出非 Null 值，就會得出相對的錯誤。</span><span class="sxs-lookup"><span data-stu-id="b26ba-165">If this expression evaluates to a nonnull value, the appropriate error will be raised.</span></span> <span data-ttu-id="b26ba-166">`Assert` 運算子是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-166">The `Assert` operator is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-167">![指派語言項目圖示](../../2014/database-engine/media/assign-32.gif "指派語言項目圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-167">![Assign language element icon](../../2014/database-engine/media/assign-32.gif "Assign language element icon")</span></span>|`Assign`|<span data-ttu-id="b26ba-168">`Assign` 運算子會將運算式的值或常數指派給變數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-168">The `Assign` operator assigns the value of an expression or a constant to a variable.</span></span> <span data-ttu-id="b26ba-169">`Assign` 是語言元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-169">`Assign` is a language element.</span></span>|  
|<span data-ttu-id="b26ba-170">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-170">None</span></span>|`Asnyc Concat`|<span data-ttu-id="b26ba-171">`Asnyc Concat` 運算子只能使用於遠端查詢 (分散式查詢)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-171">The `Asnyc Concat` operator is used only in remote queries (distributed queries).</span></span> <span data-ttu-id="b26ba-172">它有 *n* 個子節點和一個父節點。</span><span class="sxs-lookup"><span data-stu-id="b26ba-172">It has *n* children and one parent node.</span></span> <span data-ttu-id="b26ba-173">一般來說，某些子節點是參與分散式查詢的遠端電腦。</span><span class="sxs-lookup"><span data-stu-id="b26ba-173">Usually, some of the children are remote computers that participate in a distributed query.</span></span> <span data-ttu-id="b26ba-174">`Asnyc Concat` 會同時對所有子節點發出 `open()` 呼叫，然後再將點陣圖套用到每個子節點。</span><span class="sxs-lookup"><span data-stu-id="b26ba-174">`Asnyc Concat` issues `open()` calls to all of the children simultaneously and then applies a bitmap to each child.</span></span> <span data-ttu-id="b26ba-175">`Async Concat` 會針對每一個是 1 的位元，視需要將輸出資料列傳送至父節點。</span><span class="sxs-lookup"><span data-stu-id="b26ba-175">For each bit that is a 1, `Async Concat` sends the output rows to the parent node on demand.</span></span>|  
|<span data-ttu-id="b26ba-176">![點陣圖運算子圖示](../../2014/database-engine/media/bitmap-32x.gif "點陣圖運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-176">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="b26ba-177">使用 `Bitmap` 運算子，在平行查詢計劃中執行點陣圖篩選。</span><span class="sxs-lookup"><span data-stu-id="b26ba-177">uses the `Bitmap` operator to implement bitmap filtering in parallel query plans.</span></span> <span data-ttu-id="b26ba-178">點陣圖篩選會藉由刪除索引鍵值無法產生任何聯結記錄的資料列來加速查詢執行，然後再透過另一個運算子（例如運算子）傳遞資料列 `Parallelism` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-178">Bitmap filtering speeds up query execution by eliminating rows with key values that cannot produce any join records before passing rows through another operator such as the `Parallelism` operator.</span></span> <span data-ttu-id="b26ba-179">點陣圖篩選會於運算子樹狀目錄的一部分，以精簡方式顯示資料表中的一組值，以便從此樹狀目錄的另一個部分篩選第二個資料表中的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-179">A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree.</span></span> <span data-ttu-id="b26ba-180">藉由盡早移除查詢中的不必要資料列，後續的運算子需要處理的資料列就會更少，而查詢的整體效能也會提升。</span><span class="sxs-lookup"><span data-stu-id="b26ba-180">By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves.</span></span> <span data-ttu-id="b26ba-181">最佳化工具會判斷點陣圖何時具有足夠的選擇性能夠充分運用以及將篩選套用到哪個運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-181">The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.</span></span> <span data-ttu-id="b26ba-182">`Bitmap` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-182">`Bitmap` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-183">![點陣圖運算子圖示](../../2014/database-engine/media/bitmap-32x.gif "點陣圖運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-183">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap Create`|<span data-ttu-id="b26ba-184">`Bitmap Create` 運算子會出現在建立點陣圖的 Showplan 輸出中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-184">The `Bitmap Create` operator appears in the Showplan output where bitmaps are built.</span></span> <span data-ttu-id="b26ba-185">`Bitmap Create` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-185">`Bitmap Create` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-186">![書籤查閱運算子圖示](../../2014/database-engine/media/bookmark-lookup-32x.gif "書籤查閱運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-186">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Bookmark Lookup`|<span data-ttu-id="b26ba-187">`Bookmark Lookup` 運算子使用書籤 (資料列識別碼或叢集索引鍵) 在資料表或叢集索引中查閱對應的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-187">The `Bookmark Lookup` operator uses a bookmark (row ID or clustering key) to look up the corresponding row in the table or clustered index.</span></span> <span data-ttu-id="b26ba-188">資料 `Argument` 行包含書簽標籤，用來查閱資料表或叢集索引中的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-188">The `Argument` column contains the bookmark label used to look up the row in the table or clustered index.</span></span> <span data-ttu-id="b26ba-189">此資料 `Argument` 行也包含查閱資料列所在之資料表或叢集索引的名稱。</span><span class="sxs-lookup"><span data-stu-id="b26ba-189">The `Argument` column also contains the name of the table or clustered index in which the row is looked up.</span></span> <span data-ttu-id="b26ba-190">如果資料行中出現 WITH 預先提取子句 `Argument` ，表示查詢處理器已決定在資料表或叢集索引中查閱書簽時，使用非同步預先提取 (預先讀取) 的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="b26ba-190">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the table or clustered index.</span></span><br /><br /> <span data-ttu-id="b26ba-191">`Bookmark Lookup` 無法用於 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-191">`Bookmark Lookup` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span> <span data-ttu-id="b26ba-192">不過，`Clustered Index Seek` 和 `RID Lookup` 會提供書籤查閱功能。</span><span class="sxs-lookup"><span data-stu-id="b26ba-192">Instead, `Clustered Index Seek` and `RID Lookup` provide bookmark lookup functionality.</span></span> <span data-ttu-id="b26ba-193">`Key Lookup` 運算子也提供這項功能。</span><span class="sxs-lookup"><span data-stu-id="b26ba-193">The `Key Lookup` operator also provides this functionality.</span></span>|  
|<span data-ttu-id="b26ba-194">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-194">None</span></span>|`Branch Repartition`|<span data-ttu-id="b26ba-195">在平行查詢計畫中，有時候會有 Iterator 的概念區。</span><span class="sxs-lookup"><span data-stu-id="b26ba-195">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="b26ba-196">在這種區域內的所有 Iterator，都可以由平行執行緒來執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-196">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="b26ba-197">區域本身必須連續執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-197">The regions themselves must be executed serially.</span></span> <span data-ttu-id="b26ba-198">個別區域內的一些 `Parallelism` Iterator，稱為 `Branch Repartition`。</span><span class="sxs-lookup"><span data-stu-id="b26ba-198">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="b26ba-199">在兩個這種區域的界限上的 `Parallelism` Iterator，稱為 `Segment Repartition`。</span><span class="sxs-lookup"><span data-stu-id="b26ba-199">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="b26ba-200">`Branch Repartition` 和 `Segment Repartition` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-200">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="b26ba-201">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-201">None</span></span>|`Broadcast`|<span data-ttu-id="b26ba-202">`Broadcast`有一個子節點和*n*個父節點。</span><span class="sxs-lookup"><span data-stu-id="b26ba-202">`Broadcast` has one child node and *n* parent nodes.</span></span> <span data-ttu-id="b26ba-203">`Broadcast` 會依要求將其輸入資料列傳送至多位取用者。</span><span class="sxs-lookup"><span data-stu-id="b26ba-203">`Broadcast` sends its input rows to multiple consumers on demand.</span></span> <span data-ttu-id="b26ba-204">每位取用者都會收到所有資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-204">Each consumer gets all of the rows.</span></span> <span data-ttu-id="b26ba-205">例如，若所有取用者都是雜湊聯結的建立者，則會建立 *n* 份雜湊資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-205">For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables will be built.</span></span>|  
|<span data-ttu-id="b26ba-206">![建立雜湊運算子圖示](../../2014/database-engine/media/build-hash.gif "建立雜湊運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-206">![Build hash operator icon](../../2014/database-engine/media/build-hash.gif "Build hash operator icon")</span></span>|`Build Hash`|<span data-ttu-id="b26ba-207">指示建立 xVelocity 記憶體最佳化的資料行存放區索引之批次雜湊資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-207">Indicates the build of a batch hash table for an xVelocity memory optimized columnstore index.</span></span>|  
|<span data-ttu-id="b26ba-208">None</span><span class="sxs-lookup"><span data-stu-id="b26ba-208">None</span></span>|`Cache`|<span data-ttu-id="b26ba-209">`Cache`是多工**緩衝**處理運算子的特製化版本。</span><span class="sxs-lookup"><span data-stu-id="b26ba-209">`Cache` is a specialized version of the **Spool** operator.</span></span> <span data-ttu-id="b26ba-210">它只儲存一列資料。</span><span class="sxs-lookup"><span data-stu-id="b26ba-210">It stores only one row of data.</span></span> <span data-ttu-id="b26ba-211">`Cache` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-211">`Cache` is a logical operator.</span></span> <span data-ttu-id="b26ba-212">`Cache` 無法用於 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-212">`Cache` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="b26ba-213">![叢集索引刪除運算子圖示](../../2014/database-engine/media/clustered-index-delete-32x.gif "叢集索引刪除運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-213">![Clustered index delete operator icon](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered index delete operator icon")</span></span>|`Clustered Index Delete`|<span data-ttu-id="b26ba-214">`Clustered Index Delete` 運算子會從查詢執行計畫之 Argument 資料行所指定的叢集索引中刪除資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-214">The `Clustered Index Delete` operator deletes rows from the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="b26ba-215">如果 Argument 資料行中出現 WHERE:() 述詞，就只刪除滿足述詞的資料列。`Clustered Index Delete`</span><span class="sxs-lookup"><span data-stu-id="b26ba-215">If a WHERE:() predicate is present in the Argument column, then only those rows that satisfy the predicate are deleted.`Clustered Index Delete`</span></span> <span data-ttu-id="b26ba-216"> 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-216">is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-217">![叢集索引插入運算子圖示](../../2014/database-engine/media/clustered-index-insert-32x.gif "叢集索引插入運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-217">![Clustered index insert operator icon](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered index insert operator icon")</span></span>|`Clustered Index Insert`|<span data-ttu-id="b26ba-218">`Clustered Index Insert` 執行程序表運算子會將其輸入的資料列插入 Argument 資料行所指定的叢集索引中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-218">The `Clustered Index Insert` Showplan operator inserts rows from its input into the clustered index specified in the Argument column.</span></span> <span data-ttu-id="b26ba-219">Argument 資料行也包含 SET:() 述詞，指出每一個資料行設定的值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-219">The Argument column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="b26ba-220">如果沒有 `Clustered Index Insert` 插入值的子系，則會從運算子本身取得插入的資料列 `Insert` 。`Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="b26ba-220">If `Clustered Index Insert` has no children for insert values, the row inserted is taken from the `Insert` operator itself.`Clustered Index Insert`</span></span> <span data-ttu-id="b26ba-221"> 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-221">is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-222">![叢集索引合併運算子](../../2014/database-engine/media/clustered-index-merge-32x.gif "叢集索引合併運算子")</span><span class="sxs-lookup"><span data-stu-id="b26ba-222">![Clustered index merge operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered index merge operator")</span></span>|<span data-ttu-id="b26ba-223">**叢集索引合併**</span><span class="sxs-lookup"><span data-stu-id="b26ba-223">**Clustered Index Merge**</span></span>|<span data-ttu-id="b26ba-224">「叢集索引合併」運算子會將合併資料流套用到叢集索引。</span><span class="sxs-lookup"><span data-stu-id="b26ba-224">The **Clustered Index Merge** operator applies a merge data stream to a clustered index.</span></span> <span data-ttu-id="b26ba-225">運算子會從運算子的資料行中指定的叢集索引中刪除、更新或插入資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-225">The operator deletes, updates, or inserts rows from the clustered index specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="b26ba-226">所執行的實際作業取決於運算子的資料行中所指定之**動作**資料行的運行時間值 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-226">The actual operation performed depends on the runtime value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="b26ba-227">「叢集索引合併」是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-227">**Clustered Index Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-228">![叢集索引掃描運算子圖示](../../2014/database-engine/media/clustered-index-scan-32x.gif "叢集索引掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-228">![Clustered index scan operator icon](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered index scan operator icon")</span></span>|`Clustered Index Scan`|<span data-ttu-id="b26ba-229">`Clustered Index Scan` 運算子會掃描查詢執行計畫的 Argument 資料行中指定的叢集索引。</span><span class="sxs-lookup"><span data-stu-id="b26ba-229">The `Clustered Index Scan` operator scans the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="b26ba-230">出現選擇性的 WHERE:() 述詞時，只會傳回滿足述詞的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-230">When an optional WHERE:() predicate is present, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="b26ba-231">如果 Argument 資料行中包含 ORDERED 子句，表示查詢處理器要求資料列的輸出須按叢集索引的排序次序傳回。</span><span class="sxs-lookup"><span data-stu-id="b26ba-231">If the Argument column contains the ORDERED clause, the query processor has requested that the output of the rows be returned in the order in which the clustered index has sorted it.</span></span> <span data-ttu-id="b26ba-232">如果沒有 ORDERED 子句，儲存引擎會以最佳方式搜尋索引，而不需要排序輸出。</span><span class="sxs-lookup"><span data-stu-id="b26ba-232">If the ORDERED clause is not present, the storage engine scans the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="b26ba-233">`Clustered Index Scan` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-233">`Clustered Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-234">![叢集索引搜尋運算子圖示](../../2014/database-engine/media/clustered-index-seek-32x.gif "叢集索引搜尋運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-234">![Clustered index seek operator icon](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered index seek operator icon")</span></span>|`Clustered Index Seek`|<span data-ttu-id="b26ba-235">`Clustered Index Seek` 運算子使用索引的搜尋能力，從叢集索引中擷取資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-235">The `Clustered Index Seek` operator uses the seeking ability of indexes to retrieve rows from a clustered index.</span></span> <span data-ttu-id="b26ba-236">資料 `Argument` 行包含所使用的叢集索引名稱，以及 SEEK： ( # A1 述詞。</span><span class="sxs-lookup"><span data-stu-id="b26ba-236">The `Argument` column contains the name of the clustered index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="b26ba-237">儲存引擎會使用索引來處理滿足這個 SEEK:() 述詞的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-237">The storage engine uses the index to process only those rows that satisfy this SEEK:() predicate.</span></span> <span data-ttu-id="b26ba-238">也可以包含 WHERE:() 述詞，讓儲存引擎針對滿足 SEEK:() 述詞的所有資料列進行評估，但此為選擇性，且不使用索引來完成此程序。</span><span class="sxs-lookup"><span data-stu-id="b26ba-238">It can also include a WHERE:() predicate where the storage engine evaluates against all rows that satisfy the SEEK:() predicate, but this is optional and does not use indexes to complete this process.</span></span><br /><br /> <span data-ttu-id="b26ba-239">如果資料 `Argument` 行包含已排序的子句，則查詢處理器已判定資料列必須依照叢集索引已排序的順序傳回。</span><span class="sxs-lookup"><span data-stu-id="b26ba-239">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them.</span></span> <span data-ttu-id="b26ba-240">如果沒有 ORDERED 子句，儲存引擎會以最佳方式搜尋索引，不需要將輸出排序。</span><span class="sxs-lookup"><span data-stu-id="b26ba-240">If the ORDERED clause is not present, the storage engine searches the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="b26ba-241">讓輸出維持次序會比產生不按次序的輸出更沒效率。</span><span class="sxs-lookup"><span data-stu-id="b26ba-241">Allowing the output to retain its ordering can be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="b26ba-242">出現關鍵字 LOOKUP 時，表示正在執行書籤查閱。</span><span class="sxs-lookup"><span data-stu-id="b26ba-242">When the keyword LOOKUP appears, then a bookmark lookup is being performed.</span></span> <span data-ttu-id="b26ba-243">在 [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 和更新版本中， `Key Lookup` 運算子會提供書簽查閱功能。</span><span class="sxs-lookup"><span data-stu-id="b26ba-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the `Key Lookup` operator provides bookmark lookup functionality.</span></span> <span data-ttu-id="b26ba-244">`Clustered Index Seek` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-244">`Clustered Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-245">![叢集索引更新運算子圖示](../../2014/database-engine/media/clustered-index-update-32x.gif "叢集索引更新運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-245">![Clustered index update operator icon](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered index update operator icon")</span></span>|`Clustered Index Update`|<span data-ttu-id="b26ba-246">`Clustered Index Update`運算子會更新資料行中所指定之叢集索引內的輸入資料 `Argument` 列。如果有 WHERE： ( # A1 述詞，則只會更新滿足這個述詞的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-246">The `Clustered Index Update` operator updates input rows in the clustered index specified in the `Argument` column.If a WHERE:() predicate is present, only those rows that satisfy this predicate are updated.</span></span> <span data-ttu-id="b26ba-247">如果出現 SET:() 述詞，則每個更新的資料行都會設為這個值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-247">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="b26ba-248">如果出現 DEFINE:() 述詞，就會列出這個運算子定義的數值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-248">If a DEFINE:() predicate is present, the values that this operator defines are listed.</span></span> <span data-ttu-id="b26ba-249">在 SET 子句中或這個運算子中以及這個查詢中的其他位置，都可以參考這些數值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-249">These values may be referenced in the SET clause or elsewhere within this operator and elsewhere within this query.</span></span> <span data-ttu-id="b26ba-250">`Clustered Index Update` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-250">`Clustered Index Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-251">![摺疊運算子圖示](../../2014/database-engine/media/collapse-32x.gif "摺疊運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-251">![Collapse operator icon](../../2014/database-engine/media/collapse-32x.gif "Collapse operator icon")</span></span>|`Collapse`|<span data-ttu-id="b26ba-252">`Collapse` 運算子可最佳化更新處理。</span><span class="sxs-lookup"><span data-stu-id="b26ba-252">The `Collapse` operator optimizes update processing.</span></span> <span data-ttu-id="b26ba-253">執行更新時，它可以分割成 (使用 `Split` 運算子) 刪除與插入。</span><span class="sxs-lookup"><span data-stu-id="b26ba-253">When an update is performed, it can be split (using the `Split` operator) into a delete and an insert.</span></span> <span data-ttu-id="b26ba-254">此資料 `Argument` 行包含指定索引鍵資料行清單的 GROUP BY： ( # A1 子句。</span><span class="sxs-lookup"><span data-stu-id="b26ba-254">The `Argument` column contains a GROUP BY:() clause that specifies a list of key columns.</span></span> <span data-ttu-id="b26ba-255">如果查詢處理器發現了刪除及插入相同索引鍵值的相鄰資料列，會以更有效率的單一更新作業來取代這些不同的作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-255">If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single more efficient update operation.</span></span> <span data-ttu-id="b26ba-256">`Collapse` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-256">`Collapse` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-257">![資料行存放區索引掃描](../../2014/database-engine/media/columnstoreindexscan.gif "資料行存放區索引掃描")</span><span class="sxs-lookup"><span data-stu-id="b26ba-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span></span>|`Columnstore Index Scan`|<span data-ttu-id="b26ba-258">`Columnstore Index Scan`運算子會掃描 `Argument` 查詢執行計畫之資料行中所指定的資料行存放區索引。</span><span class="sxs-lookup"><span data-stu-id="b26ba-258">The `Columnstore Index Scan` operator scans the columnstore index specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="b26ba-259">![計算純量運算子圖示](../../2014/database-engine/media/compute-scalar-32x.gif "計算純量運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-259">![Compute scalar operator icon](../../2014/database-engine/media/compute-scalar-32x.gif "Compute scalar operator icon")</span></span>|`Compute Scalar`|<span data-ttu-id="b26ba-260">`Compute Scalar`運算子會評估運算式，以產生計算的純量值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-260">The `Compute Scalar` operator evaluates an expression to produce a computed scalar value.</span></span> <span data-ttu-id="b26ba-261">然後可能會將此值傳回給使用者，或由查詢的其他地方來參考，或兩者皆是。</span><span class="sxs-lookup"><span data-stu-id="b26ba-261">This may then be returned to the user, referenced elsewhere in the query, or both.</span></span> <span data-ttu-id="b26ba-262">例如在篩選述詞或聯結述詞中，就會見到這兩種情況。</span><span class="sxs-lookup"><span data-stu-id="b26ba-262">An example of both is in a filter predicate or join predicate.</span></span> <span data-ttu-id="b26ba-263">`Compute Scalar` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-263">`Compute Scalar` is a logical and physical operator.</span></span><br /><br /> <span data-ttu-id="b26ba-264">`Compute Scalar`在 SET STATISTICS XML 產生的執行程式表中出現的運算子可能不包含 `RunTimeInformation` 元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-264">`Compute Scalar` operators that appear in Showplans generated by SET STATISTICS XML might not contain the `RunTimeInformation` element.</span></span> <span data-ttu-id="b26ba-265">在圖形化的執行程序表中，當選取 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] 中的 [包括實際執行計畫] 選項時，[實際資料列]、[實際重新繫結] 與 [實際倒轉] 可能不會顯示在 [屬性] 視窗中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-265">In graphical Showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="b26ba-266">發生此情況時，表示這些運算子雖然用於編譯的執行計畫中，它們的作用是由即時查詢計畫中的其他運算子執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-266">When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the run-time query plan.</span></span> <span data-ttu-id="b26ba-267">同時也請注意，由 SET STATISTICS PROFILE 產生的「執行程序表」輸出中的執行數目，等於由 SET STATISTICS XML 產生的「執行程序表」中重新繫結和倒轉的總和。</span><span class="sxs-lookup"><span data-stu-id="b26ba-267">Also note that the number of executes in Showplan output generated by SET STATISTICS PROFILE is equivalent to the sum of rebinds and rewinds in Showplans generated by SET STATISTICS XML.</span></span>|  
|<span data-ttu-id="b26ba-268">![串連運算子圖示](../../2014/database-engine/media/concatenation-32x.gif "串連運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-268">![Concatenation operator icon](../../2014/database-engine/media/concatenation-32x.gif "Concatenation operator icon")</span></span>|<span data-ttu-id="b26ba-269">**串連**</span><span class="sxs-lookup"><span data-stu-id="b26ba-269">**Concatenation**</span></span>|<span data-ttu-id="b26ba-270">「串連」運算子會掃描多個輸入，並傳回每一個掃描的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-270">The **Concatenation** operator scans multiple inputs, returning each row scanned.</span></span> <span data-ttu-id="b26ba-271">「串連」通常用來實作 [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL 建構。</span><span class="sxs-lookup"><span data-stu-id="b26ba-271">**Concatenation** is typically used to implement the [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL construct.</span></span> <span data-ttu-id="b26ba-272">「串連」實體運算子有兩個以上的輸入和一個輸出。</span><span class="sxs-lookup"><span data-stu-id="b26ba-272">The **Concatenation** physical operator has two or more inputs and one output.</span></span> <span data-ttu-id="b26ba-273">串連作業會將資料列從第一個輸入資料流複製到輸出資料流，再對其他每一個輸入資料流重複此作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-273">Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.</span></span> <span data-ttu-id="b26ba-274">「串連」是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-274">**Concatenation** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-275">![固定掃描運算子圖示](../../2014/database-engine/media/constant-scan-32x.gif "固定掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-275">![Constant scan operator icon](../../2014/database-engine/media/constant-scan-32x.gif "Constant scan operator icon")</span></span>|`Constant Scan`|<span data-ttu-id="b26ba-276">運算子會在 `Constant Scan` 查詢中引進一或多個常數資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-276">The `Constant Scan` operator introduces one or more constant rows into a query.</span></span> <span data-ttu-id="b26ba-277">`Compute Scalar`運算子通常會在之後用 `Constant Scan` 來將資料行加入至運算子所產生的資料列 `Constant Scan` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-277">A `Compute Scalar` operator is often used after a `Constant Scan` to add columns to a row produced by the `Constant Scan` operator.</span></span>|  
|<span data-ttu-id="b26ba-278">![轉換 (資料庫引擎) 語言項目圖示](../../2014/database-engine/media/convert-32x.gif "轉換 (資料庫引擎) 語言項目圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-278">![Convert (Database Engine) language element icon](../../2014/database-engine/media/convert-32x.gif "Convert (Database Engine) language element icon")</span></span>|`Convert`|<span data-ttu-id="b26ba-279">`Convert` 運算子可將某個純量資料類型轉換為另一個資料類型。</span><span class="sxs-lookup"><span data-stu-id="b26ba-279">The `Convert` operator converts one scalar data type to another.</span></span> <span data-ttu-id="b26ba-280">`Convert` 是語言元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-280">`Convert` is a language element.</span></span>|  
|<span data-ttu-id="b26ba-281">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-281">None</span></span>|`Cross Join`|<span data-ttu-id="b26ba-282">`Cross Join` 運算子會將第一個 (頂端) 輸入的每一列與第二個 (底部) 輸入的每一列相聯結。</span><span class="sxs-lookup"><span data-stu-id="b26ba-282">The `Cross Join` operator joins each row from the first (top) input with each row from the second (bottom) input.</span></span> <span data-ttu-id="b26ba-283">`Cross Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-283">`Cross Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-284">![資料指標 Catchall 資料指標運算子圖示](../../2014/database-engine/media/cursor-catch-all.gif "資料指標 catchall 資料指標運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-284">![Cursor catchall cursor operator icon](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor operator icon")</span></span>|`catchall`|<span data-ttu-id="b26ba-285">產生圖形執行程序表的邏輯若找不到適當的 Iterator 圖示，就會顯示 [雜物箱] 圖示。</span><span class="sxs-lookup"><span data-stu-id="b26ba-285">The catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical showplans.</span></span> <span data-ttu-id="b26ba-286">[雜物箱] 圖示不一定會指出錯誤條件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-286">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="b26ba-287">[雜物箱] 圖示有三種：藍色 (Iterator)、橙色 (資料指標) 與綠色 ( [!INCLUDE[tsql](../includes/tsql-md.md)] 語言項目)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-287">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language elements).</span></span>|  
|<span data-ttu-id="b26ba-288">None</span><span class="sxs-lookup"><span data-stu-id="b26ba-288">None</span></span>|<span data-ttu-id="b26ba-289">**資料指標**</span><span class="sxs-lookup"><span data-stu-id="b26ba-289">**Cursor**</span></span>|<span data-ttu-id="b26ba-290">「資料指標」邏輯與實體運算子可用來說明與資料指標作業有關的查詢或更新將如何執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-290">The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed.</span></span> <span data-ttu-id="b26ba-291">實體運算子是說明用來處理資料指標的實體實作演算法，例如使用索引鍵集衍生資料指標。</span><span class="sxs-lookup"><span data-stu-id="b26ba-291">The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor.</span></span> <span data-ttu-id="b26ba-292">資料指標執行的每個步驟都有一個實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-292">Each step in the execution of a cursor involves a physical operator.</span></span> <span data-ttu-id="b26ba-293">邏輯運算子會說明資料指標的屬性，如資料指標是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="b26ba-293">The logical operators describe a property of the cursor, such as the cursor is read only.</span></span><br /><br /> <span data-ttu-id="b26ba-294">邏輯運算子包括非同步、開放式、主要、唯讀、捲動鎖定及次要與同步。</span><span class="sxs-lookup"><span data-stu-id="b26ba-294">Logical operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, and Secondary and Synchronous.</span></span><br /><br /> <span data-ttu-id="b26ba-295">實體運算子包括動態、提取查詢、索引鍵集、母體擴展查詢、重新整理查詢與快照集。</span><span class="sxs-lookup"><span data-stu-id="b26ba-295">Physical operators include Dynamic, Fetch Query, Keyset, Population Query, Refresh Query and Snapshot.</span></span>|  
|<span data-ttu-id="b26ba-296">![宣告語言項目圖示](../../2014/database-engine/media/declare-32x.gif "宣告語言項目圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-296">![Declare language element icon](../../2014/database-engine/media/declare-32x.gif "Declare language element icon")</span></span>|`Declare`|<span data-ttu-id="b26ba-297">`Declare`運算子會在查詢計劃中配置區域變數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-297">The `Declare`  operator allocates a local variable in the query plan.</span></span> <span data-ttu-id="b26ba-298">`Declare` 是語言元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-298">`Declare` is a language element.</span></span>|  
|<span data-ttu-id="b26ba-299">![刪除 (資料庫引擎) 運算子圖示](../../2014/database-engine/media/delete-32x.gif "刪除 (資料庫引擎) 運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-299">![Delete (Database Engine) operator icon](../../2014/database-engine/media/delete-32x.gif "Delete (Database Engine) operator icon")</span></span>|`Delete`|<span data-ttu-id="b26ba-300">`Delete`運算子會從符合資料行中選擇性述詞的物件資料列中刪除 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-300">The `Delete` operator deletes from an object rows that satisfy the optional predicate in the `Argument` column.</span></span>|  
|<span data-ttu-id="b26ba-301">![刪除掃描運算子圖示](../../2014/database-engine/media/delete-scan-32x.gif "刪除掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-301">![Delete scan operator icon](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan operator icon")</span></span>|`Deleted Scan`|<span data-ttu-id="b26ba-302">`Deleted Scan` 運算子會掃描觸發程序中已刪除的資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-302">The `Deleted Scan` operator scans the deleted table within a trigger.</span></span>|  
|<span data-ttu-id="b26ba-303">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-303">None</span></span>|`Distinct`|<span data-ttu-id="b26ba-304">`Distinct` 運算子可從資料列集或從值集合移除重複的項目。</span><span class="sxs-lookup"><span data-stu-id="b26ba-304">The `Distinct` operator removes duplicates from a rowset or from a collection of values.</span></span> <span data-ttu-id="b26ba-305">`Distinct` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-305">`Distinct` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-306">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-306">None</span></span>|`Distinct Sort`|<span data-ttu-id="b26ba-307">`Distinct Sort`邏輯運算子會掃描輸入，移除重複項，並依 [相異排序依據] 中指定的資料行排序：資料行的 ( # A1 述詞 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-307">The `Distinct Sort` logical operator scans the input, removing duplicates and sorting by the columns specified in the DISTINCT ORDER BY:() predicate of the `Argument` column.</span></span> <span data-ttu-id="b26ba-308">`Distinct Sort` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-308">`Distinct Sort` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-309">![散發資料流平行處理原則運算子圖示](../../2014/database-engine/media/parallelism-distribute-stream.gif "散發資料流平行處理原則運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-309">![Distribute streams parallelism operator icon](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism operator icon")</span></span>|<span data-ttu-id="b26ba-310">**散發資料流**</span><span class="sxs-lookup"><span data-stu-id="b26ba-310">**Distribute Streams**</span></span>|<span data-ttu-id="b26ba-311">「散發資料流」運算子只用於平行查詢計畫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-311">The **Distribute Streams** operator is used only in parallel query plans.</span></span> <span data-ttu-id="b26ba-312">「散發資料流」運算子會採用記錄的單一輸入資料流，並產生多個輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="b26ba-312">The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams.</span></span> <span data-ttu-id="b26ba-313">記錄內容與格式不會變更。</span><span class="sxs-lookup"><span data-stu-id="b26ba-313">The record contents and format are not changed.</span></span> <span data-ttu-id="b26ba-314">輸入資料流中的每筆資料錄都會出現在一個輸出資料流中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-314">Each record from the input stream appears in one of the output streams.</span></span> <span data-ttu-id="b26ba-315">這個運算子會自動在輸出資料流中保留輸入資料錄的關聯次序。</span><span class="sxs-lookup"><span data-stu-id="b26ba-315">This operator automatically preserves the relative order of the input records in the output streams.</span></span> <span data-ttu-id="b26ba-316">通常是利用雜湊方式來決定特定輸入資料錄應屬於哪個輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="b26ba-316">Usually, hashing is used to decide to which output stream a particular input record belongs.</span></span><br /><br /> <span data-ttu-id="b26ba-317">如果輸出已分割，則資料 `Argument` 行包含資料分割資料行： ( # A1 述詞和分割資料行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-317">If the output is partitioned, then the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.</span></span> <span data-ttu-id="b26ba-318">「散發資料流」是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-318">**Distribute Streams** is a logical operator</span></span>|  
|<span data-ttu-id="b26ba-319">![動態資料指標運算子圖示](../../2014/database-engine/media/dynamic-32x.gif "動態資料指標運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-319">![Dynamic cursor operator icon](../../2014/database-engine/media/dynamic-32x.gif "Dynamic cursor operator icon")</span></span>|`Dynamic`|<span data-ttu-id="b26ba-320">`Dynamic` 運算子採用的資料指標，可以看到其他人進行的所有變更。</span><span class="sxs-lookup"><span data-stu-id="b26ba-320">The `Dynamic` operator uses a cursor that can see all changes made by others.</span></span>|  
|<span data-ttu-id="b26ba-321">![多工緩衝處理運算子圖示](../../2014/database-engine/media/spool-32x.gif "多工緩衝處理運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-321">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="b26ba-322">**急切的多工緩衝處理**</span><span class="sxs-lookup"><span data-stu-id="b26ba-322">**Eager Spool**</span></span>|<span data-ttu-id="b26ba-323">積極式多工**緩衝**處理運算子會採用整個輸入，並將每個資料列儲存在資料庫所儲存的隱藏暫存物件中 `tempdb` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-323">The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="b26ba-324">如果運算子是倒帶 (例如，由 `Nested Loops` 運算子) 但不需要重新系結，則會使用多工緩衝處理的資料，而非重新掃描輸入。</span><span class="sxs-lookup"><span data-stu-id="b26ba-324">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="b26ba-325">如果必須重新繫結的話，就丟棄多工緩衝處理的資料，然後重新掃描 (重新繫結) 輸入以重建多工緩衝處理物件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-325">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="b26ba-326">「急切的多工緩衝處理」運算子會以「急切的」方式建立多工緩衝處理檔案：當多工緩衝處理的父系運算子要求第一列時，「多工緩衝處理」運算子會消耗其輸入運算子的所有資料列，並將它們儲存在多工緩衝處理中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-326">The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.</span></span> <span data-ttu-id="b26ba-327">**急切的多工緩衝處理** 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-327">**Eager Spool** is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-328">![擷取查詢資料指標運算子圖示](../../2014/database-engine/media/fetch-query-32x.gif "擷取查詢資料指標運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-328">![Fetch query cursor operator icon](../../2014/database-engine/media/fetch-query-32x.gif "Fetch query cursor operator icon")</span></span>|`Fetch Query`|<span data-ttu-id="b26ba-329">`Fetch Query` 運算子會在對資料指標發出提取時擷取資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-329">The `Fetch Query` operator retrieves rows when a fetch is issued against a cursor.</span></span>|  
|<span data-ttu-id="b26ba-330">![篩選 (資料庫引擎) 運算子圖示](../../2014/database-engine/media/filter-32x.gif "篩選 (資料庫引擎) 運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-330">![Filter (Database Engine) operator icon](../../2014/database-engine/media/filter-32x.gif "Filter (Database Engine) operator icon")</span></span>|<span data-ttu-id="b26ba-331">**Filter**</span><span class="sxs-lookup"><span data-stu-id="b26ba-331">**Filter**</span></span>|<span data-ttu-id="b26ba-332">**篩選**運算子會掃描輸入，只傳回滿足篩選運算式的資料列， (出現在資料行中的述詞) `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-332">The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the `Argument` column.</span></span>|  
|<span data-ttu-id="b26ba-333">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-333">None</span></span>|`Flow Distinct`|<span data-ttu-id="b26ba-334">`Flow Distinct` 邏輯運算子會掃描輸入，移除重複的項目。</span><span class="sxs-lookup"><span data-stu-id="b26ba-334">The `Flow Distinct` logical operator scans the input, removing duplicates.</span></span> <span data-ttu-id="b26ba-335">運算子會在 `Distinct` 產生任何輸出之前耗用所有輸入，因此， **FlowDistinct**運算子會傳回從輸入 (取得的每個資料列，除非該資料列是重複的，在此情況下，它會被捨棄) 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-335">Whereas the `Distinct` operator consumes all input before producing any output, the **FlowDistinct** operator returns each row as it is obtained from the input (unless that row is a duplicate, in which case it is discarded).</span></span>|  
|<span data-ttu-id="b26ba-336">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-336">None</span></span>|`Full Outer Join`|<span data-ttu-id="b26ba-337">`Full Outer Join` 邏輯運算子所傳回的每個資料列，皆滿足第一個 (上方) 輸入的聯結述詞與第二個 (下方) 輸入的每一個資料列相聯結。</span><span class="sxs-lookup"><span data-stu-id="b26ba-337">The `Full Outer Join` logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input.</span></span> <span data-ttu-id="b26ba-338">它也會傳回以下資料列：</span><span class="sxs-lookup"><span data-stu-id="b26ba-338">It also returns rows from:</span></span><br /><br /> <span data-ttu-id="b26ba-339">\- 第一個輸入中與第二個輸入完全不符合者。</span><span class="sxs-lookup"><span data-stu-id="b26ba-339">-The first input that had no matches in the second input.</span></span><br /><br /> <span data-ttu-id="b26ba-340">\- 第二個輸入中與第一個輸入完全不符合者。</span><span class="sxs-lookup"><span data-stu-id="b26ba-340">-The second input that had no matches in the first input.</span></span><br /><br /> <br /><br /> <span data-ttu-id="b26ba-341">不包含相符值的輸入會以 Null 值傳回。</span><span class="sxs-lookup"><span data-stu-id="b26ba-341">The input that does not contain the matching values is returned as a null value.</span></span> <span data-ttu-id="b26ba-342">`Full Outer Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-342">`Full Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-343">![集中資料流平行處理原則運算子圖示](../../2014/database-engine/media/parallelism-32x.gif "集中資料流平行處理原則運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-343">![Gather streams parallelism operator icon](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism operator icon")</span></span>|<span data-ttu-id="b26ba-344">**蒐集資料流**</span><span class="sxs-lookup"><span data-stu-id="b26ba-344">**Gather Streams**</span></span>|<span data-ttu-id="b26ba-345">「蒐集資料流」運算子僅用於平行查詢計畫中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-345">The **Gather Streams** operator is only used in parallel query plans.</span></span> <span data-ttu-id="b26ba-346">「蒐集資料流」運算子會耗用數個輸入資料流，並將輸入資料流合併而產生記錄的單一輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="b26ba-346">The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams.</span></span> <span data-ttu-id="b26ba-347">記錄內容與格式不會變更。</span><span class="sxs-lookup"><span data-stu-id="b26ba-347">The record contents and format are not changed.</span></span> <span data-ttu-id="b26ba-348">若此運算子要保留順序，那麼所有輸入資料流都必須排序好。</span><span class="sxs-lookup"><span data-stu-id="b26ba-348">If this operator is order preserving, all input streams must be ordered.</span></span> <span data-ttu-id="b26ba-349">如果輸出經過排序，則資料 `Argument` 行包含 ORDER BY： ( # A1 述詞，以及要排序之資料行的名稱。</span><span class="sxs-lookup"><span data-stu-id="b26ba-349">If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the names of columns being ordered.</span></span> <span data-ttu-id="b26ba-350">**蒐集資料流** 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-350">**Gather Streams** is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-351">![雜湊比對運算子圖示](../../2014/database-engine/media/hash-match-32x.gif "雜湊比對運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-351">![Hash match operator icon](../../2014/database-engine/media/hash-match-32x.gif "Hash match operator icon")</span></span>|`Hash Match`|<span data-ttu-id="b26ba-352">`Hash Match` 運算子會根據其建立的輸入，為每一資料列計算雜湊值，以建立雜湊資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-352">The `Hash Match` operator builds a hash table by computing a hash value for each row from its build input.</span></span> <span data-ttu-id="b26ba-353">雜湊： ( # A1 述詞，以及用來建立雜湊值的資料行清單會出現在資料 `Argument` 行中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-353">A HASH:() predicate with a list of columns used to create a hash value appears in the `Argument` column.</span></span> <span data-ttu-id="b26ba-354">然後它會為每個探查列 (視情況) 建立雜湊值 (使用相同的雜湊函數)，並在雜湊資料表中尋找符合者。</span><span class="sxs-lookup"><span data-stu-id="b26ba-354">Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches.</span></span> <span data-ttu-id="b26ba-355">如果有剩餘的述詞 (在資料行) 中 ( # A2 識別 `Argument` ，則也必須滿足該述詞，資料列才會被視為相符。</span><span class="sxs-lookup"><span data-stu-id="b26ba-355">If a residual predicate is present (identified by RESIDUAL:() in the `Argument` column), that predicate must also be satisfied for rows to be considered a match.</span></span> <span data-ttu-id="b26ba-356">行為取決於正在執行的邏輯作業：</span><span class="sxs-lookup"><span data-stu-id="b26ba-356">Behavior depends on the logical operation being performed:</span></span><br /><br /> <span data-ttu-id="b26ba-357">對於任何聯結，使用第一個 (上方) 輸入來建立雜湊資料表，第二個輸入 (下方) 來探查雜湊資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-357">For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table.</span></span> <span data-ttu-id="b26ba-358">輸出相符 (或不符合) 由聯結類型規定。</span><span class="sxs-lookup"><span data-stu-id="b26ba-358">Output matches (or nonmatches) as dictated by the join type.</span></span> <span data-ttu-id="b26ba-359">如果多個聯結使用相同的聯結行，這些作業會組成一組成為雜湊群。</span><span class="sxs-lookup"><span data-stu-id="b26ba-359">If multiple joins use the same join column, these operations are grouped into a hash team.</span></span><br /><br /> <span data-ttu-id="b26ba-360">對於相異運算子或彙總運算子，使用輸入來建立雜湊資料表 (移除重複項，並計算任何彙總運算式)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-360">For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions).</span></span> <span data-ttu-id="b26ba-361">建立雜湊資料表時，會掃描資料表並輸出所有項目。</span><span class="sxs-lookup"><span data-stu-id="b26ba-361">When the hash table is built, scan the table and output all entries.</span></span><br /><br /> <span data-ttu-id="b26ba-362">對於等位運算子，使用第一個輸入來建立雜湊資料表 (移除重複項)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-362">For the union operator, use the first input to build the hash table (removing duplicates).</span></span> <span data-ttu-id="b26ba-363">使用第二個輸入 (必須沒有重複項) 探查雜湊資料表，傳回不符合的所有資料列，然後掃描雜湊資料表，並傳回所有項目。</span><span class="sxs-lookup"><span data-stu-id="b26ba-363">Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.</span></span><br /><br /> <br /><br /> <span data-ttu-id="b26ba-364">`Hash Match` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-364">`Hash Match` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-365">![If 語言項目圖示](../../2014/database-engine/media/if-32x.gif "If 語言項目圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-365">![If language element icon](../../2014/database-engine/media/if-32x.gif "If language element icon")</span></span>|`If`|<span data-ttu-id="b26ba-366">`If` 運算子會依據運算式執行條件式處理。</span><span class="sxs-lookup"><span data-stu-id="b26ba-366">The `If` operator carries out conditional processing based on an expression.</span></span> <span data-ttu-id="b26ba-367">`If` 是語言元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-367">`If` is a language element.</span></span>|  
|<span data-ttu-id="b26ba-368">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-368">None</span></span>|`Inner Join`|<span data-ttu-id="b26ba-369">`Inner Join` 邏輯運算子所傳回的每個資料列，皆滿足第一個 (上方) 輸入與第二個 (下方) 輸入的聯結。</span><span class="sxs-lookup"><span data-stu-id="b26ba-369">The `Inner Join` logical operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span>|  
|<span data-ttu-id="b26ba-370">![插入 (資料庫引擎) 運算子圖示](../../2014/database-engine/media/insert-32x.gif "插入 (資料庫引擎) 運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-370">![Insert (Database Engine) operator icon](../../2014/database-engine/media/insert-32x.gif "Insert (Database Engine) operator icon")</span></span>|`Insert`|<span data-ttu-id="b26ba-371">`Insert`邏輯運算子會將其輸入中的每個資料列插入至資料行中指定的物件 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-371">The `Insert` logical operator inserts each row from its input into the object specified in the `Argument` column.</span></span> <span data-ttu-id="b26ba-372">實體運算子是 `Table Insert`、`Index Insert` 或 `Clustered Index Insert` 運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-372">The physical operator is either the `Table Insert`, `Index Insert`, or `Clustered Index Insert` operator.</span></span>|  
|<span data-ttu-id="b26ba-373">![插入的掃描運算子圖示](../../2014/database-engine/media/inserted-scan-32x.gif "插入的掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-373">![Inserted scan operator icon](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan operator icon")</span></span>|<span data-ttu-id="b26ba-374">**插入的掃描**</span><span class="sxs-lookup"><span data-stu-id="b26ba-374">**Inserted Scan**</span></span>|<span data-ttu-id="b26ba-375">「插入的掃描」運算子會掃描 **inserted** 資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-375">The **Inserted Scan** operator scans the **inserted** table.</span></span> <span data-ttu-id="b26ba-376">「插入的掃描」是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-376">**Inserted Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-377">![內建語言項目圖示](../../2014/database-engine/media/intrinsic-32x.gif "內建語言項目圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-377">![Intrinsic language element icon](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic language element icon")</span></span>|`Intrinsic`|<span data-ttu-id="b26ba-378">`Intrinsic` 運算子會叫用內部 [!INCLUDE[tsql](../includes/tsql-md.md)] 函數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-378">The `Intrinsic` operator invokes an internal [!INCLUDE[tsql](../includes/tsql-md.md)] function.</span></span> <span data-ttu-id="b26ba-379">`Intrinsic` 是語言元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-379">`Intrinsic` is a language element.</span></span>|  
|<span data-ttu-id="b26ba-380">![迭代器 catchall 運算子圖示](../../2014/database-engine/media/iterator-catch-all.gif "迭代器 catchall 運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-380">![Iterator catchall operator icon](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall operator icon")</span></span>|`Iterator`|<span data-ttu-id="b26ba-381">產生圖形執行程序表的邏輯若找不到適當的 Iterator 圖示，就會顯示 `Iterator` 雜物箱圖示。</span><span class="sxs-lookup"><span data-stu-id="b26ba-381">The `Iterator` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="b26ba-382">[雜物箱] 圖示不一定會指出錯誤條件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-382">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="b26ba-383">[雜物箱] 圖示有三種：藍色 (Iterator)、橙色 (資料指標) 與綠色 ( [!INCLUDE[tsql](../includes/tsql-md.md)] 語言建構)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-383">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="b26ba-384">![書籤查閱運算子圖示](../../2014/database-engine/media/bookmark-lookup-32x.gif "書籤查閱運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-384">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Key Lookup`|<span data-ttu-id="b26ba-385">`Key Lookup`運算子是具有叢集索引之資料表上的書簽查閱。</span><span class="sxs-lookup"><span data-stu-id="b26ba-385">The `Key Lookup` operator is a bookmark lookup on a table with a clustered index.</span></span> <span data-ttu-id="b26ba-386">資料 `Argument` 行包含叢集索引的名稱，以及用來查閱叢集索引中之資料列的叢集索引鍵。</span><span class="sxs-lookup"><span data-stu-id="b26ba-386">The `Argument` column contains the name of the clustered index and the clustering key used to look up the row in the clustered index.</span></span> <span data-ttu-id="b26ba-387">`Key Lookup`一律會伴隨一個 `Nested Loops` 運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-387">`Key Lookup` is always accompanied by a `Nested Loops` operator.</span></span> <span data-ttu-id="b26ba-388">如果資料行中出現 WITH 預先提取子句 `Argument` ，表示查詢處理器已決定在叢集索引中查閱書簽時，使用非同步預先提取 (預先讀取) 的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="b26ba-388">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.</span></span><br /><br /> <span data-ttu-id="b26ba-389">在 `Key Lookup` 查詢計劃中使用運算子，表示查詢可能受益于效能調整。</span><span class="sxs-lookup"><span data-stu-id="b26ba-389">The use of a `Key Lookup` operator in a query plan indicates that the query might benefit from performance tuning.</span></span> <span data-ttu-id="b26ba-390">例如，您可以加入涵蓋索引來提高查詢效能。</span><span class="sxs-lookup"><span data-stu-id="b26ba-390">For example, query performance might be improved by adding a covering index.</span></span>|  
|<span data-ttu-id="b26ba-391">![索引鍵集資料指標運算子圖示](../../2014/database-engine/media/keyset-32x.gif "索引鍵集資料指標運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-391">![Keyset cursor operator icon](../../2014/database-engine/media/keyset-32x.gif "Keyset cursor operator icon")</span></span>|`Keyset`|<span data-ttu-id="b26ba-392">`Keyset` 運算子使用可以查看更新，但無法插入其他人所製作的資料指標。</span><span class="sxs-lookup"><span data-stu-id="b26ba-392">The `Keyset` operator uses a cursor that can see updates, but not inserts made by others.</span></span>|  
|<span data-ttu-id="b26ba-393">![語言項目 catchall 圖示](../../2014/database-engine/media/language-construct-catch-all.gif "語言項目 catchall 圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-393">![Language element catchall icon](../../2014/database-engine/media/language-construct-catch-all.gif "Language element catchall icon")</span></span>|`Language Element`|<span data-ttu-id="b26ba-394">產生圖形執行程序表的邏輯若找不到適當的 Iterator 圖示，就會顯示 `Language Element` 雜物箱圖示。</span><span class="sxs-lookup"><span data-stu-id="b26ba-394">The `Language Element` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="b26ba-395">[雜物箱] 圖示不一定會指出錯誤條件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-395">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="b26ba-396">[雜物箱] 圖示有三種：藍色 (Iterator)、橙色 (資料指標) 與綠色 ( [!INCLUDE[tsql](../includes/tsql-md.md)] 語言建構)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-396">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="b26ba-397">![多工緩衝處理運算子圖示](../../2014/database-engine/media/spool-32x.gif "多工緩衝處理運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-397">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="b26ba-398">**延遲多工緩衝處理**</span><span class="sxs-lookup"><span data-stu-id="b26ba-398">**Lazy Spool**</span></span>|<span data-ttu-id="b26ba-399">「**延遲**多工緩衝處理」邏輯運算子會將其輸入中的每個資料列，儲存在資料庫中儲存的隱藏暫存物件中 `tempdb` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-399">The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="b26ba-400">如果運算子是倒帶 (例如，由 `Nested Loops` 運算子) 但不需要重新系結，則會使用多工緩衝處理的資料，而非重新掃描輸入。</span><span class="sxs-lookup"><span data-stu-id="b26ba-400">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="b26ba-401">如果必須重新繫結的話，就丟棄多工緩衝處理的資料，然後重新掃描 (重新繫結) 輸入以重建多工緩衝處理物件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-401">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="b26ba-402">「延遲多工緩衝處理」運算子會以「延遲」方式建立它的多工緩衝處理檔案，也就是說，每次多工緩衝處理的父系運算子要求一個資料列時，多工緩衝處理運算子就會從它的輸入運算子取得一個資料列，然後將它儲存在多工緩衝處理內，而不是一次取用所有資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-402">The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.</span></span> <span data-ttu-id="b26ba-403">Lazy Spool 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-403">Lazy Spool is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-404">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-404">None</span></span>|`Left Anti Semi Join`|<span data-ttu-id="b26ba-405">當第二個 (下方) 輸入中沒有相符的資料列時，`Left Anti Semi Join` 運算子將會從第一個 (上方) 輸入傳回每一個資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-405">The `Left Anti Semi Join` operator returns each row from the first (top) input when there is no matching row in the second (bottom) input.</span></span> <span data-ttu-id="b26ba-406">如果資料行中沒有聯結述詞 `Argument` ，則每個資料列都是相符的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-406">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="b26ba-407">`Left Anti Semi Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-407">`Left Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-408">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-408">None</span></span>|`Left Outer Join`|<span data-ttu-id="b26ba-409">`Left Outer Join` 運算子所傳回的每個資料列，皆滿足第一個 (上方) 輸入與第二個 (下方) 輸入的聯結。</span><span class="sxs-lookup"><span data-stu-id="b26ba-409">The `Left Outer Join` operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span> <span data-ttu-id="b26ba-410">它也會傳回第一個輸入中與第二個輸入完全不相符的任何資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-410">It also returns any rows from the first input that had no matching rows in the second input.</span></span> <span data-ttu-id="b26ba-411">第二個輸入中的不符合資料列會以 null 值傳回。</span><span class="sxs-lookup"><span data-stu-id="b26ba-411">The nonmatching rows in the second input are returned as null values.</span></span> <span data-ttu-id="b26ba-412">如果資料行中沒有聯結述詞 `Argument` ，則每個資料列都是相符的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-412">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="b26ba-413">`Left Outer Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-413">`Left Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-414">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-414">None</span></span>|`Left Semi Join`|<span data-ttu-id="b26ba-415">當第二個 (下方) 輸入中有相符的資料列時，`Left Semi Join` 運算子將會從第一個 (上方) 輸入傳回每一個資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-415">The `Left Semi Join` operator returns each row from the first (top) input when there is a matching row in the second (bottom) input.</span></span> <span data-ttu-id="b26ba-416">如果資料行中沒有聯結述詞 `Argument` ，則每個資料列都是相符的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-416">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="b26ba-417">`Left Semi Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-417">`Left Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-418">![記錄資料列掃描運算子圖示](../../2014/database-engine/media/log-row-scan-32x.gif "記錄資料列掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-418">![Log row scan operator icon](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan operator icon")</span></span>|`Log Row Scan`|<span data-ttu-id="b26ba-419">`Log Row Scan` 運算子會掃描交易記錄。</span><span class="sxs-lookup"><span data-stu-id="b26ba-419">The `Log Row Scan` operator scans the transaction log.</span></span> <span data-ttu-id="b26ba-420">`Log Row Scan` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-420">`Log Row Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-421">![合併間隔運算子圖示](../../2014/database-engine/media/merge-interval-32x.gif "合併間隔運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-421">![Merge interval operator icon](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval operator icon")</span></span>|`Merge Interval`|<span data-ttu-id="b26ba-422">`Merge Interval` 運算子會合併多個 (可能重疊) 間隔以產生最小的非重疊間隔，然後使用這些間隔，尋找索引項目。</span><span class="sxs-lookup"><span data-stu-id="b26ba-422">The `Merge Interval` operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries.</span></span> <span data-ttu-id="b26ba-423">這個運算子通常會出現在一或多個運算子上方，而不是由運算子組成，這會在 `Compute Scalar` `Constant Scan` 此運算子合併的資料列) 中，以資料行的形式 (表示的間隔</span><span class="sxs-lookup"><span data-stu-id="b26ba-423">This operator typically appears above one or more `Compute Scalar` operators over `Constant Scan` operators, which construct the intervals (represented as columns in a row) that this operator merges.</span></span> <span data-ttu-id="b26ba-424">`Merge Interval` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-424">`Merge Interval` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-425">![合併聯結運算子圖示](../../2014/database-engine/media/merge-join-32x.gif "合併聯結運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-425">![Merge join operator icon](../../2014/database-engine/media/merge-join-32x.gif "Merge join operator icon")</span></span>|<span data-ttu-id="b26ba-426">**合併聯結**</span><span class="sxs-lookup"><span data-stu-id="b26ba-426">**Merge Join**</span></span>|<span data-ttu-id="b26ba-427">「合併聯結」運算子會執行內部聯結、左方外部聯結、左方半聯結、左方反半聯結、右方外部聯結、右方半聯結、右方反半聯結，以及等位邏輯作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-427">The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.</span></span><br /><br /> <span data-ttu-id="b26ba-428">在資料 `Argument` 行中， **merge Join**運算子包含 merge： ( # A1 述詞（如果作業正在執行一對多聯結）或多對多合併：如果作業正在執行多對多聯結，則為 ( # A3 述詞。</span><span class="sxs-lookup"><span data-stu-id="b26ba-428">In the `Argument` column, the **Merge Join** operator contains a MERGE:() predicate if the operation is performing a one-to-many join, or a MANY-TO-MANY MERGE:() predicate if the operation is performing a many-to-many join.</span></span> <span data-ttu-id="b26ba-429">此資料 `Argument` 行也包含用來執行作業的資料行清單（以逗號分隔）。</span><span class="sxs-lookup"><span data-stu-id="b26ba-429">The `Argument` column also includes a comma-separated list of columns used to perform the operation.</span></span> <span data-ttu-id="b26ba-430">「合併聯結」運算子需要兩個輸入，依個別資料行排序，可能是利用在查詢計畫中明確地插入排序作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-430">The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan.</span></span> <span data-ttu-id="b26ba-431">如果不需要明確的排序，合併聯結會特別有效；例如，如果資料庫中有合適的 B 型樹狀目錄索引，或如果排序次序可以由多個作業利用 (如合併聯結與含積存的分組功能)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-431">Merge join is particularly effective if explicit sorting is not required, for example, if there is a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with roll up.</span></span> <span data-ttu-id="b26ba-432">「合併聯結」是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-432">**Merge Join** is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-433">![巢狀迴圈運算子圖示](../../2014/database-engine/media/nested-loops-32x.gif "巢狀迴圈運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-433">![Nested loops operator icon](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops operator icon")</span></span>|`Nested Loops`|<span data-ttu-id="b26ba-434">`Nested Loops` 運算子執行內部聯結、左方外部聯結、左方半聯結和左方反半聯結邏輯運算。</span><span class="sxs-lookup"><span data-stu-id="b26ba-434">The `Nested Loops` operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.</span></span> <span data-ttu-id="b26ba-435">巢狀迴圈聯結通常會使用索引，在內部資料表中搜尋外部資料表的每個資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-435">Nested loops joins perform a search on the inner table for each row of the outer table, typically using an index.</span></span> <span data-ttu-id="b26ba-436">查詢處理器會根據預期的成本，決定是否要排序外部輸入，以改進對內部輸入的索引搜尋位置。</span><span class="sxs-lookup"><span data-stu-id="b26ba-436">The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input.</span></span> <span data-ttu-id="b26ba-437">在資料行中滿足 (選擇性) 述詞的任何資料 `Argument` 列，會根據所執行的邏輯作業傳回為適用。</span><span class="sxs-lookup"><span data-stu-id="b26ba-437">Any rows that satisfy the (optional) predicate in the `Argument` column are returned as applicable, based on the logical operation being performed.</span></span> <span data-ttu-id="b26ba-438">`Nested Loops` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-438">`Nested Loops` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-439">![非叢集索引刪除運算子圖示](../../2014/database-engine/media/nonclust-index-delete-32x.gif "非叢集索引刪除運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-439">![Nonclustered index delete operator icon](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered index delete operator icon")</span></span>|`Nonclustered Index Delete`|<span data-ttu-id="b26ba-440">`Nonclustered Index Delete`運算子會從資料行中指定的非叢集索引刪除輸入資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-440">The `Nonclustered Index Delete` operator deletes input rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="b26ba-441">`Nonclustered Index Delete` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-441">`Nonclustered Index Delete` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-442">![非叢集索引插入運算子圖示](../../2014/database-engine/media/nonclust-index-insert-32x.gif "非叢集索引插入運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-442">![Nonclustered index insert operator icon](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered index insert operator icon")</span></span>|`Index Insert`|<span data-ttu-id="b26ba-443">運算子會將 `Index Insert` 其輸入的資料列插入資料行中指定的非叢集索引 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-443">The `Index Insert` operator inserts rows from its input into the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="b26ba-444">`Argument` 資料行也包含 SET:() 述詞，指出每一個資料行設定的值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-444">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="b26ba-445">`Index Insert` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-445">`Index Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-446">![非叢集索引掃描運算子圖示](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "非叢集索引掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-446">![Nonclustered index scan operator icon](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan operator icon")</span></span>|`Index Scan`|<span data-ttu-id="b26ba-447">`Index Scan`運算子會從資料行中指定的非叢集索引抓取所有的資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-447">The `Index Scan` operator retrieves all rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="b26ba-448">如果選擇性的 WHERE： ( # A1 述詞出現在資料 `Argument` 行中，則只會傳回滿足述詞的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-448">If an optional WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="b26ba-449">`Index Scan` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-449">`Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-450">![非叢集索引搜尋運算子圖示](../../2014/database-engine/media/index-seek-32x.gif "非叢集索引搜尋運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-450">![Nonclustered index seek operator icon](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek operator icon")</span></span>|`Index Seek`|<span data-ttu-id="b26ba-451">`Index Seek` 運算子使用索引的搜尋能力，從非叢集索引中擷取資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-451">The `Index Seek` operator uses the seeking ability of indexes to retrieve rows from a nonclustered index.</span></span> <span data-ttu-id="b26ba-452">資料 `Argument` 行包含所使用之非叢集索引的名稱。</span><span class="sxs-lookup"><span data-stu-id="b26ba-452">The `Argument` column contains the name of the nonclustered index being used.</span></span> <span data-ttu-id="b26ba-453">它也包含 SEEK:() 述詞。</span><span class="sxs-lookup"><span data-stu-id="b26ba-453">It also contains the SEEK:() predicate.</span></span> <span data-ttu-id="b26ba-454">儲存引擎會使用索引來處理滿足 SEEK:() 述詞的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-454">The storage engine uses the index to process only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="b26ba-455">它可以選擇包含 WHERE:() 述詞，讓儲存引擎比對所有滿足 SEEK:() 述詞的資料列 (這麼做時不使用索引)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-455">It optionally may include a WHERE:() predicate, which the storage engine will evaluate against all rows that satisfy the SEEK:() predicate (it does not use the indexes to do this).</span></span> <span data-ttu-id="b26ba-456">如果資料 `Argument` 行包含已排序的子句，則查詢處理器已判定資料列必須依照非叢集索引的排序次序傳回。</span><span class="sxs-lookup"><span data-stu-id="b26ba-456">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them.</span></span> <span data-ttu-id="b26ba-457">如果沒有 ORDERED 子句，儲存引擎會以最適當的方式搜尋索引 (不保證輸出會依序排列)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-457">If the ORDERED clause is not present, the storage engine searches the index in the optimal way (which does not guarantee that the output will be sorted).</span></span> <span data-ttu-id="b26ba-458">讓輸出維持次序會比產生不按次序的輸出還要沒有效率。</span><span class="sxs-lookup"><span data-stu-id="b26ba-458">Allowing the output to retain its ordering may be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="b26ba-459">`Index Seek` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-459">`Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-460">![非叢集索引多工緩衝處理運算子圖示](../../2014/database-engine/media/index-spool-32x.gif "非叢集索引多工緩衝處理運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-460">![Nonclustered index spool operator icon](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool operator icon")</span></span>|<span data-ttu-id="b26ba-461">**索引多工緩衝處理**</span><span class="sxs-lookup"><span data-stu-id="b26ba-461">**Index Spool**</span></span>|<span data-ttu-id="b26ba-462">「**索引**多工緩衝處理」實體運算子在資料行中包含 SEEK： ( # A1 述詞 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-462">The **Index Spool** physical operator contains a SEEK:() predicate in the `Argument` column.</span></span> <span data-ttu-id="b26ba-463">「**索引**多工緩衝處理」運算子會掃描其輸入資料列，並將每個資料列的複本放入隱藏的多工緩衝處理檔案中 (儲存在資料庫中， `tempdb` 而且只會在查詢) 的存留期間內建立非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="b26ba-463">The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the `tempdb` database and existing only for the lifetime of the query), and builds a nonclustered index on the rows.</span></span> <span data-ttu-id="b26ba-464">這讓您可以使用索引的搜尋能力來輸出滿足 SEEK:() 述詞的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-464">This allows you to use the seeking capability of indexes to output only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="b26ba-465">如果運算子是倒帶 (例如，由 `Nested Loops` 運算子) 但不需要重新系結，則會使用多工緩衝處理的資料，而非重新掃描輸入。</span><span class="sxs-lookup"><span data-stu-id="b26ba-465">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span>|  
|<span data-ttu-id="b26ba-466">![非叢集索引更新運算子圖示](../../2014/database-engine/media/nonclust-index-update-32x.gif "非叢集索引更新運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-466">![Nonclustered index update operator icon](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update operator icon")</span></span>|`Nonclustered Index Update`|<span data-ttu-id="b26ba-467">`Nonclustered Index Update`實體運算子會從資料行中指定的非叢集索引中的輸入更新資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-467">The `Nonclustered Index Update` physical operator updates rows from its input in the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="b26ba-468">如果出現 SET:() 述詞，則每個更新的資料行都會設為這個值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-468">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="b26ba-469">`Nonclustered Index Update` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-469">`Nonclustered Index Update` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-470">![線上索引插入運算子圖示](../../2014/database-engine/media/online-index-32x.gif "線上索引插入運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-470">![Online index insert operator icon](../../2014/database-engine/media/online-index-32x.gif "Online index insert operator icon")</span></span>|<span data-ttu-id="b26ba-471">**線上索引插入**</span><span class="sxs-lookup"><span data-stu-id="b26ba-471">**Online Index Insert**</span></span>|<span data-ttu-id="b26ba-472">「線上索引插入」實體運算子指出索引之建立、改變或卸除作業將於線上進行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-472">The **Online Index Insert** physical operator indicates that an index create, alter, or drop operation is performed online.</span></span> <span data-ttu-id="b26ba-473">也就是說，基礎資料表資料在索引操作期間仍然可供使用者使用。</span><span class="sxs-lookup"><span data-stu-id="b26ba-473">That is, the underlying table data remains available to users during the index operation.</span></span>|  
|<span data-ttu-id="b26ba-474">None</span><span class="sxs-lookup"><span data-stu-id="b26ba-474">None</span></span>|`Parallelism`|<span data-ttu-id="b26ba-475">`Parallelism`運算子會執行散發資料流程、搜集資料流程，以及重新分割資料流程的邏輯作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-475">The `Parallelism` operator performs the distribute streams, gather streams, and repartition streams logical operations.</span></span> <span data-ttu-id="b26ba-476">這些資料 `Argument` 行可以包含分割區資料行： ( # A1 述詞，以及要分割的資料行清單（以逗號分隔）。</span><span class="sxs-lookup"><span data-stu-id="b26ba-476">The `Argument` columns can contain a PARTITION COLUMNS:() predicate with a comma-separated list of the columns being partitioned.</span></span> <span data-ttu-id="b26ba-477">這些資料 `Argument` 行也可以包含 ORDER BY： ( # A1 述詞，列出資料分割期間要保留排序次序的資料行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-477">The `Argument` columns can also contain an ORDER BY:() predicate, listing the columns to preserve the sort order for during partitioning.</span></span> <span data-ttu-id="b26ba-478">`Parallelism` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-478">`Parallelism` is a physical operator.</span></span><br /><br /> <span data-ttu-id="b26ba-479">注意：如果查詢已經編譯為平行查詢，但在執行時間是以序列查詢的形式執行，則 SET STATISTICS XML 或使用中的 [ **Include 實際執行計畫**] 選項所產生的執行程式表輸出 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] 將不會包含 `RunTimeInformation` 運算子的元素 `Parallelism` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-479">Note: If a query has been compiled as a parallel query, but at run time it is run as a serial query, the Showplan output generated by SET STATISTICS XML or by using the **Include Actual Execution Plan** option in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] will not contain the `RunTimeInformation` element for the `Parallelism` operator.</span></span> <span data-ttu-id="b26ba-480">在 [設定統計資料設定檔輸出] 中，運算子的實際資料列計數和實際執行次數會顯示零 `Parallelism` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-480">In SET STATISTICS PROFILE output, the actual row counts and actual number of executes will display zeroes for the `Parallelism` operator.</span></span> <span data-ttu-id="b26ba-481">發生任一種狀況時，這表示 `Parallelism` 運算子只會在查詢編譯期間使用，而不是在執行時間查詢計劃中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-481">When either condition occurs, it means that the `Parallelism` operator was only used during query compilation and not in the run-time query plan.</span></span> <span data-ttu-id="b26ba-482">請注意，如果伺服器上有大量的並行載入，平行查詢計畫有時會以序列方式執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-482">Note that sometimes parallel query plans are run in serial if there is a high concurrent load on the server.</span></span>|  
|<span data-ttu-id="b26ba-483">![參數資料表掃描運算子圖示](../../2014/database-engine/media/parameter-table-scan-32x.gif "參數資料表掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-483">![Parameter table scan operator icon](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan operator icon")</span></span>|`Parameter Table Scan`|<span data-ttu-id="b26ba-484">`Parameter Table Scan` 運算子會掃描在目前的查詢中當做參數使用的資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-484">The `Parameter Table Scan` operator scans a table that is acting as a parameter in the current query.</span></span> <span data-ttu-id="b26ba-485">一般而言，這是用於預存程序中的 INSERT 查詢。</span><span class="sxs-lookup"><span data-stu-id="b26ba-485">Typically, this is used for INSERT queries within a stored procedure.</span></span> <span data-ttu-id="b26ba-486">`Parameter Table Scan` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-486">`Parameter Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-487">None</span><span class="sxs-lookup"><span data-stu-id="b26ba-487">None</span></span>|<span data-ttu-id="b26ba-488">**部分彙總**</span><span class="sxs-lookup"><span data-stu-id="b26ba-488">**Partial Aggregate**</span></span>|<span data-ttu-id="b26ba-489">「部分彙總」用於平行計畫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-489">**Partial Aggregate** is used in parallel plans.</span></span> <span data-ttu-id="b26ba-490">它將彙總函式套用至盡可能最多的輸入資料列，因此不需要寫入磁碟 (稱為「溢出」)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-490">It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") is not necessary.</span></span> <span data-ttu-id="b26ba-491">`Hash Match`這是執行分割區匯總 (反覆運算器) 唯一的實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-491">`Hash Match` is the only physical operator (iterator) that implements partition aggregation.</span></span> <span data-ttu-id="b26ba-492">**部分彙總** 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-492">**Partial Aggregate** is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-493">![母體擴展查詢資料指標運算子圖示](../../2014/database-engine/media/poulation-query-32x.gif "母體擴展查詢資料指標運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-493">![Population query cursor operator icon](../../2014/database-engine/media/poulation-query-32x.gif "Population query cursor operator icon")</span></span>|`Population Query`|<span data-ttu-id="b26ba-494">`Population Query` 運算子會在開啟資料指標時，擴展資料指標的工作資料表。</span><span class="sxs-lookup"><span data-stu-id="b26ba-494">The `Population Query` operator populates the work table of a cursor when the cursor is opened.</span></span>|  
|<span data-ttu-id="b26ba-495">![重新整理查詢資料指標運算子圖示](../../2014/database-engine/media/refresh-query-32x.gif "重新整理查詢資料指標運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-495">![Refresh query cursor operator icon](../../2014/database-engine/media/refresh-query-32x.gif "Refresh query cursor operator icon")</span></span>|`Refresh Query`|<span data-ttu-id="b26ba-496">`Refresh Query` 運算子會在提取緩衝區中提取資料列目前的資料。</span><span class="sxs-lookup"><span data-stu-id="b26ba-496">The `Refresh Query` operator fetches current data for rows in the fetch buffer.</span></span>|  
|<span data-ttu-id="b26ba-497">![遠端刪除運算子圖示](../../2014/database-engine/media/remote-delete-32x.gif "遠端刪除運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-497">![Remote delete operator icon](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete operator icon")</span></span>|`Remote Delete`|<span data-ttu-id="b26ba-498">`Remote Delete` 運算子會刪除遠端物件的輸入資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-498">The `Remote Delete` operator deletes the input rows from a remote object.</span></span> <span data-ttu-id="b26ba-499">`Remote Delete` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-499">`Remote Delete` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-500">![遠端索引搜尋執行程式表運算子](../../2014/database-engine/media/remote-index-scan-32x.gif "遠端索引搜尋執行程序表運算子")</span><span class="sxs-lookup"><span data-stu-id="b26ba-500">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="b26ba-501">**遠端索引掃描**</span><span class="sxs-lookup"><span data-stu-id="b26ba-501">**Remote Index Scan**</span></span>|<span data-ttu-id="b26ba-502">「遠端索引掃描」運算子會掃描 Argument 資料行中所指定的遠端索引。</span><span class="sxs-lookup"><span data-stu-id="b26ba-502">The **Remote Index Scan** operator scans the remote index specified in the Argument column.</span></span> <span data-ttu-id="b26ba-503">「遠端索引掃描」是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-503">**Remote Index Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-504">![遠端索引搜尋執行程式表運算子](../../2014/database-engine/media/remote-index-seek-32x.gif "遠端索引搜尋執行程序表運算子")</span><span class="sxs-lookup"><span data-stu-id="b26ba-504">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="b26ba-505">**遠端索引搜尋**</span><span class="sxs-lookup"><span data-stu-id="b26ba-505">**Remote Index Seek**</span></span>|<span data-ttu-id="b26ba-506">「遠端索引搜尋」運算子會使用遠端索引物件的搜尋功能來擷取資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-506">The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows.</span></span> <span data-ttu-id="b26ba-507">資料 `Argument` 行包含所使用的遠端索引名稱及 SEEK： ( # A1 述詞。</span><span class="sxs-lookup"><span data-stu-id="b26ba-507">The `Argument` column contains the name of the remote index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="b26ba-508">「遠端索引搜尋」是邏輯實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-508">**Remote Index Seek** is a logical physical operator.</span></span>|  
|<span data-ttu-id="b26ba-509">![遠端插入運算子圖示](../../2014/database-engine/media/remote-insert-32x.gif "遠端插入運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-509">![Remote insert operator icon](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert operator icon")</span></span>|<span data-ttu-id="b26ba-510">**遠端插入**</span><span class="sxs-lookup"><span data-stu-id="b26ba-510">**Remote Insert**</span></span>|<span data-ttu-id="b26ba-511">「遠端插入」運算子會將輸入資料列插入遠端物件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-511">The **Remote Insert** operator inserts the input rows into a remote object.</span></span> <span data-ttu-id="b26ba-512">「遠端插入」是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-512">**Remote Insert** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-513">![遠端查詢運算子圖示](../../2014/database-engine/media/remote-query-32x.gif "遠端查詢運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-513">![Remote query operator icon](../../2014/database-engine/media/remote-query-32x.gif "Remote query operator icon")</span></span>|`Remote Query`|<span data-ttu-id="b26ba-514">`Remote Query` 運算子會對遠端來源送出查詢。</span><span class="sxs-lookup"><span data-stu-id="b26ba-514">The `Remote Query` operator submits a query to a remote source.</span></span> <span data-ttu-id="b26ba-515">傳送到遠端伺服器的查詢文字會出現在資料行中 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-515">The text of the query sent to the remote server appears in the `Argument` column.</span></span> <span data-ttu-id="b26ba-516">`Remote Query` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-516">`Remote Query` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-517">![遠端掃描運算子圖示](../../2014/database-engine/media/remote-scan-32x.gif "遠端掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-517">![Remote scan operator icon](../../2014/database-engine/media/remote-scan-32x.gif "Remote scan operator icon")</span></span>|`Remote Scan`|<span data-ttu-id="b26ba-518">`Remote Scan` 運算子會掃描遠端物件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-518">The `Remote Scan` operator scans a remote object.</span></span> <span data-ttu-id="b26ba-519">遠端物件的名稱會出現在資料 `Argument` 行中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-519">The name of the remote object appears in the `Argument` column.</span></span> <span data-ttu-id="b26ba-520">`Remote Scan` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-520">`Remote Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-521">![遠端更新運算子圖示](../../2014/database-engine/media/remote-update-32x.gif "遠端更新運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-521">![Remote update operator icon](../../2014/database-engine/media/remote-update-32x.gif "Remote update operator icon")</span></span>|`Remote Update`|<span data-ttu-id="b26ba-522">`Remote Update` 運算子會更新遠端物件中的輸入資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-522">The `Remote Update` operator updates the input rows in a remote object.</span></span> <span data-ttu-id="b26ba-523">`Remote Update` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-523">`Remote Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-524">![重新分割資料流平行處理原則運算子圖示](../../2014/database-engine/media/parallelism-repartition-stream.gif "重新分割資料流平行處理原則運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-524">![Repartition streams parallelism operator icon](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism operator icon")</span></span>|<span data-ttu-id="b26ba-525">**重新分割資料流**</span><span class="sxs-lookup"><span data-stu-id="b26ba-525">**Repartition Streams**</span></span>|<span data-ttu-id="b26ba-526">「重新分割資料流」\*\*\*\* 運算子會消耗多個資料流，並產生多個記錄的資料流。</span><span class="sxs-lookup"><span data-stu-id="b26ba-526">The **Repartition Streams** operator consumes multiple streams and produces multiple streams of records.</span></span> <span data-ttu-id="b26ba-527">記錄內容與格式不會變更。</span><span class="sxs-lookup"><span data-stu-id="b26ba-527">The record contents and format are not changed.</span></span> <span data-ttu-id="b26ba-528">如果查詢最佳化工具使用點陣圖篩選，輸出資料流中的資料列數會減少。</span><span class="sxs-lookup"><span data-stu-id="b26ba-528">If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced.</span></span> <span data-ttu-id="b26ba-529">輸入資料流的每個資料錄會被放入一個輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="b26ba-529">Each record from an input stream is placed into one output stream.</span></span> <span data-ttu-id="b26ba-530">如果這個運算子要保留次序，那麼所有輸入資料流都必須排序好，而且合併成數個排序的輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="b26ba-530">If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams.</span></span> <span data-ttu-id="b26ba-531">如果輸出已分割，則資料 `Argument` 行包含資料分割資料行： ( # A1 述詞和分割資料行。如果輸出經過排序，則資料 `Argument` 行包含 ORDER BY： ( # A3 述詞和要排序的資料行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-531">If the output is partitioned, the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the columns being ordered.</span></span> <span data-ttu-id="b26ba-532">**重新分割資料流** 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-532">**Repartition Streams** is a logical operator.</span></span> <span data-ttu-id="b26ba-533">此運算子只用於平行查詢計畫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-533">The operator is used only in parallel query plans.</span></span>|  
|<span data-ttu-id="b26ba-534">![結果語言項目圖示](../../2014/database-engine/media/result-32x.gif "結果語言項目圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-534">![Result language element icon](../../2014/database-engine/media/result-32x.gif "Result language element icon")</span></span>|`Result`|<span data-ttu-id="b26ba-535">`Result` 運算子是在查詢計畫結束時所傳回的資料。</span><span class="sxs-lookup"><span data-stu-id="b26ba-535">The `Result` operator is the data returned at the end of a query plan.</span></span> <span data-ttu-id="b26ba-536">這通常是 Showplan 的根元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-536">This is usually the root element of a Showplan.</span></span> <span data-ttu-id="b26ba-537">`Result` 是語言元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-537">`Result` is a language element.</span></span>|  
|<span data-ttu-id="b26ba-538">![RID 查閱運算子圖示](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID 查閱運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-538">![RID lookup operator icon](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup operator icon")</span></span>|`RID Lookup`|<span data-ttu-id="b26ba-539">`RID Lookup` 是堆積上的書籤查閱，它會使用提供的資料列識別碼 (RID)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-539">`RID Lookup` is a bookmark lookup on a heap using a supplied row identifier (RID).</span></span> <span data-ttu-id="b26ba-540">資料行 `Argument` 包含書簽標籤，可用來查閱資料表中的資料列，以及查閱資料列的資料表名稱。</span><span class="sxs-lookup"><span data-stu-id="b26ba-540">The `Argument` column contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up.</span></span> <span data-ttu-id="b26ba-541">`RID Lookup` 一律都會伴隨 NESTED LOOP JOIN。</span><span class="sxs-lookup"><span data-stu-id="b26ba-541">`RID Lookup` is always accompanied by a NESTED LOOP JOIN.</span></span> <span data-ttu-id="b26ba-542">`RID Lookup` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-542">`RID Lookup` is a physical operator.</span></span> <span data-ttu-id="b26ba-543">如需書籤查閱的詳細資訊，請參閱 MSDN SQL Server 部落格中的[書籤查閱](https://go.microsoft.com/fwlink/?LinkId=132568)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-543">For more information about bookmark lookups, see "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" on the MSDN SQL Server blog.</span></span>|  
|<span data-ttu-id="b26ba-544">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-544">None</span></span>|`Right Anti Semi Join`|<span data-ttu-id="b26ba-545">`Right Anti Semi Join` 運算子會在第一個 (上方) 輸入中沒有符合資料列存在時，輸出第二個 (下方) 輸入中的每一列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-545">The `Right Anti Semi Join` operator outputs each row from the second (bottom) input when a matching row in the first (top) input does not exist.</span></span> <span data-ttu-id="b26ba-546">相符的資料列會定義為符合資料行中述詞的資料 `Argument` 列 (如果沒有述詞存在，每個資料列都是相符的資料列) 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-546">A matching row is defined as a row that satisfies the predicate in the `Argument` column (if no predicate exists, each row is a matching row).</span></span> <span data-ttu-id="b26ba-547">`Right Anti Semi Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-547">`Right Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-548">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-548">None</span></span>|`Right Outer Join`|<span data-ttu-id="b26ba-549">`Right Outer Join` 運算子所傳回的每個資料列，皆滿足第二個 (下方) 輸入與第一個 (上方) 輸入之每個相符資料列的聯結。</span><span class="sxs-lookup"><span data-stu-id="b26ba-549">The `Right Outer Join` operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input.</span></span> <span data-ttu-id="b26ba-550">它也會傳回第二個輸入中與第一個輸入完全不相符的任何資料列，以 NULL 相聯結。</span><span class="sxs-lookup"><span data-stu-id="b26ba-550">It also returns any rows from the second input that had no matching rows in the first input, joined with NULL.</span></span> <span data-ttu-id="b26ba-551">如果資料行中沒有聯結述詞 `Argument` ，則每個資料列都是相符的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-551">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="b26ba-552">`Right Outer Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-552">`Right Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-553">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-553">None</span></span>|`Right Semi Join`|<span data-ttu-id="b26ba-554">當第一個 (頂端) 輸入有相符的資料列時，`Right Semi Join` 運算子會從第二個 (底端) 輸入傳回每一個資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-554">The `Right Semi Join` operator returns each row from the second (bottom) input when there is a matching row in the first (top) input.</span></span> <span data-ttu-id="b26ba-555">如果資料行中沒有聯結述詞 `Argument` ，則每個資料列都是相符的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-555">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="b26ba-556">`Right Semi Join` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-556">`Right Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-557">![資料列計數多工緩衝處理運算子圖示](../../2014/database-engine/media/remote-count-spool-32x.gif "資料列計數多工緩衝處理運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-557">![Row count spool operator icon](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool operator icon")</span></span>|<span data-ttu-id="b26ba-558">**資料列計數多工緩衝處理**</span><span class="sxs-lookup"><span data-stu-id="b26ba-558">**Row Count Spool**</span></span>|<span data-ttu-id="b26ba-559">「資料列計數多工緩衝處理」運算子會掃描輸入、計算共有多少資料列，然後傳回一樣多但不含任何資料的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-559">The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them.</span></span> <span data-ttu-id="b26ba-560">如果重點是檢查資料列是否存在，而不是資料列中是否包含資料，就可以使用這個運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-560">This operator is used when it is important to check for the existence of rows, rather than the data contained in the rows.</span></span> <span data-ttu-id="b26ba-561">例如，如果 `Nested Loops` 運算子執行左方半聯結作業，而且聯結述詞會套用至內部輸入，則資料列計數多工緩衝處理可能會放在運算子內部輸入的頂端 `Nested Loops` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-561">For example, if a `Nested Loops` operator performs a left semi join operation and the join predicate applies to inner input, a row count spool may be placed at the top of the inner input of the `Nested Loops` operator.</span></span> <span data-ttu-id="b26ba-562">然後， `Nested Loops` 運算子可以判斷資料列計數多工緩衝處理所輸出的資料列數 (因為不需要內部的實際資料，) 判斷是否要傳回外部資料欄。</span><span class="sxs-lookup"><span data-stu-id="b26ba-562">Then the `Nested Loops` operator can determine how many rows are output by the row count spool (because the actual data from the inner side is not needed) to determine whether to return the outer row.</span></span> <span data-ttu-id="b26ba-563">「資料列計數多工緩衝處理」是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-563">**Row Count Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-564">![區段運算子圖示](../../2014/database-engine/media/segment-32x.gif "區段運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-564">![Segment operator icon](../../2014/database-engine/media/segment-32x.gif "Segment operator icon")</span></span>|<span data-ttu-id="b26ba-565">**區段**</span><span class="sxs-lookup"><span data-stu-id="b26ba-565">**Segment**</span></span>|<span data-ttu-id="b26ba-566">「區段」是實體和邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-566">**Segment** is a physical and a logical operator.</span></span> <span data-ttu-id="b26ba-567">它會根據一或多個資料行的值，將輸入集分割為區段。</span><span class="sxs-lookup"><span data-stu-id="b26ba-567">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="b26ba-568">這些資料行在「區段」運算子中會顯示為引數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-568">These columns are shown as arguments in the **Segment** operator.</span></span> <span data-ttu-id="b26ba-569">然後運算子一次會輸出一個區段。</span><span class="sxs-lookup"><span data-stu-id="b26ba-569">The operator then outputs one segment at a time.</span></span>|  
|<span data-ttu-id="b26ba-570">無</span><span class="sxs-lookup"><span data-stu-id="b26ba-570">None</span></span>|`Segment Repartition`|<span data-ttu-id="b26ba-571">在平行查詢計畫中，有時候會有 Iterator 的概念區。</span><span class="sxs-lookup"><span data-stu-id="b26ba-571">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="b26ba-572">在這種區域內的所有 Iterator，都可以由平行執行緒來執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-572">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="b26ba-573">區域本身必須連續執行。</span><span class="sxs-lookup"><span data-stu-id="b26ba-573">The regions themselves must be executed serially.</span></span> <span data-ttu-id="b26ba-574">個別區域內的一些 `Parallelism` Iterator，稱為 `Branch Repartition`。</span><span class="sxs-lookup"><span data-stu-id="b26ba-574">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="b26ba-575">在兩個這種區域的界限上的 `Parallelism` Iterator，稱為 `Segment Repartition`。</span><span class="sxs-lookup"><span data-stu-id="b26ba-575">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="b26ba-576">`Branch Repartition` 和 `Segment Repartition` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-576">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="b26ba-577">![序列運算子圖示](../../2014/database-engine/media/sequence-32x.gif "順序運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-577">![Sequence operator icon](../../2014/database-engine/media/sequence-32x.gif "Sequence operator icon")</span></span>|`Sequence`|<span data-ttu-id="b26ba-578">`Sequence` 運算子會驅動大範圍的更新計畫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-578">The `Sequence` operator drives wide update plans.</span></span> <span data-ttu-id="b26ba-579">在功能上，它會依序執行每個輸入 (由上而下)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-579">Functionally, it executes each input in sequence (top to bottom).</span></span> <span data-ttu-id="b26ba-580">每個輸入通常是更新不同的物件。</span><span class="sxs-lookup"><span data-stu-id="b26ba-580">Each input is usually an update of a different object.</span></span> <span data-ttu-id="b26ba-581">它只會傳回來自最後一個 (下方) 輸入的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-581">It returns only those rows that come from its last (bottom) input.</span></span> <span data-ttu-id="b26ba-582">`Sequence` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-582">`Sequence` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-583">![序列專案運算子圖示](../../2014/database-engine/media/sequence-project-32x.gif "順序專案運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-583">![Sequence project operator icon](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project operator icon")</span></span>|`Sequence Project`|<span data-ttu-id="b26ba-584">`Sequence Project` 運算子會加入資料行以執行已排序集合的計算。</span><span class="sxs-lookup"><span data-stu-id="b26ba-584">The `Sequence Project` operator adds columns to perform computations over an ordered set.</span></span> <span data-ttu-id="b26ba-585">它會根據一或多個資料行的值，將輸入集分割為區段。</span><span class="sxs-lookup"><span data-stu-id="b26ba-585">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="b26ba-586">然後運算子一次會輸出一個區段。</span><span class="sxs-lookup"><span data-stu-id="b26ba-586">The operator then outputs one segment at a time.</span></span> <span data-ttu-id="b26ba-587">這些資料行在 `Sequence Project` 運算子中會顯示為引數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-587">These columns are shown as arguments in the `Sequence Project` operator.</span></span> <span data-ttu-id="b26ba-588">`Sequence Project` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-588">`Sequence Project` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-589">![快照集資料指標運算子圖示](../../2014/database-engine/media/snapshot-32x.gif "快照集資料指標運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-589">![Snapshot cursor operator icon](../../2014/database-engine/media/snapshot-32x.gif "Snapshot cursor operator icon")</span></span>|<span data-ttu-id="b26ba-590">**快照式**</span><span class="sxs-lookup"><span data-stu-id="b26ba-590">**Snapshot**</span></span>|<span data-ttu-id="b26ba-591">「快照式」運算子會建立一個資料指標，而不會看到其他人所做的變更。</span><span class="sxs-lookup"><span data-stu-id="b26ba-591">The **Snapshot** operator creates a cursor that does not see changes made by others.</span></span>|  
|<span data-ttu-id="b26ba-592">![排序運算子圖示](../../2014/database-engine/media/sort-32x.gif "排序運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-592">![Sort operator icon](../../2014/database-engine/media/sort-32x.gif "Sort operator icon")</span></span>|`Sort`|<span data-ttu-id="b26ba-593">`Sort`運算子會排序所有傳入的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-593">The `Sort` operator sorts all incoming rows.</span></span> <span data-ttu-id="b26ba-594">`Argument`此資料行包含不同的 ORDER BY：如果此作業移除重複專案，則為 ( # A1 述詞，或 ORDER BY： ( # A3 述詞，其中包含要排序之資料行的逗號分隔清單。</span><span class="sxs-lookup"><span data-stu-id="b26ba-594">The `Argument` column contains either a DISTINCT ORDER BY:() predicate if duplicates are removed by this operation, or an ORDER BY:() predicate with a comma-separated list of the columns being sorted.</span></span> <span data-ttu-id="b26ba-595">如果將資料行依遞增順序排序，資料行前會加上 ASC 值，如果將資料行依遞減順序排序，資料行前會加上 DESC 值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-595">The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.</span></span> <span data-ttu-id="b26ba-596">`Sort` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-596">`Sort` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-597">![分割運算子圖示](../../2014/database-engine/media/split-32x.gif "分割運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-597">![Split operator icon](../../2014/database-engine/media/split-32x.gif "Split operator icon")</span></span>|`Split`|<span data-ttu-id="b26ba-598">`Split`運算子是用來優化更新處理。</span><span class="sxs-lookup"><span data-stu-id="b26ba-598">The `Split` operator is used to optimize update processing.</span></span> <span data-ttu-id="b26ba-599">它會將每個更新分割成一個刪除和一個插入作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-599">It splits each update operation into a delete and an insert operation.</span></span> <span data-ttu-id="b26ba-600">`Split` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-600">`Split` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-601">![多工緩衝處理運算子圖示](../../2014/database-engine/media/spool-32x.gif "多工緩衝處理運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-601">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="b26ba-602">**多工緩衝處理**</span><span class="sxs-lookup"><span data-stu-id="b26ba-602">**Spool**</span></span>|<span data-ttu-id="b26ba-603">多工**緩衝**處理運算子會將中繼查詢結果儲存到 `tempdb` 資料庫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-603">The **Spool** operator saves an intermediate query result to the `tempdb` database.</span></span>|  
|<span data-ttu-id="b26ba-604">![資料流彙總運算子圖示](../../2014/database-engine/media/stream-aggregate-32x.gif "資料流彙總運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-604">![Stream aggregate operator icon](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate operator icon")</span></span>|`Stream Aggregate`|<span data-ttu-id="b26ba-605">`Stream Aggregate` 運算子會依據一個或多個資料行將資料列分組，然後計算查詢所傳回的一個或多個彙總運算式。</span><span class="sxs-lookup"><span data-stu-id="b26ba-605">The `Stream Aggregate` operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query.</span></span> <span data-ttu-id="b26ba-606">這個運算子的輸出可稍後由查詢中的運算子參考，並/或傳回到用戶端。</span><span class="sxs-lookup"><span data-stu-id="b26ba-606">The output of this operator can be referenced by later operators in the query, returned to the client, or both.</span></span> <span data-ttu-id="b26ba-607">`Stream Aggregate` 運算子需要其群組內的輸入項目依資料行排列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-607">The `Stream Aggregate` operator requires input ordered by the columns within its groups.</span></span> <span data-ttu-id="b26ba-608">如果資料因為前面的 `Sort` 運算子或因為已排序索引搜尋或掃描，而尚未進行排序，最佳化工具就會在這個運算子之前使用 `Sort` 運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-608">The optimizer will use a `Sort` operator prior to this operator if the data is not already sorted due to a prior `Sort` operator or due to an ordered index seek or scan.</span></span> <span data-ttu-id="b26ba-609">在中的 SHOWPLAN_ALL 語句或圖形執行計畫中 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] ，GROUP BY 述詞中的資料行會列在 `Argument` 資料行中，而匯總運算式則會列在 [**定義的值**] 欄位中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-609">In the SHOWPLAN_ALL statement or the graphical execution plan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the GROUP BY predicate are listed in the `Argument` column, and the aggregate expressions are listed in the **Defined Values** column.</span></span> <span data-ttu-id="b26ba-610">`Stream Aggregate` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-610">`Stream Aggregate` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-611">![切換運算子圖示](../../2014/database-engine/media/switch-32x.gif "切換運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-611">![Switch operator icon](../../2014/database-engine/media/switch-32x.gif "Switch operator icon")</span></span>|<span data-ttu-id="b26ba-612">**開關**</span><span class="sxs-lookup"><span data-stu-id="b26ba-612">**Switch**</span></span>|<span data-ttu-id="b26ba-613">「參數」是一種特殊類型的串連 Iterator，它有 *n* 個輸入。</span><span class="sxs-lookup"><span data-stu-id="b26ba-613">**Switch** is a special type of concatenation iterator that has *n* inputs.</span></span> <span data-ttu-id="b26ba-614">運算式與每一個「參數」運算子相關聯。</span><span class="sxs-lookup"><span data-stu-id="b26ba-614">An expression is associated with each **Switch** operator.</span></span> <span data-ttu-id="b26ba-615">根據運算式的傳回值 (介於 0 和 *n*-1 之間)，「參數」會將適當的輸入資料流複製到輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="b26ba-615">Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream.</span></span> <span data-ttu-id="b26ba-616">「參數」的用途之一是實作查詢計畫，包括利用某些運算子向前快轉資料指標，例如 **TOP** 運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-616">One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.</span></span> <span data-ttu-id="b26ba-617">「參數」同時為邏輯和實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-617">**Switch** is both a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-618">![資料表刪除運算子圖示](../../2014/database-engine/media/table-delete-32x.gif "資料表刪除運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-618">![Table delete operator icon](../../2014/database-engine/media/table-delete-32x.gif "Table delete operator icon")</span></span>|`Table Delete`|<span data-ttu-id="b26ba-619">`Table Delete`實體運算子會從查詢執行計畫之資料行中所指定的資料表中刪除資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-619">The `Table Delete` physical operator deletes rows from the table specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="b26ba-620">![資料表插入運算子圖示](../../2014/database-engine/media/table-insert-32x.gif "資料表插入運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-620">![Table insert operator icon](../../2014/database-engine/media/table-insert-32x.gif "Table insert operator icon")</span></span>|`Table Insert`|<span data-ttu-id="b26ba-621">運算子會將 `Table Insert` 其輸入的資料列插入查詢執行計畫之資料行中所指定的資料表 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-621">The `Table Insert` operator inserts rows from its input into the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="b26ba-622">`Argument` 資料行也包含 SET:() 述詞，指出每一個資料行設定的值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-622">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="b26ba-623">如果 `Table Insert` 沒有插入值的子系，則會從插入運算子本身取得插入的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-623">If `Table Insert` has no children for insert values, then the row inserted is taken from the Insert operator itself.</span></span> <span data-ttu-id="b26ba-624">`Table Insert` 是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-624">`Table Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-625">![資料表合併運算子](../../2014/database-engine/media/table-merge-32x.gif "資料表合併運算子")</span><span class="sxs-lookup"><span data-stu-id="b26ba-625">![Table merge operator](../../2014/database-engine/media/table-merge-32x.gif "Table merge operator")</span></span>|<span data-ttu-id="b26ba-626">**資料表合併**</span><span class="sxs-lookup"><span data-stu-id="b26ba-626">**Table Merge**</span></span>|<span data-ttu-id="b26ba-627">「資料表合併」運算子會將合併資料流套用到堆積中。</span><span class="sxs-lookup"><span data-stu-id="b26ba-627">The **Table Merge** operator applies a merge data stream to a heap.</span></span> <span data-ttu-id="b26ba-628">運算子會在運算子的資料行中所指定的資料表中刪除、更新或插入資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-628">The operator deletes, updates, or inserts rows in the table specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="b26ba-629">所執行的實際作業取決於運算子的資料行中所指定之**ACTION**資料行的運行時間值 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-629">The actual operation performed depends on the run-time value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="b26ba-630">「資料表合併」是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-630">**Table Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-631">![資料表掃描運算子圖示](../../2014/database-engine/media/table-scan-32x.gif "資料表掃描運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-631">![Table scan operator icon](../../2014/database-engine/media/table-scan-32x.gif "Table scan operator icon")</span></span>|`Table Scan`|<span data-ttu-id="b26ba-632">`Table Scan`運算子會從查詢執行計畫之資料行中所指定的資料表，抓取所有的資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-632">The `Table Scan` operator retrieves all rows from the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="b26ba-633">如果 WHERE： ( # A1 述詞出現在資料 `Argument` 行中，則只會傳回滿足述詞的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-633">If a WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="b26ba-634">`Table Scan` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-634">`Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-635">![資料表多工緩衝處理運算子圖示](../../2014/database-engine/media/table-spool-32x.gif "資料表多工緩衝處理運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-635">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|<span data-ttu-id="b26ba-636">**資料表多工緩衝處理**</span><span class="sxs-lookup"><span data-stu-id="b26ba-636">**Table Spool**</span></span>|<span data-ttu-id="b26ba-637">「資料表多工緩衝處理」運算子會掃描輸入，並將每個資料列的複本放入隱藏的多工緩衝資料表 (儲存在 [tempdb](../relational-databases/databases/tempdb-database.md) 資料庫，直到查詢結束就不再存在)。</span><span class="sxs-lookup"><span data-stu-id="b26ba-637">The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb](../relational-databases/databases/tempdb-database.md) database and existing only for the lifetime of the query.</span></span> <span data-ttu-id="b26ba-638">如果運算子是倒帶 (例如，由 `Nested Loops` 運算子) 但不需要重新系結，則會使用多工緩衝處理的資料，而非重新掃描輸入。</span><span class="sxs-lookup"><span data-stu-id="b26ba-638">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="b26ba-639">「資料表多工緩衝處理」是實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-639">**Table Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="b26ba-640">![資料表更新運算子圖示](../../2014/database-engine/media/table-update-32x.gif "資料表更新運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-640">![Table update operator icon](../../2014/database-engine/media/table-update-32x.gif "Table update operator icon")</span></span>|`Table Update`|<span data-ttu-id="b26ba-641">`Table Update`實體運算子會更新查詢執行計畫之資料行所指定資料表中的輸入資料 `Argument` 列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-641">The `Table Update` physical operator updates input rows in the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="b26ba-642">SET:() 述詞決定每個更新資料行的值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-642">The SET:() predicate determines the value of each updated column.</span></span> <span data-ttu-id="b26ba-643">在 SET 子句中或這個運算子中，以及這個查詢中的其他位置，皆可參考這些數值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-643">These values may be referenced in the SET clause or elsewhere within this operator as well as elsewhere within this query.</span></span>|  
|<span data-ttu-id="b26ba-644">![資料表值函式運算子圖示](../../2014/database-engine/media/table-valued-function-32x.gif "資料表值函式運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-644">![Table-valued function operator icon](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function operator icon")</span></span>|<span data-ttu-id="b26ba-645">**資料表值函式**</span><span class="sxs-lookup"><span data-stu-id="b26ba-645">**Table-valued Function**</span></span>|<span data-ttu-id="b26ba-646">「資料表值函式」運算子會評估資料表值函數 ([!INCLUDE[tsql](../includes/tsql-md.md)] 或 CLR)，並將產生的資料列儲存至 [tempdb](../relational-databases/databases/tempdb-database.md) 資料庫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-646">The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE[tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb](../relational-databases/databases/tempdb-database.md) database.</span></span> <span data-ttu-id="b26ba-647">當父反覆運算器要求資料列時，**資料表值函式**會從傳回資料列 `tempdb` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-647">When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.</span></span><br /><br /> <span data-ttu-id="b26ba-648">含有呼叫資料表值函數的查詢會產生內含「資料表值函式」Iterator 的查詢計畫。</span><span class="sxs-lookup"><span data-stu-id="b26ba-648">Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator.</span></span> <span data-ttu-id="b26ba-649">「資料表值函式」可以使用不同的參數值進行評估：</span><span class="sxs-lookup"><span data-stu-id="b26ba-649">**Table-valued Function** can be evaluated with different parameter values:</span></span><br /><br /> <span data-ttu-id="b26ba-650">「資料表值函式 XML 讀取器」可輸入 XML BLOB 作為參數，並以 XML 文件的順序，產生代表 XML 節點的資料列集。</span><span class="sxs-lookup"><span data-stu-id="b26ba-650">**Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order.</span></span> <span data-ttu-id="b26ba-651">其他的輸入參數可能會限制傳回給 XML 文件子集的 XML 節點。</span><span class="sxs-lookup"><span data-stu-id="b26ba-651">Other input parameters may restrict XML nodes returned to a subset of XML document.</span></span><br /><br /> <span data-ttu-id="b26ba-652">**具有 xpath 篩選的資料表值函式 XML 讀取**器是一種特殊類型的**Xml 讀取器資料表值函數**，可將輸出限制為滿足 XPath 運算式的 xml 節點。</span><span class="sxs-lookup"><span data-stu-id="b26ba-652">**Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.</span></span><br /><br /> <br /><br /> <span data-ttu-id="b26ba-653">「資料表值函式」是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-653">**Table-valued Function** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-654">![Top 運算子圖示](../../2014/database-engine/media/top-32x.gif "Top 運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-654">![Top operator icon](../../2014/database-engine/media/top-32x.gif "Top operator icon")</span></span>|<span data-ttu-id="b26ba-655">**前幾個**</span><span class="sxs-lookup"><span data-stu-id="b26ba-655">**Top**</span></span>|<span data-ttu-id="b26ba-656">「頂端」運算子會掃描輸入，可能會根據排序的先後順序，只傳回指定數目或百分比的資料列。</span><span class="sxs-lookup"><span data-stu-id="b26ba-656">The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order.</span></span> <span data-ttu-id="b26ba-657">此資料行可以包含要檢查系結的資料 `Argument` 行清單。</span><span class="sxs-lookup"><span data-stu-id="b26ba-657">The `Argument` column can contain a list of the columns that are being checked for ties.</span></span> <span data-ttu-id="b26ba-658">在更新計畫中，可使用「頂端」運算子強行限制資料列數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-658">In update plans, the **Top** operator is used to enforce row count limits.</span></span> <span data-ttu-id="b26ba-659">「頂端」是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-659">**Top** is a logical and physical operator.</span></span> <span data-ttu-id="b26ba-660">「頂端」是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-660">**Top** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="b26ba-661">None</span><span class="sxs-lookup"><span data-stu-id="b26ba-661">None</span></span>|<span data-ttu-id="b26ba-662">**前 N 個排序**</span><span class="sxs-lookup"><span data-stu-id="b26ba-662">**Top N Sort**</span></span>|<span data-ttu-id="b26ba-663">「**前 n 個排序**」類似于 `Sort` iterator，不同之處在于只需要前*n*個數據列，而不是整個結果集。</span><span class="sxs-lookup"><span data-stu-id="b26ba-663">**Top N Sort** is similar to the `Sort` iterator, except that only the first *N* rows are needed, and not the entire result set.</span></span> <span data-ttu-id="b26ba-664">若 *N* 值較小，[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 查詢執行引擎會嘗試在記憶體中執行整個排序作業。</span><span class="sxs-lookup"><span data-stu-id="b26ba-664">For small values of *N*, the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory.</span></span> <span data-ttu-id="b26ba-665">若 *N*的值較大，則查詢執行引擎會訴諸比較一般性的排序方法，而不採用 *N* 作為參數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-665">For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* is not a parameter.</span></span>|  
|<span data-ttu-id="b26ba-666">![擴充運算子 (UDX) 圖示](../../2014/database-engine/media/udx-32x.gif "擴充運算子 (UDX) 圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-666">![Extended operator (UDX) icon](../../2014/database-engine/media/udx-32x.gif "Extended operator (UDX) icon")</span></span>|`UDX`|<span data-ttu-id="b26ba-667">擴充運算子 (UDX) 會在 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中實作許多 XQuery 和 XPath 作業的其中一項。</span><span class="sxs-lookup"><span data-stu-id="b26ba-667">Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="b26ba-668">所有 UDX 運算子都是邏輯和實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-668">All UDX operators are both logical and physical operators.</span></span><br /><br /> <span data-ttu-id="b26ba-669">擴充運算子 (UDX) `FOR XML` 用於序列化關聯式資料列集，它會在單一輸出資料列的單一 BLOB 資料行中，以 XML 表示法輸入這個資料列集。</span><span class="sxs-lookup"><span data-stu-id="b26ba-669">Extended operator (UDX) `FOR XML` is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row.</span></span> <span data-ttu-id="b26ba-670">這是一個會區分順序的 XML 彙總運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-670">It is an order sensitive XML aggregation operator.</span></span><br /><br /> <span data-ttu-id="b26ba-671">擴充運算子 (UDX) `XML SERIALIZER` 是區分順序的 XML 彙總運算子，</span><span class="sxs-lookup"><span data-stu-id="b26ba-671">Extended operator (UDX) `XML SERIALIZER` is an order sensitive XML aggregation operator.</span></span> <span data-ttu-id="b26ba-672">會以 XML 文件順序來輸入用於表示 XML 節點或 XQuery 純量的資料列，並在單一輸出資料列的單一 XML 資料行中產生序列化的 XML BLOB。</span><span class="sxs-lookup"><span data-stu-id="b26ba-672">It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.</span></span><br /><br /> <span data-ttu-id="b26ba-673">擴充運算子 (UDX) `XML FRAGMENT SERIALIZER` 是特殊類型的 `XML SERIALIZER`，可用於處理輸入資料列，而此輸入資料列用於表示要插入至 XQuery 插入資料修改延伸模組的 XML 片段。</span><span class="sxs-lookup"><span data-stu-id="b26ba-673">Extended operator (UDX) `XML FRAGMENT SERIALIZER` is a special type of `XML SERIALIZER` that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.</span></span><br /><br /> <span data-ttu-id="b26ba-674">擴充運算子 (UDX) `XQUERY STRING` 會評估用於表示 XML 節點之輸入資料列的 XQuery 字串值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-674">Extended operator (UDX) `XQUERY STRING` evaluates the XQuery string value of input rows representing XML nodes.</span></span> <span data-ttu-id="b26ba-675">這是一個區分順序的字串彙總運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-675">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="b26ba-676">它會輸出一個資料列以及多個資料行，每個資料行都代表含有輸入字串值的 XQuery 純量。</span><span class="sxs-lookup"><span data-stu-id="b26ba-676">It outputs one row with columns representing the XQuery scalar that contains string value of the input.</span></span><br /><br /> <span data-ttu-id="b26ba-677">擴充運算子 (UDX) `XQUERY LIST DECOMPOSER` 是 XQuery 清單分解運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-677">Extended operator (UDX) `XQUERY LIST DECOMPOSER` is an XQuery list decomposition operator.</span></span> <span data-ttu-id="b26ba-678">針對代表 XML 節點的每一個輸入資料列，會產生代表 XQuery 純量的一或多個資料列，而如果輸入是 XSD 清單類型，則包含清單元素值。</span><span class="sxs-lookup"><span data-stu-id="b26ba-678">For each input row representing an XML node it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.</span></span><br /><br /> <span data-ttu-id="b26ba-679">擴充運算子 (UDX) `XQUERY DATA` 會評估表示 XML 節點之輸入的 XQuery fn:data() 函數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-679">Extended operator (UDX) `XQUERY DATA` evaluates the XQuery fn:data() function on input representing XML nodes.</span></span> <span data-ttu-id="b26ba-680">這是一個區分順序的字串彙總運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-680">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="b26ba-681">它會輸出一個資料列以及多個資料行，每個資料行都代表含有 **fn:data()** 結果的 XQuery 純量。</span><span class="sxs-lookup"><span data-stu-id="b26ba-681">It outputs one row with columns representing XQuery scalar that contains the result of **fn:data()**.</span></span><br /><br /> <span data-ttu-id="b26ba-682">擴充運算子 `XQUERY CONTAINS` 會評估表示 XML 節點之輸入的 XQuery fn:contains() 函數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-682">Extended operator `XQUERY CONTAINS` evaluates the XQuery fn:contains() function on input representing XML nodes.</span></span> <span data-ttu-id="b26ba-683">這是一個區分順序的字串彙總運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-683">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="b26ba-684">它會輸出一個資料列以及多個資料行，每個資料行都代表含有 **fn:contains()** 結果的 XQuery 純量。</span><span class="sxs-lookup"><span data-stu-id="b26ba-684">It outputs one row with columns representing XQuery scalar that contains the result of **fn:contains()**.</span></span><br /><br /> <span data-ttu-id="b26ba-685">擴充運算子會 `UPDATE XML NODE` 更新 xml 類型上**修改 ( # B1**方法中的 XQuery 取代資料修改延伸模組中的 XML 節點。</span><span class="sxs-lookup"><span data-stu-id="b26ba-685">Extended operator `UPDATE XML NODE` updates XML node in the XQuery replace data modification extension in the **modify()** method on XML type.</span></span>|  
|<span data-ttu-id="b26ba-686">None</span><span class="sxs-lookup"><span data-stu-id="b26ba-686">None</span></span>|<span data-ttu-id="b26ba-687">**Union**</span><span class="sxs-lookup"><span data-stu-id="b26ba-687">**Union**</span></span>|<span data-ttu-id="b26ba-688">**Union** 運算子會掃描多個輸入，輸出掃描的每一資料列，並移除重複項。</span><span class="sxs-lookup"><span data-stu-id="b26ba-688">The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.</span></span> <span data-ttu-id="b26ba-689">**Union** 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-689">**Union** is a logical operator.</span></span>|  
|<span data-ttu-id="b26ba-690">![更新 (資料庫引擎) 運算子圖示](../../2014/database-engine/media/update-32x.gif "更新 (資料庫引擎) 運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-690">![Update (Database Engine) operator icon](../../2014/database-engine/media/update-32x.gif "Update (Database Engine) operator icon")</span></span>|`Update`|<span data-ttu-id="b26ba-691">`Update`運算子會從查詢執行計畫之資料行所指定物件中的每個資料列，更新其輸入 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="b26ba-691">The `Update` operator updates each row from its input in the object specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="b26ba-692">`Update` 是邏輯運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-692">`Update` is a logical operator.</span></span> <span data-ttu-id="b26ba-693">實體運算子是 `Table Update`、`Index Update` 或 `Clustered Index Update`。</span><span class="sxs-lookup"><span data-stu-id="b26ba-693">The physical operator is `Table Update`, `Index Update`, or `Clustered Index Update`.</span></span>|  
|<span data-ttu-id="b26ba-694">![While 語言項目圖示](../../2014/database-engine/media/while-32x.gif "While 語言項目圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-694">![While language element icon](../../2014/database-engine/media/while-32x.gif "While language element icon")</span></span>|`While`|<span data-ttu-id="b26ba-695">`While` 運算子會實作 [!INCLUDE[tsql](../includes/tsql-md.md)] while 迴圈。</span><span class="sxs-lookup"><span data-stu-id="b26ba-695">The `While` operator implements the [!INCLUDE[tsql](../includes/tsql-md.md)] while loop.</span></span> <span data-ttu-id="b26ba-696">`While` 是語言元素。</span><span class="sxs-lookup"><span data-stu-id="b26ba-696">`While` is a language element</span></span>|  
|<span data-ttu-id="b26ba-697">![資料表多工緩衝處理運算子圖示](../../2014/database-engine/media/table-spool-32x.gif "資料表多工緩衝處理運算子圖示")</span><span class="sxs-lookup"><span data-stu-id="b26ba-697">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|`Window Spool`|<span data-ttu-id="b26ba-698">`Window Spool` 運算子會將每一列展開成一組資料列，分別代表與其關聯的視窗。</span><span class="sxs-lookup"><span data-stu-id="b26ba-698">The `Window Spool` operator expands each row into the set of rows that represents the window associated with it.</span></span> <span data-ttu-id="b26ba-699">查詢中的 OVER 子句會定義查詢結果集中的視窗，以及一個計算視窗中各資料列值的視窗函數。</span><span class="sxs-lookup"><span data-stu-id="b26ba-699">In a query, the OVER clause defines the window within a query result set and a window function then computes a value for each row in the window.</span></span> <span data-ttu-id="b26ba-700">`Window Spool` 是邏輯與實體運算子。</span><span class="sxs-lookup"><span data-stu-id="b26ba-700">`Window Spool` is a logical and physical operator.</span></span>|  
  
  
