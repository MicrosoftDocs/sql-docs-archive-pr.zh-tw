---
title: 統計資料 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords:
- statistical information [SQL Server], query optimization
- query performance [SQL Server], statistics
- query optimization statistics [SQL Server]
- statistical information [SQL Server], database options
- query optimization statistics [SQL Server], about query optimization statistics
- statistical information [SQL Server], guidelines
- statistical information [SQL Server]
- using statistics [SQL Server]
- statistical information [SQL Server], indexes
- index statistics [SQL Server]
- query optimizer [SQL Server], statistics
- statistics [SQL Server]
ms.assetid: b86a88ba-4f7c-4e19-9fbd-2f8bcd3be14a
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 0f0950e48245bed53581d2f91b120ab9555aa562
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87599413"
---
# <a name="statistics"></a><span data-ttu-id="31dc3-102">統計資料</span><span class="sxs-lookup"><span data-stu-id="31dc3-102">Statistics</span></span>
  <span data-ttu-id="31dc3-103">查詢最佳化工具會使用統計資料來建立可改善查詢效能的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-103">The query optimizer uses statistics to create query plans that improve query performance.</span></span> <span data-ttu-id="31dc3-104">對於大部分查詢而言，查詢最佳化工具已經產生高品質查詢計劃的必要統計資料。不過，在少數情況下，您必須建立其他統計資料或修改查詢設計，以便獲得最佳結果。</span><span class="sxs-lookup"><span data-stu-id="31dc3-104">For most queries, the query optimizer already generates the necessary statistics for a high quality query plan; in a few cases, you need to create additional statistics or modify the query design for best results.</span></span> <span data-ttu-id="31dc3-105">本主題將討論有效使用查詢最佳化統計資料的概念和指導方針。</span><span class="sxs-lookup"><span data-stu-id="31dc3-105">This topic discusses statistics concepts and provides guidelines for using query optimization statistics effectively.</span></span>  
  
##  <a name="components-and-concepts"></a><a name="DefinitionQOStatistics"></a> <span data-ttu-id="31dc3-106">元件和概念</span><span class="sxs-lookup"><span data-stu-id="31dc3-106">Components and Concepts</span></span>  
 <span data-ttu-id="31dc3-107">統計資料</span><span class="sxs-lookup"><span data-stu-id="31dc3-107">Statistics</span></span>  
 <span data-ttu-id="31dc3-108">查詢最佳化的統計資料是指包含資料表或索引檢視表之一個或多個資料行中值分佈相關統計資料的物件。</span><span class="sxs-lookup"><span data-stu-id="31dc3-108">Statistics for query optimization are objects that contain statistical information about the distribution of values in one or more columns of a table or indexed view.</span></span> <span data-ttu-id="31dc3-109">查詢最佳化工具會使用這些統計資料來估計查詢結果中的*基數*或資料列數目。</span><span class="sxs-lookup"><span data-stu-id="31dc3-109">The query optimizer uses these statistics to estimate the *cardinality*, or number of rows, in the query result.</span></span> <span data-ttu-id="31dc3-110">這些*基數估計值*可讓查詢最佳化工具建立高品質的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-110">These *cardinality estimates* enable the query optimizer to create a high-quality query plan.</span></span> <span data-ttu-id="31dc3-111">例如，查詢最佳化工具可使用基數估計值來選擇索引搜尋運算子，而非需要更大量資源的索引掃描運算子，而且這樣做會改善查詢效能。</span><span class="sxs-lookup"><span data-stu-id="31dc3-111">For example, the query optimizer could use cardinality estimates to choose the index seek operator instead of the more resource-intensive index scan operator, and in doing so improve query performance.</span></span>  
  
 <span data-ttu-id="31dc3-112">每個統計資料物件都是針對一或多個資料表資料行的清單所建立，而且包含顯示第一個資料行中值分佈的長條圖。</span><span class="sxs-lookup"><span data-stu-id="31dc3-112">Each statistics object is created on a list of one or more table columns and includes a histogram displaying the distribution of values in the first column.</span></span> <span data-ttu-id="31dc3-113">多個資料行的統計資料物件也會儲存這些資料行之間值相互關聯的相關統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-113">Statistics objects on multiple columns also store statistical information about the correlation of values among the columns.</span></span> <span data-ttu-id="31dc3-114">這些相互關聯統計資料 (或稱「密度」) 衍生自資料行值之相異資料列的數目。</span><span class="sxs-lookup"><span data-stu-id="31dc3-114">These correlation statistics, or *densities*, are derived from the number of distinct rows of column values.</span></span> <span data-ttu-id="31dc3-115">如需統計資料物件的詳細資訊，請參閱 [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-115">For more information about statistics objects, see [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql).</span></span>  
  
 <span data-ttu-id="31dc3-116">篩選的統計資料</span><span class="sxs-lookup"><span data-stu-id="31dc3-116">Filtered Statistics</span></span>  
 <span data-ttu-id="31dc3-117">對於從定義完善的資料子集中選取的查詢而言，篩選的統計資料可以改善查詢效能。</span><span class="sxs-lookup"><span data-stu-id="31dc3-117">Filtered statistics can improve query performance for queries that select from well-defined subsets of data.</span></span> <span data-ttu-id="31dc3-118">篩選的統計資料會使用篩選述詞來選取統計資料中所含的資料子集。</span><span class="sxs-lookup"><span data-stu-id="31dc3-118">Filtered statistics use a filter predicate to select the subset of data that is included in the statistics.</span></span> <span data-ttu-id="31dc3-119">設計完善的篩選統計資料可以改善查詢執行計畫 (相較於完整資料表統計資料而言)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-119">Well-designed filtered statistics can improve the query execution plan compared with full-table statistics.</span></span> <span data-ttu-id="31dc3-120">如需篩選述詞的詳細資訊，請參閱 [CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-120">For more information about the filter predicate, see [CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql).</span></span> <span data-ttu-id="31dc3-121">如需有關何時建立篩選統計資料的詳細資訊，請參閱本主題的 [何時建立統計資料](#UpdateStatistics) 一節。</span><span class="sxs-lookup"><span data-stu-id="31dc3-121">For more information about when to create filtered statistics, see the [When to Create Statistics](#UpdateStatistics) section in this topic.</span></span> <span data-ttu-id="31dc3-122">如需個案研究，請參閱 SQLCAT 網站的部落格文章 [配合分割資料表使用已篩選的統計資料](https://go.microsoft.com/fwlink/?LinkId=178505)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-122">For a case study, see the blog entry, [Using Filtered Statistics with Partitioned Tables](https://go.microsoft.com/fwlink/?LinkId=178505), on the SQLCAT Web site.</span></span>  
  
 <span data-ttu-id="31dc3-123">統計資料選項</span><span class="sxs-lookup"><span data-stu-id="31dc3-123">Statistics Options</span></span>  
 <span data-ttu-id="31dc3-124">您可以設定三個選項來影響何時及如何建立和更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-124">There are three options that you can set that affect when and how statistics are created and updated.</span></span> <span data-ttu-id="31dc3-125">這些選項只會在資料庫層級設定。</span><span class="sxs-lookup"><span data-stu-id="31dc3-125">These options are set at the database level only.</span></span>  
  
 <span data-ttu-id="31dc3-126">AUTO_CREATE_STATISTICS 選項</span><span class="sxs-lookup"><span data-stu-id="31dc3-126">AUTO_CREATE_STATISTICS Option</span></span>  
 <span data-ttu-id="31dc3-127">開啟自動建立統計資料選項 AUTO_CREATE_STATISTICS 時，查詢最佳化工具就會視需要針對查詢述詞中的個別資料行建立統計資料，以便改善查詢計劃的基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-127">When the automatic create statistics option, AUTO_CREATE_STATISTICS, is on, the query optimizer creates statistics on individual columns in the query predicate, as necessary, to improve cardinality estimates for the query plan.</span></span> <span data-ttu-id="31dc3-128">這些單一資料行統計資料是針對在現有統計資料物件中尚未具有長條圖的資料行建立的。</span><span class="sxs-lookup"><span data-stu-id="31dc3-128">These single-column statistics are created on columns that do not already have a histogram in an existing statistics object.</span></span> <span data-ttu-id="31dc3-129">AUTO_CREATE_STATISTICS 選項不會判斷系統是否針對索引建立了統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-129">The AUTO_CREATE_STATISTICS option does not determine whether statistics get created for indexes.</span></span> <span data-ttu-id="31dc3-130">這個選項也不會產生篩選的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-130">This option also does not generate filtered statistics.</span></span> <span data-ttu-id="31dc3-131">它會嚴格套用至完整資料表的單一資料行統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-131">It applies strictly to single-column statistics for the full table.</span></span>  
  
 <span data-ttu-id="31dc3-132">當查詢最佳化工具由於使用 AUTO_CREATE_STATISTICS 選項而產生統計資料時，統計資料名稱就會以 `_WA`為開頭。</span><span class="sxs-lookup"><span data-stu-id="31dc3-132">When the query optimizer creates statistics as a result of using the AUTO_CREATE_STATISTICS option, the statistics name starts with `_WA`.</span></span> <span data-ttu-id="31dc3-133">您可以使用下列查詢來判斷查詢最佳化工具是否已經針對查詢述詞資料行建立了統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-133">You can use the following query to determine if the query optimizer has created statistics for a query predicate column.</span></span>  
  
```  
SELECT OBJECT_NAME(s.object_id) AS object_name,  
    COL_NAME(sc.object_id, sc.column_id) AS column_name,  
    s.name AS statistics_name  
FROM sys.stats AS s JOIN sys.stats_columns AS sc  
    ON s.stats_id = sc.stats_id AND s.object_id = sc.object_id  
WHERE s.name like '_WA%'  
ORDER BY s.name;  
```  
  
 <span data-ttu-id="31dc3-134">AUTO_UPDATE_STATISTICS 選項</span><span class="sxs-lookup"><span data-stu-id="31dc3-134">AUTO_UPDATE_STATISTICS Option</span></span>  
 <span data-ttu-id="31dc3-135">開啟自動更新統計資料選項 AUTO_UPDATE_STATISTICS 時，查詢最佳化工具就會判斷統計資料可能過期的時間，然後在查詢使用統計資料時加以更新。</span><span class="sxs-lookup"><span data-stu-id="31dc3-135">When the automatic update statistics option, AUTO_UPDATE_STATISTICS, is on, the query optimizer determines when statistics might be out-of-date and then updates them when they are used by a query.</span></span> <span data-ttu-id="31dc3-136">當插入、更新、刪除或合併作業變更資料表或索引檢視表中的資料分佈之後，統計資料就會變成過期。</span><span class="sxs-lookup"><span data-stu-id="31dc3-136">Statistics become out-of-date after insert, update, delete, or merge operations change the data distribution in the table or indexed view.</span></span> <span data-ttu-id="31dc3-137">查詢最佳化工具會計算自從上次更新統計資料以來資料修改的次數，並且比較修改次數與臨界值，藉以判斷統計資料可能過期的時間。</span><span class="sxs-lookup"><span data-stu-id="31dc3-137">The query optimizer determines when statistics might be out-of-date by counting the number of data modifications since the last statistics update and comparing the number of modifications to a threshold.</span></span> <span data-ttu-id="31dc3-138">此臨界值是以資料表或索引檢視表中的資料列數目為基礎。</span><span class="sxs-lookup"><span data-stu-id="31dc3-138">The threshold is based on the number of rows in the table or indexed view.</span></span>  
  
 <span data-ttu-id="31dc3-139">在編譯查詢之前以及執行快取查詢計劃之前，查詢最佳化工具會檢查是否有過期的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-139">The query optimizer checks for out-of-date statistics before compiling a query and before executing a cached query plan.</span></span> <span data-ttu-id="31dc3-140">在編譯查詢之前，查詢最佳化工具會使用查詢述詞中的資料行、資料表和索引檢視表來判斷哪些統計資料可能已過期。</span><span class="sxs-lookup"><span data-stu-id="31dc3-140">Before compiling a query, the query optimizer uses the columns, tables, and indexed views in the query predicate to determine which statistics might be out-of-date.</span></span> <span data-ttu-id="31dc3-141">在執行快取查詢計劃之前， [!INCLUDE[ssDE](../../../includes/ssde-md.md)] 會確認查詢計劃是否參考最新的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-141">Before executing a cached query plan, the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] verifies that the query plan references up-to-date statistics.</span></span>  
  
 <span data-ttu-id="31dc3-142">AUTO_UPDATE_STATISTICS 選項會套用至針對索引所建立的統計資料物件、查詢述詞中的單一資料行，以及使用 [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) 陳述式所建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-142">The AUTO_UPDATE_STATISTICS option applies to statistics objects created for indexes, single-columns in query predicates, and statistics created with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span> <span data-ttu-id="31dc3-143">此外，這個選項也會套用至篩選的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-143">This option also applies to filtered statistics.</span></span>  
  
 <span data-ttu-id="31dc3-144">AUTO_UPDATE_STATISTICS_ASYNC</span><span class="sxs-lookup"><span data-stu-id="31dc3-144">AUTO_UPDATE_STATISTICS_ASYNC</span></span>  
 <span data-ttu-id="31dc3-145">非同步統計資料更新選項 AUTO_UPDATE_STATISTICS_ASYNC 會決定查詢最佳化工具要使用同步或非同步統計資料更新。</span><span class="sxs-lookup"><span data-stu-id="31dc3-145">The asynchronous statistics update option, AUTO_UPDATE_STATISTICS_ASYNC, determines whether the query optimizer uses synchronous or asynchronous statistics updates.</span></span> <span data-ttu-id="31dc3-146">根據預設，非同步統計資料更新選項處於關閉狀態，而且查詢最佳化工具會以同步方式更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-146">By default, the asynchronous statistics update option is off, and the query optimizer updates statistics synchronously.</span></span> <span data-ttu-id="31dc3-147">AUTO_UPDATE_STATISTICS_ASYNC 選項會套用至針對索引所建立的統計資料物件、查詢述詞中的單一資料行，以及使用 [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) 陳述式所建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-147">The AUTO_UPDATE_STATISTICS_ASYNC option applies to statistics objects created for indexes, single columns in query predicates, and statistics created with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span>  
  
 <span data-ttu-id="31dc3-148">統計資料更新可以是同步 (預設值) 或非同步。</span><span class="sxs-lookup"><span data-stu-id="31dc3-148">Statistics updates can be either synchronous (the default) or asynchronous.</span></span> <span data-ttu-id="31dc3-149">使用同步統計資料更新時，查詢一律會使用最新的統計資料進行編譯和執行。如果統計資料已過期，查詢最佳化工具就會先等候更新的統計資料，然後再編譯並執行查詢。</span><span class="sxs-lookup"><span data-stu-id="31dc3-149">With synchronous statistics updates, queries always compile and execute with up-to-date statistics; When statistics are out-of-date, the query optimizer waits for updated statistics before compiling and executing the query.</span></span> <span data-ttu-id="31dc3-150">使用非同步統計資料更新時，查詢就會使用現有的統計資料進行編譯，即使現有的統計資料已過期也一樣。如果查詢進行編譯時統計資料已過期，查詢最佳化工具可能會選擇次佳查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-150">With asynchronous statistics updates, queries compile with existing statistics even if the existing statistics are out-of-date; The query optimizer could choose a suboptimal query plan if statistics are out-of-date when the query compiles.</span></span> <span data-ttu-id="31dc3-151">在非同步更新完成之後進行編譯的查詢將會從使用更新的統計資料中獲益。</span><span class="sxs-lookup"><span data-stu-id="31dc3-151">Queries that compile after the asynchronous updates have completed will benefit from using the updated statistics.</span></span>  
  
 <span data-ttu-id="31dc3-152">當您執行變更資料分佈的作業時 (例如截斷資料表，或大量更新大部分的資料列)，請考慮使用同步統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-152">Consider using synchronous statistics when you perform operations that change the distribution of data, such as truncating a table or performing a bulk update of a large percentage of the rows.</span></span> <span data-ttu-id="31dc3-153">如果您沒有在完成此作業之後更新統計資料，使用同步統計資料將可在針對變更的資料執行查詢之前，確保統計資料處於最新狀態。</span><span class="sxs-lookup"><span data-stu-id="31dc3-153">If you do not update the statistics after completing the operation, using synchronous statistics will ensure statistics are up-to-date before executing queries on the changed data.</span></span>  
  
 <span data-ttu-id="31dc3-154">在下列狀況中，請考慮使用非同步統計資料來達到更可預測的查詢回應時間：</span><span class="sxs-lookup"><span data-stu-id="31dc3-154">Consider using asynchronous statistics to achieve more predictable query response times for the following scenarios:</span></span>  
  
-   <span data-ttu-id="31dc3-155">您的應用程式經常會執行相同的查詢、相似的查詢或相似的快取查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-155">Your application frequently executes the same query, similar queries, or similar cached query plans.</span></span> <span data-ttu-id="31dc3-156">相較於使用同步統計資料更新而言，使用非同步統計資料更新可能會讓您的查詢回應時間更可預測，因為查詢最佳化工具不需要等候最新的統計資料，就可以執行傳入的查詢。</span><span class="sxs-lookup"><span data-stu-id="31dc3-156">Your query response times might be more predictable with asynchronous statistics updates than with synchronous statistics updates because the query optimizer can execute incoming queries without waiting for up-to-date statistics.</span></span> <span data-ttu-id="31dc3-157">這樣會避免延遲某些查詢，但無法避免延遲其他查詢。</span><span class="sxs-lookup"><span data-stu-id="31dc3-157">This avoids delaying some queries and not others.</span></span>  
  
-   <span data-ttu-id="31dc3-158">您的應用程式遇到等候更新統計資料之一或多個查詢所造成的用戶端要求逾時。</span><span class="sxs-lookup"><span data-stu-id="31dc3-158">Your application has experienced client request time outs caused by one or more queries waiting for updated statistics.</span></span> <span data-ttu-id="31dc3-159">在某些情況下，等候同步統計資料可能會造成具有彙總逾時的應用程式失敗。</span><span class="sxs-lookup"><span data-stu-id="31dc3-159">In some cases, waiting for synchronous statistics could cause applications with aggressive time outs to fail.</span></span>  
  
 <span data-ttu-id="31dc3-160">累加統計資料</span><span class="sxs-lookup"><span data-stu-id="31dc3-160">INCREMENTAL STATS</span></span>  
 <span data-ttu-id="31dc3-161">開啟 (ON) 時，所建立的統計資料是依據每個分割區區的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-161">When ON, the statistics created are per partition statistics.</span></span> <span data-ttu-id="31dc3-162">關閉 (OFF) 時，會卸除統計資料樹狀結構，而 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 會重新計算統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-162">When OFF, the statistics tree is dropped and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] re-computes the statistics.</span></span> <span data-ttu-id="31dc3-163">預設值為 OFF。</span><span class="sxs-lookup"><span data-stu-id="31dc3-163">The default is OFF.</span></span> <span data-ttu-id="31dc3-164">此設定會覆寫資料庫層級 INCREMENTAL 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dc3-164">This setting overrides the database level INCREMENTAL property.</span></span>  
  
 <span data-ttu-id="31dc3-165">當新的分割區區加入到大型資料表時，應更新統計資料，以包含新的分割區區。</span><span class="sxs-lookup"><span data-stu-id="31dc3-165">When new partitions are added to a large table, statistics should be updated to include the new partitions.</span></span> <span data-ttu-id="31dc3-166">但是掃描整個資料表 (FULLSCAN 或 SAMPLE 選項) 所需的時間可能會很長。</span><span class="sxs-lookup"><span data-stu-id="31dc3-166">However the time required to scan the entire table (FULLSCAN or SAMPLE option) might be quite long.</span></span> <span data-ttu-id="31dc3-167">此外，由於可能只需要新分割區區的統計資料，所以不需要掃描整個資料表。</span><span class="sxs-lookup"><span data-stu-id="31dc3-167">Also, scanning the entire table isn't necessary because only the statistics on the new partitions might be needed.</span></span> <span data-ttu-id="31dc3-168">累加選項會以每個分割區區為基礎，建立及儲存統計資料，更新時只會重新整理需要新統計資料之分割區區的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-168">The incremental option creates and stores statistics on a per partition basis, and when updated, only refreshes statistics on those partitions that need new statistics</span></span>  
  
 <span data-ttu-id="31dc3-169">如果不支援每個分割區區的統計資料，則會忽略該選項，並產生警告。</span><span class="sxs-lookup"><span data-stu-id="31dc3-169">If per partition statistics are not supported the option is ignored and a warning is generated.</span></span> <span data-ttu-id="31dc3-170">針對下列統計資料類型，不支援累加統計資料：</span><span class="sxs-lookup"><span data-stu-id="31dc3-170">Incremental stats are not supported for following statistics types:</span></span>  
  
-   <span data-ttu-id="31dc3-171">建立統計資料時，所使用的索引未與基底資料表進行分割區對齊。</span><span class="sxs-lookup"><span data-stu-id="31dc3-171">Statistics created with indexes that are not partition-aligned with the base table.</span></span>  
  
-   <span data-ttu-id="31dc3-172">在 AlwaysOn 可讀取次要資料庫上建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-172">Statistics created on AlwaysOn readable secondary databases.</span></span>  
  
-   <span data-ttu-id="31dc3-173">在唯讀資料庫上建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-173">Statistics created on read-only databases.</span></span>  
  
-   <span data-ttu-id="31dc3-174">在篩選的索引上建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-174">Statistics created on filtered indexes.</span></span>  
  
-   <span data-ttu-id="31dc3-175">在檢視上建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-175">Statistics created on views.</span></span>  
  
-   <span data-ttu-id="31dc3-176">在內部資料表上建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-176">Statistics created on internal tables.</span></span>  
  
-   <span data-ttu-id="31dc3-177">使用空間索引或 XML 索引建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-177">Statistics created with spatial indexes or XML indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="31dc3-178">**適用於**： [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] 至 [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="31dc3-178">**Applies to**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] through [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)].</span></span>|  
  
##  <a name="when-to-create-statistics"></a><a name="CreateStatistics"></a><span data-ttu-id="31dc3-179">建立統計資料的時機</span><span class="sxs-lookup"><span data-stu-id="31dc3-179">When to Create Statistics</span></span>  
 <span data-ttu-id="31dc3-180">查詢最佳化工具已經用下列方式建立統計資料：</span><span class="sxs-lookup"><span data-stu-id="31dc3-180">The query optimizer already creates statistics in the following ways:</span></span>  
  
1.  <span data-ttu-id="31dc3-181">建立索引時，查詢最佳化工具就會針對資料表或檢視表的索引建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-181">The query optimizer creates statistics for indexes on tables or views when the index is created.</span></span> <span data-ttu-id="31dc3-182">這些統計資料是針對索引的索引鍵資料行所建立的。</span><span class="sxs-lookup"><span data-stu-id="31dc3-182">These statistics are created on the key columns of the index.</span></span> <span data-ttu-id="31dc3-183">如果索引是篩選的索引，查詢最佳化工具就會在針對篩選索引所指定的相同資料列子集上建立篩選的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-183">If the index is a filtered index, the query optimizer creates filtered statistics on the same subset of rows specified for the filtered index.</span></span> <span data-ttu-id="31dc3-184">如需篩選索引的詳細資訊，請參閱[建立篩選的索引](../indexes/create-filtered-indexes.md)和 [CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-184">For more information about filtered indexes, see [Create Filtered Indexes](../indexes/create-filtered-indexes.md) and [CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql).</span></span>  
  
2.  <span data-ttu-id="31dc3-185">開啟 AUTO_CREATE_STATISTICS 時，查詢最佳化工具會針對查詢述詞中的單一資料行建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-185">The query optimizer creates statistics for single columns in query predicates when AUTO_CREATE_STATISTICS is on.</span></span>  
  
 <span data-ttu-id="31dc3-186">對於大部分查詢而言，這兩種建立統計資料的方法可確保高品質的查詢計劃。不過，在少數情況下，您可以使用 [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) 陳述式來建立其他統計資料，以便改善查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-186">For most queries, these two methods for creating statistics ensure a high-quality query plan; in a few cases, you can improve query plans by creating additional statistics with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span> <span data-ttu-id="31dc3-187">這些額外的統計資料可以擷取查詢最佳化工具在建立索引或單一資料行的統計資料時無法解釋的統計相互關聯。</span><span class="sxs-lookup"><span data-stu-id="31dc3-187">These additional statistics can capture statistical correlations that the query optimizer does not account for when it creates statistics for indexes or single columns.</span></span> <span data-ttu-id="31dc3-188">您的應用程式可能會在資料表資料中具有其他統計相互關聯，而且如果它們計算成統計資料物件，就可讓查詢最佳化工具改善查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-188">Your application might have additional statistical correlations in the table data that, if calculated into a statistics object, could enable the query optimizer to improve query plans.</span></span> <span data-ttu-id="31dc3-189">例如，資料列子集的篩選統計資料或查詢述詞資料行的多重資料行統計資料可能會改善查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-189">For example, filtered statistics on a subset of data rows or multicolumn statistics on query predicate columns might improve the query plan.</span></span>  
  
 <span data-ttu-id="31dc3-190">使用 CREATE STATISTICS 陳述式來建立統計資料時，我們建議您將 AUTO_CREATE_STATISTICS 選項保持開啟狀態，讓查詢最佳化工具能夠繼續例行地針對查詢述詞資料行建立單一資料行統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-190">When creating statistics with the CREATE STATISTICS statement, we recommend keeping the AUTO_CREATE_STATISTICS option on so that the query optimizer continues to routinely create single-column statistics for query predicate columns.</span></span> <span data-ttu-id="31dc3-191">如需查詢述詞的詳細資訊，請參閱[搜尋條件 &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-191">For more information about query predicates, see [Search Condition &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql).</span></span>  
  
 <span data-ttu-id="31dc3-192">當下列任何情況適用時，請考慮使用 CREATE STATISTICS 陳述式來建立統計資料：</span><span class="sxs-lookup"><span data-stu-id="31dc3-192">Consider creating statistics with the CREATE STATISTICS statement when any of the following applies:</span></span>  
  
-   <span data-ttu-id="31dc3-193">[!INCLUDE[ssDE](../../../includes/ssde-md.md)] Tuning Advisor 建議您建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-193">The [!INCLUDE[ssDE](../../../includes/ssde-md.md)] Tuning Advisor suggests creating statistics.</span></span>  
  
-   <span data-ttu-id="31dc3-194">查詢述詞包含多個尚未存在相同索引中的相互關聯資料行。</span><span class="sxs-lookup"><span data-stu-id="31dc3-194">The query predicate contains multiple correlated columns that are not already in the same index.</span></span>  
  
-   <span data-ttu-id="31dc3-195">查詢會從資料子集中選取。</span><span class="sxs-lookup"><span data-stu-id="31dc3-195">The query selects from a subset of data.</span></span>  
  
-   <span data-ttu-id="31dc3-196">查詢具有遺失的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-196">The query has missing statistics.</span></span>  
  
### <a name="query-predicate-contains-multiple-correlated-columns"></a><span data-ttu-id="31dc3-197">查詢述詞包含多個相互關聯的資料行</span><span class="sxs-lookup"><span data-stu-id="31dc3-197">Query Predicate Contains Multiple Correlated Columns</span></span>  
 <span data-ttu-id="31dc3-198">當查詢述詞包含多個具有跨資料行關聯性與相依性的資料行時，多個資料行的統計資料可能會改善查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-198">When a query predicate contains multiple columns that have cross-column relationships and dependencies, statistics on the multiple columns might improve the query plan.</span></span> <span data-ttu-id="31dc3-199">多個資料行的統計資料包含跨資料行相互關聯統計資料 (稱為「密度」，而且這些統計資料不會在單一資料行統計資料中提供。</span><span class="sxs-lookup"><span data-stu-id="31dc3-199">Statistics on multiple columns contain cross-column correlation statistics, called *densities*, that are not available in single-column statistics.</span></span> <span data-ttu-id="31dc3-200">當查詢結果相依於多個資料行之間的資料關聯性時，密度可以改善基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-200">Densities can improve cardinality estimates when query results depend on data relationships among multiple columns.</span></span>  
  
 <span data-ttu-id="31dc3-201">如果資料行已經存在相同的索引中，就表示多重資料行統計資料物件已經存在，而且您不需要手動建立此物件。</span><span class="sxs-lookup"><span data-stu-id="31dc3-201">If the columns are already in the same index, the multicolumn statistics object already exists and it is not necessary to create it manually.</span></span> <span data-ttu-id="31dc3-202">如果資料行尚未存在相同的索引中，您可以針對資料行建立索引或使用 CREATE STATISTICS 陳述式，藉以建立多重資料行統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-202">If the columns are not already in the same index, you can create multicolumn statistics by creating an index on the columns or by using the CREATE STATISTICS statement.</span></span> <span data-ttu-id="31dc3-203">相較於統計資料物件而言，這種統計資料需要更多系統資源來維護索引。</span><span class="sxs-lookup"><span data-stu-id="31dc3-203">It requires more system resources to maintain an index than a statistics object.</span></span> <span data-ttu-id="31dc3-204">如果應用程式不需要多重資料行索引，您就可以建立統計資料物件而不建立索引，藉以節省系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dc3-204">If the application does not require the multicolumn index, you can economize on system resources by creating the statistics object without creating the index.</span></span>  
  
 <span data-ttu-id="31dc3-205">建立多重資料行統計資料時，統計資料物件定義中的資料行順序會影響建立基數估計值之密度的有效性。</span><span class="sxs-lookup"><span data-stu-id="31dc3-205">When creating multicolumn statistics, the order of the columns in the statistics object definition affects the effectiveness of densities for making cardinality estimates.</span></span> <span data-ttu-id="31dc3-206">統計資料物件會將索引鍵資料行之每個前置詞的密度儲存在統計資料物件定義中。</span><span class="sxs-lookup"><span data-stu-id="31dc3-206">The statistics object stores densities for each prefix of key columns in the statistics object definition.</span></span> <span data-ttu-id="31dc3-207">如需密度的詳細資訊，請參閱 [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-207">For more information about densities, see [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql).</span></span>  
  
 <span data-ttu-id="31dc3-208">若要建立對於基數估計值有用的密度，查詢述詞中的資料行必須與統計資料物件定義的其中一個資料行前置詞相符。</span><span class="sxs-lookup"><span data-stu-id="31dc3-208">To create densities that are useful for cardinality estimates, the columns in the query predicate must match one of the prefixes of columns in the statistics object definition.</span></span> <span data-ttu-id="31dc3-209">例如，下列命令會針對 `LastName`、 `MiddleName`和 `FirstName`資料行建立多重資料行統計資料物件。</span><span class="sxs-lookup"><span data-stu-id="31dc3-209">For example, the following creates a multicolumn statistics object on the columns `LastName`, `MiddleName`, and `FirstName`.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
IF EXISTS (SELECT name FROM sys.stats  
    WHERE name = 'LastFirst'  
    AND object_ID = OBJECT_ID ('Person.Person'))  
DROP STATISTICS Person.Person.LastFirst;  
GO  
CREATE STATISTICS LastFirst ON Person.Person (LastName, MiddleName, FirstName);  
GO  
```  
  
 <span data-ttu-id="31dc3-210">在這則範例中，統計資料物件 `LastFirst` 具有下列資料行前置詞的密度：(`LastName`)、(`LastName, MiddleName`) 和 (`LastName, MiddleName, FirstName`)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-210">In this example, the statistics object `LastFirst` has densities for the following column prefixes: (`LastName`), (`LastName, MiddleName`), and (`LastName, MiddleName, FirstName`).</span></span> <span data-ttu-id="31dc3-211">此密度不適用於 (`LastName, FirstName`)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-211">The density is not available for (`LastName, FirstName`).</span></span> <span data-ttu-id="31dc3-212">如果查詢使用 `LastName` 和 `FirstName` 而不使用 `MiddleName`，此密度就不適用於基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-212">If the query uses `LastName` and `FirstName` without using `MiddleName`, the density is not available for cardinality estimates.</span></span>  
  
### <a name="query-selects-from-a-subset-of-data"></a><span data-ttu-id="31dc3-213">查詢會從資料子集中選取</span><span class="sxs-lookup"><span data-stu-id="31dc3-213">Query Selects from a Subset of Data</span></span>  
 <span data-ttu-id="31dc3-214">當查詢最佳化工具針對單一資料行和索引建立統計資料時，它就會針對所有資料列中的值建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-214">When the query optimizer creates statistics for single columns and indexes, it creates the statistics for the values in all rows.</span></span> <span data-ttu-id="31dc3-215">當查詢從資料列的子集中選取，而且該資料列子集具有唯一的資料分佈時，篩選的統計資料就可以改善查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-215">When queries select from a subset of rows, and that subset of rows has a unique data distribution, filtered statistics can improve query plans.</span></span> <span data-ttu-id="31dc3-216">您可以使用 CREATE STATISTICS 陳述式搭配 WHERE 子句來定義篩選述詞運算式，藉此建立篩選統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-216">You can create filtered statistics by using the CREATE STATISTICS statement with the WHERE clause to define the filter predicate expression.</span></span>  
  
 <span data-ttu-id="31dc3-217">例如，在使用 [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)]時，Production.Product 資料表中的每個產品都屬於 Production.ProductCategory 資料表中的四個類別之一：Bikes、Components、Clothing 及 Accessories。</span><span class="sxs-lookup"><span data-stu-id="31dc3-217">For example, using [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)], each product in the Production.Product table belongs to one of four categories in the Production.ProductCategory table: Bikes, Components, Clothing, and Accessories.</span></span> <span data-ttu-id="31dc3-218">其中每個類別目錄都具有不同的重量資料分佈：腳踏車 (Bikes) 的重量範圍是從 13.77 到 30.0、元件 (Components) 的重量範圍是從 2.12 到 1050.00 且有些是 NULL 值、衣服 (Clothing) 的重量全部為 NULL，配件 (Accessories) 的重量也是 NULL。</span><span class="sxs-lookup"><span data-stu-id="31dc3-218">Each of the categories has a different data distribution for weight: bike weights range from 13.77 to 30.0, component weights range from 2.12 to 1050.00 with some NULL values, clothing weights are all NULL, and accessory weights are also NULL.</span></span>  
  
 <span data-ttu-id="31dc3-219">以 Bikes 為例，相較於 Weight 資料行的完整資料表統計資料或不存在的統計資料而言，所有腳踏車重量的篩選統計資料將提供更精確的統計資料給查詢最佳化工具，而且可以改善查詢計畫品質。</span><span class="sxs-lookup"><span data-stu-id="31dc3-219">Using Bikes as an example, filtered statistics on all bike weights will provide more accurate statistics to the query optimizer and can improve the query plan quality compared with full-table statistics or nonexistent statistics on the Weight column.</span></span> <span data-ttu-id="31dc3-220">雖然腳踏車重量資料行適合做為篩選的統計資料，但是不一定適合做為篩選的索引 (如果重量查閱的數目相當小的話)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-220">The bike weight column is a good candidate for filtered statistics but not necessarily a good candidate for a filtered index if the number of weight lookups is relatively small.</span></span> <span data-ttu-id="31dc3-221">篩選索引為查閱所提供的效能提升程度可能不會超過將篩選索引加入至資料庫的額外維護和儲存成本。</span><span class="sxs-lookup"><span data-stu-id="31dc3-221">The performance gain for lookups that a filtered index provides might not outweigh the additional maintenance and storage cost for adding a filtered index to the database.</span></span>  
  
 <span data-ttu-id="31dc3-222">下列陳述式會針對 Bikes 的所有子類別目錄建立 `BikeWeights` 篩選統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-222">The following statement creates the `BikeWeights` filtered statistics on all of the subcategories for Bikes.</span></span> <span data-ttu-id="31dc3-223">篩選述詞運算式會使用比較 `Production.ProductSubcategoryID IN (1,2,3)`來列舉所有腳踏車子類別目錄，藉以定義腳踏車。</span><span class="sxs-lookup"><span data-stu-id="31dc3-223">The filtered predicate expression defines bikes by enumerating all of the bike subcategories with the comparison `Production.ProductSubcategoryID IN (1,2,3)`.</span></span> <span data-ttu-id="31dc3-224">此述詞無法使用 Bikes 類別目錄，因為它儲存在 Production.ProductCategory 資料表中，而且篩選運算式的所有資料行都必須位於相同的資料表中。</span><span class="sxs-lookup"><span data-stu-id="31dc3-224">The predicate cannot use the Bikes category name because it is stored in the Production.ProductCategory table, and all columns in the filter expression must be in the same table.</span></span>  
  
 [!code-sql[StatisticsDDL#FilteredStats2](../../snippets/tsql/SQL14/tsql/statisticsddl/transact-sql/filteredstats.sql#filteredstats2)]  
  
 <span data-ttu-id="31dc3-225">查詢最佳化工具可以使用 `BikeWeights` 篩選統計資料來改善下列查詢的查詢計劃 (此查詢會選取所有重量超過 `25`的腳踏車)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-225">The query optimizer can use the `BikeWeights` filtered statistics to improve the query plan for the following query that selects all of the bikes that weigh more than `25`.</span></span>  
  
```  
SELECT P.Weight AS Weight, S.Name AS BikeName  
FROM Production.Product AS P  
    JOIN Production.ProductSubcategory AS S   
    ON P.ProductSubcategoryID = S.ProductSubcategoryID  
WHERE P.ProductSubcategoryID IN (1,2,3) AND P.Weight > 25  
ORDER BY P.Weight;  
GO  
```  
  
### <a name="query-identifies-missing-statistics"></a><span data-ttu-id="31dc3-226">查詢會識別遺失的統計資料</span><span class="sxs-lookup"><span data-stu-id="31dc3-226">Query Identifies Missing Statistics</span></span>  
 <span data-ttu-id="31dc3-227">如果錯誤或其他事件讓查詢最佳化工具無法建立統計資料，查詢最佳化工具會建立查詢計劃，但不使用統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-227">If an error or other event prevents the query optimizer from creating statistics, the query optimizer creates the query plan without using statistics.</span></span> <span data-ttu-id="31dc3-228">查詢最佳化工具會將統計資料標示為遺失，並且嘗試在下一次執行查詢時重新產生統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-228">The query optimizer marks the statistics as missing and attempts to regenerate the statistics the next time the query is executed.</span></span>  
  
 <span data-ttu-id="31dc3-229">當查詢的執行計畫是利用 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]以圖形顯示時，遺失的統計資料就會表示成警告 (資料表名稱為紅色)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-229">Missing statistics are indicated as warnings (table name in red text) when the execution plan of a query is graphically displayed using [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="31dc3-230">此外，使用 [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] 來監視 **Missing Column Statistics** 事件類別會指出統計資料遺失的時間。</span><span class="sxs-lookup"><span data-stu-id="31dc3-230">Additionally, monitoring the **Missing Column Statistics** event class by using [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] indicates when statistics are missing.</span></span> <span data-ttu-id="31dc3-231">如需詳細資訊，請參閱[錯誤和警告事件類別目錄 &#40;Database Engine&#41;](../event-classes/errors-and-warnings-event-category-database-engine.md)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-231">For more information, see [Errors and Warnings Event Category &#40;Database Engine&#41;](../event-classes/errors-and-warnings-event-category-database-engine.md).</span></span>  
  
 <span data-ttu-id="31dc3-232">如果統計資料已遺失，請執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="31dc3-232">If statistics are missing, perform the following steps:</span></span>  
  
-   <span data-ttu-id="31dc3-233">確認已開啟 AUTO_CREATE_STATISTICS 和 AUTO_UPDATE_STATISTICS。</span><span class="sxs-lookup"><span data-stu-id="31dc3-233">Verify that AUTO_CREATE_STATISTICS and AUTO_UPDATE_STATISTICS are on.</span></span>  
  
-   <span data-ttu-id="31dc3-234">確認資料庫不是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="31dc3-234">Verify that the database is not read-only.</span></span> <span data-ttu-id="31dc3-235">如果資料庫是唯讀的，查詢最佳化工具就無法儲存統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-235">If the database is read-only, the query optimizer cannot save statistics.</span></span>  
  
-   <span data-ttu-id="31dc3-236">使用 CREATE STATISTICS 陳述式來建立遺失的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-236">Create the missing statistics by using the CREATE STATISTICS statement.</span></span>  
  
 <span data-ttu-id="31dc3-237">如果唯讀資料庫或唯讀快照集上的統計資料遺漏或過時，[!INCLUDE[ssDE](../../../includes/ssde-md.md)] 會在 `tempdb` 中建立及維護暫時性統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-237">When statistics on a read-only database or read-only snapshot are missing or stale, the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] creates and maintains temporary statistics in `tempdb`.</span></span> <span data-ttu-id="31dc3-238">當 [!INCLUDE[ssDE](../../../includes/ssde-md.md)] 建立暫時統計資料時，統計資料名稱會附加後置詞 _readonly_database_statistic，以便區分暫時統計資料與永久統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-238">When the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] creates temporary statistics, the statistics name is appended with the suffix _readonly_database_statistic to differentiate the temporary statistics from the permanent statistics.</span></span> <span data-ttu-id="31dc3-239">後置詞 _readonly_database_statistic 會保留給 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]產生的統計資料使用。</span><span class="sxs-lookup"><span data-stu-id="31dc3-239">The suffix _readonly_database_statistic is reserved for statistics generated by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="31dc3-240">暫時統計資料的指令碼可以在讀寫資料庫上建立和複製。</span><span class="sxs-lookup"><span data-stu-id="31dc3-240">Scripts for the temporary statistics can be created and reproduced on a read-write database.</span></span> <span data-ttu-id="31dc3-241">當編寫指令碼時， [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] 會將統計資料名稱的後置詞從 _readonly_database_statistic 變更為 _readonly_database_statistic_scripted。</span><span class="sxs-lookup"><span data-stu-id="31dc3-241">When scripted, [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] changes the suffix of the statistics name from _readonly_database_statistic to _readonly_database_statistic_scripted.</span></span>  
  
 <span data-ttu-id="31dc3-242">只有 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以建立和更新暫時統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-242">Only [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can create and update temporary statistics.</span></span> <span data-ttu-id="31dc3-243">但是，您可以使用永久統計資料所使用的相同工具來刪除暫時統計資料及監控統計資料屬性：</span><span class="sxs-lookup"><span data-stu-id="31dc3-243">However, you can delete temporary statistics and monitor statistics properties using the same tools that you use for permanent statistics:</span></span>  
  
-   <span data-ttu-id="31dc3-244">使用 [DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) 陳述式所建立的統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-244">Delete temporary statistics using the [DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) statement.</span></span>  
  
-   <span data-ttu-id="31dc3-245">使用 **sys.stats** 和 **sys.stats_columns** 目錄檢視監視統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-245">Monitor statistics using the **sys.stats** and **sys.stats_columns** catalog views.</span></span> <span data-ttu-id="31dc3-246">**sys_stats** 包含 **is_temporary** 資料行，以指示哪些統計資料為永久性及哪些統計資料為暫時性。</span><span class="sxs-lookup"><span data-stu-id="31dc3-246">**sys_stats** includes the **is_temporary** column, to indicate which statistics are permanent and which are temporary.</span></span>  
  
 <span data-ttu-id="31dc3-247">因為暫時統計資料會儲存在 `tempdb` 中，所以重新啟動 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 服務會導致所有暫時統計資料消失。</span><span class="sxs-lookup"><span data-stu-id="31dc3-247">Because temporary statistics are stored in `tempdb`, a restart of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] service causes all temporary statistics to disappear.</span></span>  
  
##  <a name="when-to-update-statistics"></a><a name="UpdateStatistics"></a><span data-ttu-id="31dc3-248">何時更新統計資料</span><span class="sxs-lookup"><span data-stu-id="31dc3-248">When to Update Statistics</span></span>  
 <span data-ttu-id="31dc3-249">查詢最佳化工具會判斷統計資料可能過期的時間，然後在查詢計劃需要它們時進行更新。</span><span class="sxs-lookup"><span data-stu-id="31dc3-249">The query optimizer determines when statistics might be out-of-date and then updates them when they are needed for a query plan.</span></span> <span data-ttu-id="31dc3-250">在某些情況下，您可以讓統計資料的更新頻率高於 AUTO_UPDATE_STATISTICS 開啟時的更新頻率，藉以改善查詢計劃，因而改善查詢效能。</span><span class="sxs-lookup"><span data-stu-id="31dc3-250">In some cases you can improve the query plan and therefore improve query performance by updating statistics more frequently than occur when AUTO_UPDATE_STATISTICS is on.</span></span> <span data-ttu-id="31dc3-251">您可以使用 UPDATE STATISTICS 陳述式或 sp_updatestats 預存程序來更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-251">You can update statistics with the UPDATE STATISTICS statement or the stored procedure sp_updatestats.</span></span>  
  
 <span data-ttu-id="31dc3-252">更新統計資料可確保查詢使用最新的統計資料進行編譯。</span><span class="sxs-lookup"><span data-stu-id="31dc3-252">Updating statistics ensures that queries compile with up-to-date statistics.</span></span> <span data-ttu-id="31dc3-253">不過，更新統計資料會導致查詢重新編譯。</span><span class="sxs-lookup"><span data-stu-id="31dc3-253">However, updating statistics causes queries to recompile.</span></span> <span data-ttu-id="31dc3-254">我們建議您不要太頻繁地更新統計資料，因為改善查詢計劃與重新編譯查詢所花費的時間之間具有效能權衡取捨。</span><span class="sxs-lookup"><span data-stu-id="31dc3-254">We recommend not updating statistics too frequently because there is a performance tradeoff between improving query plans and the time it takes to recompile queries.</span></span> <span data-ttu-id="31dc3-255">特定的權衡取捨完全取決於您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dc3-255">The specific tradeoffs depend on your application.</span></span>  
  
 <span data-ttu-id="31dc3-256">使用 UPDATE STATISTICS 或 sp_updatestats 來更新統計資料時，我們建議您將 AUTO_UPDATE_STATISTICS 保持設定為 ON，讓查詢最佳化工具能夠繼續例行地更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-256">When updating statistics with UPDATE STATISTICS or sp_updatestats, we recommend keeping AUTO_UPDATE_STATISTICS set to ON so that the query optimizer continues to routinely update statistics.</span></span> <span data-ttu-id="31dc3-257">如需如何針對資料行、索引、資料表或索引檢視表更新統計資料的詳細資訊，請參閱 [UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-257">For more information about how to update statistics on a column, an index, a table, or an indexed view, see [UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql).</span></span> <span data-ttu-id="31dc3-258">如需如何針對資料庫中所有使用者定義和內部資料表更新統計資料的詳細資訊，請參閱預存程序 [sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-258">For information about how to update statistics for all user-defined and internal tables in the database, see the stored procedure [sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql).</span></span>  
  
 <span data-ttu-id="31dc3-259">若要判斷上次更新統計資料的時間，請使用 [STATS_DATE](/sql/t-sql/functions/stats-date-transact-sql) 函數。</span><span class="sxs-lookup"><span data-stu-id="31dc3-259">To determine when statistics were last updated, use the [STATS_DATE](/sql/t-sql/functions/stats-date-transact-sql) function.</span></span>  
  
 <span data-ttu-id="31dc3-260">在下列狀況中，請考慮更新統計資料：</span><span class="sxs-lookup"><span data-stu-id="31dc3-260">Consider updating statistics for the following conditions:</span></span>  
  
-   <span data-ttu-id="31dc3-261">查詢執行時間很慢。</span><span class="sxs-lookup"><span data-stu-id="31dc3-261">Query execution times are slow.</span></span>  
  
-   <span data-ttu-id="31dc3-262">插入作業針對遞增或遞減索引鍵資料行進行。</span><span class="sxs-lookup"><span data-stu-id="31dc3-262">Insert operations occur on ascending or descending key columns.</span></span>  
  
-   <span data-ttu-id="31dc3-263">在維護作業之後。</span><span class="sxs-lookup"><span data-stu-id="31dc3-263">After maintenance operations.</span></span>  
  
### <a name="query-execution-times-are-slow"></a><span data-ttu-id="31dc3-264">查詢執行時間很慢</span><span class="sxs-lookup"><span data-stu-id="31dc3-264">Query Execution Times Are Slow</span></span>  
 <span data-ttu-id="31dc3-265">如果查詢回應時間很慢或無法預測，請先確定查詢具有最新的統計資料，然後再執行其他疑難排解步驟。</span><span class="sxs-lookup"><span data-stu-id="31dc3-265">If query response times are slow or unpredictable, ensure that queries have up-to-date statistics before performing additional troubleshooting steps.</span></span>  
  
### <a name="insert-operations-occur-on-ascending-or-descending-key-columns"></a><span data-ttu-id="31dc3-266">插入作業針對遞增或遞減索引鍵資料行進行</span><span class="sxs-lookup"><span data-stu-id="31dc3-266">Insert Operations Occur on Ascending or Descending Key Columns</span></span>  
 <span data-ttu-id="31dc3-267">遞增或遞減索引鍵資料行 (例如 IDENTITY 或即時時間戳記資料行) 之統計資料所需的統計資料更新頻率可能會比查詢最佳化工具所執行的更新頻率更高。</span><span class="sxs-lookup"><span data-stu-id="31dc3-267">Statistics on ascending or descending key columns, such as IDENTITY or real-time timestamp columns, might require more frequent statistics updates than the query optimizer performs.</span></span> <span data-ttu-id="31dc3-268">插入作業會將新的值附加至遞增或遞減資料行。</span><span class="sxs-lookup"><span data-stu-id="31dc3-268">Insert operations append new values to ascending or descending columns.</span></span> <span data-ttu-id="31dc3-269">所加入的資料列數目可能會太小，而無法觸發統計資料更新。</span><span class="sxs-lookup"><span data-stu-id="31dc3-269">The number of rows added might be too small to trigger a statistics update.</span></span> <span data-ttu-id="31dc3-270">如果統計資料不是最新的，而且查詢會從最近加入的資料列中選取，則目前的統計資料將不會具有這些新值的基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-270">If statistics are not up-to-date and queries select from the most recently added rows, the current statistics will not have cardinality estimates for these new values.</span></span> <span data-ttu-id="31dc3-271">這可能會導致基數估計值不精確以及查詢效能緩慢。</span><span class="sxs-lookup"><span data-stu-id="31dc3-271">This can result in inaccurate cardinality estimates and slow query performance.</span></span>  
  
 <span data-ttu-id="31dc3-272">例如，如果統計資料沒有更新成包含最新銷售訂單日期的基數估計值，則從最新銷售訂單日期中選取的查詢就會具有不精確的基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-272">For example, a query that selects from the most recent sales order dates will have inaccurate cardinality estimates if the statistics are not updated to include cardinality estimates for the most recent sales order dates.</span></span>  
  
### <a name="after-maintenance-operations"></a><span data-ttu-id="31dc3-273">在維護作業之後</span><span class="sxs-lookup"><span data-stu-id="31dc3-273">After Maintenance Operations</span></span>  
 <span data-ttu-id="31dc3-274">在執行變更資料分佈的維護程序 (例如截斷資料表或針對大部分的資料列執行大量插入) 之後，請考慮更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-274">Consider updating statistics after performing maintenance procedures that change the distribution of data, such as truncating a table or performing a bulk insert of a large percentage of the rows.</span></span> <span data-ttu-id="31dc3-275">這樣做可在查詢等候自動統計資料更新時，避免未來查詢處理產生延遲。</span><span class="sxs-lookup"><span data-stu-id="31dc3-275">This can avoid future delays in query processing while queries wait for automatic statistics updates.</span></span>  
  
 <span data-ttu-id="31dc3-276">重建、重組或重新組織索引等作業都不會變更資料的分佈。</span><span class="sxs-lookup"><span data-stu-id="31dc3-276">Operations such as rebuilding, defragmenting, or reorganizing an index do not change the distribution of data.</span></span> <span data-ttu-id="31dc3-277">因此，在執行 ALTER INDEX REBUILD、DBCC REINDEX、DBCC INDEXDEFRAG 或 ALTER INDEX REORGANIZE 作業之後，您不需要更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-277">Therefore, you do not need to update statistics after performing ALTER INDEX REBUILD, DBCC REINDEX, DBCC INDEXDEFRAG, or ALTER INDEX REORGANIZE operations.</span></span> <span data-ttu-id="31dc3-278">當您使用 ALTER INDEX REBUILD 或 DBCC DBREINDEX 來重建資料表或檢視表的索引時，查詢最佳化工具就會更新統計資料。不過，這種統計資料更新是重新建立索引的副產品。</span><span class="sxs-lookup"><span data-stu-id="31dc3-278">The query optimizer updates statistics when you rebuild an index on a table or view with ALTER INDEX REBUILD or DBCC DBREINDEX, however; this statistics update is a byproduct of re-creating the index.</span></span> <span data-ttu-id="31dc3-279">在 DBCC INDEXDEFRAG 或 ALTER INDEX REORGANIZE 作業之後，查詢最佳化工具則不會更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-279">The query optimizer does not update statistics after DBCC INDEXDEFRAG or ALTER INDEX REORGANIZE operations.</span></span>  
  
##  <a name="queries-that-use-statistics-effectively"></a><a name="DesignStatistics"></a><span data-ttu-id="31dc3-280">有效使用統計資料的查詢</span><span class="sxs-lookup"><span data-stu-id="31dc3-280">Queries That Use Statistics Effectively</span></span>  
 <span data-ttu-id="31dc3-281">某些查詢實作 (例如查詢述詞中的區域變數和複雜運算式) 可能會導致次佳的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-281">Certain query implementations, such as local variables and complex expressions in the query predicate, can lead to suboptimal query plans.</span></span> <span data-ttu-id="31dc3-282">不過，遵循查詢設計指導方針來有效使用統計資料有助於避免這種情況發生。</span><span class="sxs-lookup"><span data-stu-id="31dc3-282">Following query design guidelines for using statistics effectively can help to avoid this.</span></span> <span data-ttu-id="31dc3-283">如需查詢述詞的詳細資訊，請參閱[搜尋條件 &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-283">For more information about query predicates, see [Search Condition &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql).</span></span>  
  
 <span data-ttu-id="31dc3-284">您可以套用有效使用統計資料的查詢設計指導方針來改善查詢述詞中使用之運算式、變數和函數的「基數估計值」，藉以改善查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-284">You can improve query plans by applying query design guidelines that use statistics effectively to improve *cardinality estimates* for expressions, variables, and functions used in query predicates.</span></span> <span data-ttu-id="31dc3-285">當查詢最佳化工具不知道運算式、變數或函數的值時，它就不知道要在長條圖中查閱哪個值，因此無法從長條圖中擷取最佳的基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-285">When the query optimizer does not know the value of an expression, variable, or function, it does not know which value to lookup in the histogram and therefore cannot retrieve the best cardinality estimate from the histogram.</span></span> <span data-ttu-id="31dc3-286">此時，查詢最佳化工具會改為以長條圖中所有取樣資料列之每個相異值的平均資料列數目做為基數估計值的基礎。</span><span class="sxs-lookup"><span data-stu-id="31dc3-286">Instead, the query optimizer bases the cardinality estimate on the average number of rows per distinct value for all of the sampled rows in the histogram.</span></span> <span data-ttu-id="31dc3-287">這樣會導致次佳的基數估計值，而且可能會損及查詢效能。</span><span class="sxs-lookup"><span data-stu-id="31dc3-287">This leads to suboptimal cardinality estimates and can hurt query performance.</span></span>  
  
 <span data-ttu-id="31dc3-288">下列指導方針描述的是如何撰寫查詢，以便透過改善基數估計值，改善查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-288">The following guidelines describe how to write queries to improve query plans by improving cardinality estimates.</span></span>  
  
### <a name="improving-cardinality-estimates-for-expressions"></a><span data-ttu-id="31dc3-289">改善運算式的基數估計值</span><span class="sxs-lookup"><span data-stu-id="31dc3-289">Improving Cardinality Estimates for Expressions</span></span>  
 <span data-ttu-id="31dc3-290">若要改善運算式的基數估計值，請遵循下列指導方針：</span><span class="sxs-lookup"><span data-stu-id="31dc3-290">To improve cardinality estimates for expressions, follow these guidelines:</span></span>  
  
-   <span data-ttu-id="31dc3-291">您應該盡可能簡化含有常數的運算式。</span><span class="sxs-lookup"><span data-stu-id="31dc3-291">Whenever possible, simplify expressions with constants in them.</span></span> <span data-ttu-id="31dc3-292">在判斷基數估計值之前，查詢最佳化工具不會評估包含常數的所有函數和運算式。</span><span class="sxs-lookup"><span data-stu-id="31dc3-292">The query optimizer does not evaluate all functions and expressions containing constants prior to determining cardinality estimates.</span></span> <span data-ttu-id="31dc3-293">例如，請簡化運算式 ABS(`-100) to 100`。</span><span class="sxs-lookup"><span data-stu-id="31dc3-293">For example, simplify the expression ABS(`-100) to 100`.</span></span>  
  
-   <span data-ttu-id="31dc3-294">如果運算式使用多個變數，請考慮建立運算式的計算資料行，然後再針對計算資料行建立統計資料或索引。</span><span class="sxs-lookup"><span data-stu-id="31dc3-294">If the expression uses multiple variables, consider creating a computed column for the expression and then create statistics or an index on the computed column.</span></span> <span data-ttu-id="31dc3-295">例如，如果您建立了 `WHERE PRICE + Tax > 100` 運算式的計算資料行， `Price + Tax`查詢述詞可能會具有較佳的基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-295">For example, the query predicate `WHERE PRICE + Tax > 100` might have a better cardinality estimate if you create a computed column for the expression `Price + Tax`.</span></span>  
  
### <a name="improving-cardinality-estimates-for-variables-and-functions"></a><span data-ttu-id="31dc3-296">改善變數和函數的基數估計值</span><span class="sxs-lookup"><span data-stu-id="31dc3-296">Improving Cardinality Estimates for Variables and Functions</span></span>  
 <span data-ttu-id="31dc3-297">若要改善變數和函數的基數估計值，請遵循下列指導方針：</span><span class="sxs-lookup"><span data-stu-id="31dc3-297">To improve the cardinality estimates for variables and functions, follow these guidelines:</span></span>  
  
-   <span data-ttu-id="31dc3-298">如果查詢述詞使用區域變數，請考慮將查詢重新撰寫成使用參數而非區域變數。</span><span class="sxs-lookup"><span data-stu-id="31dc3-298">If the query predicate uses a local variable, consider rewriting the query to use a parameter instead of a local variable.</span></span> <span data-ttu-id="31dc3-299">當查詢最佳化工具建立查詢執行計畫時，無法得知區域變數的值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-299">The value of a local variable is not known when the query optimizer creates the query execution plan.</span></span> <span data-ttu-id="31dc3-300">當查詢使用參數時，查詢最佳化工具就會使用傳遞給預存程序之第一個實際參數值的基數估計值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-300">When a query uses a parameter, the query optimizer uses the cardinality estimate for the first actual parameter value that is passed to the stored procedure.</span></span>  
  
-   <span data-ttu-id="31dc3-301">請考慮使用標準資料表或暫存資料表來保存多重陳述式資料表值函式的結果。</span><span class="sxs-lookup"><span data-stu-id="31dc3-301">Consider using a standard table or temporary table to hold the results of multi-statement table-valued functions.</span></span> <span data-ttu-id="31dc3-302">查詢最佳化工具不會針對多重陳述式資料表值函式建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-302">The query optimizer does not create statistics for multi-statement table-valued functions.</span></span> <span data-ttu-id="31dc3-303">透過這種方法，查詢最佳化工具就可以建立資料表資料行的統計資料，然後使用它們來建立較佳的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-303">With this approach the query optimizer can create statistics on the table columns and use them to create a better query plan.</span></span>  
  
-   <span data-ttu-id="31dc3-304">請考慮使用標準資料表或暫存資料表當做資料表變數的取代項目。</span><span class="sxs-lookup"><span data-stu-id="31dc3-304">Consider using a standard table or temporary table as a replacement for table variables.</span></span> <span data-ttu-id="31dc3-305">查詢最佳化工具不會針對資料表變數建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dc3-305">The query optimizer does not create statistics for table variables.</span></span> <span data-ttu-id="31dc3-306">透過這種方法，查詢最佳化工具就可以建立資料表資料行的統計資料，然後使用它們來建立較佳的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-306">With this approach the query optimizer can create statistics on the table columns and use them to create a better query plan.</span></span> <span data-ttu-id="31dc3-307">當您在判斷要使用暫存資料表或資料表變數時，存在權衡取捨。在預存程序中使用的資料表變數會讓預存程序重新編譯的次數比暫存資料表更少。</span><span class="sxs-lookup"><span data-stu-id="31dc3-307">There are tradeoffs in determining whether to use a temporary table or a table variable; Table variables used in stored procedures cause fewer recompilations of the stored procedure than temporary tables.</span></span> <span data-ttu-id="31dc3-308">根據應用程式而定，使用暫存資料表來取代資料表變數可能不會改善效能。</span><span class="sxs-lookup"><span data-stu-id="31dc3-308">Depending on the application, using a temporary table instead of a table variable might not improve performance.</span></span>  
  
-   <span data-ttu-id="31dc3-309">如果預存程序包含使用傳入參數的查詢，請避免在查詢中使用之前，變更預存程序中的參數值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-309">If a stored procedure contains a query that uses a passed-in parameter, avoid changing the parameter value within the stored procedure before using it in the query.</span></span> <span data-ttu-id="31dc3-310">查詢的基數估計值是以傳入參數而非更新的值為基礎。</span><span class="sxs-lookup"><span data-stu-id="31dc3-310">The cardinality estimates for the query are based on the passed-in parameter value and not the updated value.</span></span> <span data-ttu-id="31dc3-311">若要避免變更參數值，您可以將查詢重新撰寫成使用兩個預存程序。</span><span class="sxs-lookup"><span data-stu-id="31dc3-311">To avoid changing the parameter value, you can rewrite the query to use two stored procedures.</span></span>  
  
     <span data-ttu-id="31dc3-312">例如，當 `Sales.GetRecentSales` 時，下列預存程序 `@date` 就會變更 `@date is NULL`參數的值。</span><span class="sxs-lookup"><span data-stu-id="31dc3-312">For example, the following stored procedure `Sales.GetRecentSales` changes the value of the parameter `@date` when `@date is NULL`.</span></span>  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
    AS BEGIN  
        IF @date is NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
     <span data-ttu-id="31dc3-313">如果預存程序 `Sales.GetRecentSales` 的第一次呼叫傳遞 NULL 給 `@date` 參數，查詢最佳化工具就會使用 `@date = NULL` 的基數估計值來編譯此預存程序，即使沒有使用 `@date = NULL`來呼叫查詢述詞也一樣。</span><span class="sxs-lookup"><span data-stu-id="31dc3-313">If the first call to the stored procedure `Sales.GetRecentSales` passes a NULL for the `@date` parameter, the query optimizer will compile the stored procedure with the cardinality estimate for `@date = NULL` even though the query predicate is not called with `@date = NULL`.</span></span> <span data-ttu-id="31dc3-314">這個基數估計值可能會與實際查詢結果中的資料列數目具有大幅差異。</span><span class="sxs-lookup"><span data-stu-id="31dc3-314">This cardinality estimate might be significantly different than the number of rows in the actual query result.</span></span> <span data-ttu-id="31dc3-315">因此，查詢最佳化工具可能會選擇次佳查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="31dc3-315">As a result, the query optimizer might choose a suboptimal query plan.</span></span> <span data-ttu-id="31dc3-316">為了協助避免這種情況發生，您可以將此預存程序重新撰寫成兩個程序，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31dc3-316">To help avoid this, you can rewrite the stored procedure into two procedures as follows:</span></span>  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNullRecentSales (@date datetime)  
    AS BEGIN  
        IF @date is NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        EXEC Sales.GetNonNullRecentSales @date;  
    END  
    GO  
    IF OBJECT_ID ( 'Sales.GetNonNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNonNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNonNullRecentSales (@date datetime)  
    AS BEGIN  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
### <a name="improving-cardinality-estimates-with-query-hints"></a><span data-ttu-id="31dc3-317">使用查詢提示來改善基數估計值</span><span class="sxs-lookup"><span data-stu-id="31dc3-317">Improving Cardinality Estimates with Query Hints</span></span>  
 <span data-ttu-id="31dc3-318">若要改善區域變數的基數估計值，您可以使用 OPTIMIZE FOR 或 OPTIMIZE FOR UNKNOWN 查詢提示搭配 RECOMPILE。</span><span class="sxs-lookup"><span data-stu-id="31dc3-318">To improve cardinality estimates for local variables, you can use the OPTIMIZE FOR or OPTIMIZE FOR UNKNOWN query hints with RECOMPILE.</span></span> <span data-ttu-id="31dc3-319">如需詳細資訊，請參閱[查詢提示 &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-319">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
 <span data-ttu-id="31dc3-320">對於某些應用程式而言，每次執行查詢都重新編譯查詢可能會花費太多時間。</span><span class="sxs-lookup"><span data-stu-id="31dc3-320">For some applications, recompiling the query each time it executes might take too much time.</span></span> <span data-ttu-id="31dc3-321">即使您沒有使用 RECOMPILE 選項，OPTIMIZER FOR 查詢提示仍然有所幫助。</span><span class="sxs-lookup"><span data-stu-id="31dc3-321">The OPTIMIZER FOR query hint can help even if you don't use the RECOMPILE option.</span></span> <span data-ttu-id="31dc3-322">例如，您可以將 OPTIMIZER FOR 選項加入至預存程序 Sales.GetRecentSales，以便指定特定日期。</span><span class="sxs-lookup"><span data-stu-id="31dc3-322">For example, you could add an OPTIMIZER FOR option to the stored procedure Sales.GetRecentSales to specify a specific date.</span></span> <span data-ttu-id="31dc3-323">下列範例會將 OPTIMIZE FOR 選項加入至 Sales.GetRecentSales 程序。</span><span class="sxs-lookup"><span data-stu-id="31dc3-323">The following example adds the OPTIMIZE FOR option to the Sales.GetRecentSales procedure.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
    DROP PROCEDURE Sales.GetRecentSales;  
GO  
CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
AS BEGIN  
    IF @date is NULL  
        SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
    SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
    WHERE h.SalesOrderID = d.SalesOrderID  
    AND h.OrderDate > @date  
    OPTION ( OPTIMIZE FOR ( @date = '2004-05-01 00:00:00.000'))  
END;  
GO  
```  
  
### <a name="improving-cardinality-estimates-with-plan-guides"></a><span data-ttu-id="31dc3-324">使用計畫指南來改善基數估計值</span><span class="sxs-lookup"><span data-stu-id="31dc3-324">Improving Cardinality Estimates with Plan Guides</span></span>  
 <span data-ttu-id="31dc3-325">對於某些應用程式而言，查詢設計指導方針可能不適用，因為您無法變更查詢或者使用 RECOMPILE 查詢提示可能會導致重新編譯次數太多。</span><span class="sxs-lookup"><span data-stu-id="31dc3-325">For some applications, query design guidelines might not apply because you cannot change the query or using the RECOMPILE query hint might be cause too many recompiles.</span></span> <span data-ttu-id="31dc3-326">此時，您可以使用計畫指南來指定其他提示 (例如 USE PLAN)，以便控制查詢的行為，同時向應用程式廠商調查應用程式變更。</span><span class="sxs-lookup"><span data-stu-id="31dc3-326">You can use plan guides to specify other hints, such as USE PLAN, to control the behavior of the query while investigating application changes with the application vendor.</span></span> <span data-ttu-id="31dc3-327">如需有關計畫指南的詳細資訊，請參閱 [計畫指南](../performance/plan-guides.md)。</span><span class="sxs-lookup"><span data-stu-id="31dc3-327">For more information about plan guides, see [Plan Guides](../performance/plan-guides.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="31dc3-328">另請參閱</span><span class="sxs-lookup"><span data-stu-id="31dc3-328">See Also</span></span>  
 <span data-ttu-id="31dc3-329">[CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="31dc3-329">[CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql) </span></span>  
 <span data-ttu-id="31dc3-330">[UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="31dc3-330">[UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql) </span></span>  
 <span data-ttu-id="31dc3-331">[sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="31dc3-331">[sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql) </span></span>  
 <span data-ttu-id="31dc3-332">[DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="31dc3-332">[DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql) </span></span>  
 <span data-ttu-id="31dc3-333">[ALTER DATABASE SET 選項 &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options) </span><span class="sxs-lookup"><span data-stu-id="31dc3-333">[ALTER DATABASE SET Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options) </span></span>  
 <span data-ttu-id="31dc3-334">[DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="31dc3-334">[DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) </span></span>  
 <span data-ttu-id="31dc3-335">[CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="31dc3-335">[CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql) </span></span>  
 <span data-ttu-id="31dc3-336">[ALTER INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-index-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="31dc3-336">[ALTER INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-index-transact-sql) </span></span>  
 [<span data-ttu-id="31dc3-337">建立篩選的索引</span><span class="sxs-lookup"><span data-stu-id="31dc3-337">Create Filtered Indexes</span></span>](../indexes/create-filtered-indexes.md)  
