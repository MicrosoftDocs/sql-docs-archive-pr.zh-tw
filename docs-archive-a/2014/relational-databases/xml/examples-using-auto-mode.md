---
title: 範例：使用 AUTO 模式 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- AUTO FOR XML mode, examples
ms.assetid: 11e8d0e4-df8a-46f8-aa21-9602d4f26cad
author: rothja
ms.author: jroth
ms.openlocfilehash: b457bca6b7c25b9822e3dab2eba5f5cdb04b83e6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87585170"
---
# <a name="examples-using-auto-mode"></a><span data-ttu-id="68640-102">範例：使用 AUTO 模式</span><span class="sxs-lookup"><span data-stu-id="68640-102">Examples: Using AUTO Mode</span></span>
  <span data-ttu-id="68640-103">下列範例說明 AUTO 模式的用法。</span><span class="sxs-lookup"><span data-stu-id="68640-103">The following examples illustrate the use of AUTO mode.</span></span> <span data-ttu-id="68640-104">這些查詢中有許多是針對自行車製造說明的 XML 文件來指定的，而這些文件儲存在 [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] 範例資料庫中 ProductModel 資料表的 Instructions 資料行中。</span><span class="sxs-lookup"><span data-stu-id="68640-104">Many of these queries are specified against bicycle manufacturing instructions XML documents that are stored in the Instructions column of the ProductModel table in the [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] sample database.</span></span>  
  
## <a name="example-retrieving-customer-order-and-order-detail-information"></a><span data-ttu-id="68640-105">範例：擷取客戶、訂單及訂單詳細資訊</span><span class="sxs-lookup"><span data-stu-id="68640-105">Example: Retrieving customer, order, and order detail information</span></span>  
 <span data-ttu-id="68640-106">此查詢會擷取特定客戶的客戶、訂單及訂單詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="68640-106">This query retrieves customer, order, and order detail information for a specific customer.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT Cust.CustomerID,   
       OrderHeader.CustomerID,  
       OrderHeader.SalesOrderID,   
       Detail.SalesOrderID, Detail.LineTotal, Detail.ProductID,   
       Product.Name,  
       Detail.OrderQty  
FROM Sales.Customer AS Cust  
INNER JOIN Sales.SalesOrderHeader AS OrderHeader   
    ON Cust.CustomerID = OrderHeader.CustomerID  
INNER JOIN Sales.SalesOrderDetail AS Detail  
    ON OrderHeader.SalesOrderID = Detail.SalesOrderID  
INNER JOIN Production.Product AS Product  
    ON Product.ProductID = Detail.ProductID  
WHERE Cust.CustomerID IN (29672, 29734)  
ORDER BY OrderHeader.CustomerID,  
         OrderHeader.SalesOrderID  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="68640-107">因為此查詢會識別 `Cust`、 `OrderHeader`、 `Detail`及 `Product` 資料表別名，所以 `AUTO` 模式會產生對應的元素。</span><span class="sxs-lookup"><span data-stu-id="68640-107">Because the query identifies, `Cust`, `OrderHeader`, `Detail`, and `Product` table aliases, corresponding elements are generated by the `AUTO` mode.</span></span> <span data-ttu-id="68640-108">而 `SELECT` 子句中指定之資料行所識別的資料表順序，會決定這些元素的階層。</span><span class="sxs-lookup"><span data-stu-id="68640-108">Again, the order in which tables are identified by the columns specified in the `SELECT` clause determine the hierarchy of these elements.</span></span>  
  
 <span data-ttu-id="68640-109">以下是部份結果。</span><span class="sxs-lookup"><span data-stu-id="68640-109">This is the partial result.</span></span>  
  
 `<Cust CustomerID="29672">`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="43660">`  
  
 `<Detail SalesOrderID="43660" LineTotal="874.794000" ProductID="758" OrderQty="1">`  
  
 `<Product Name="Road-450 Red, 52" />`  
  
 `</Detail>`  
  
 `<Detail SalesOrderID="43660" LineTotal="419.458900" ProductID="762" OrderQty="1">`  
  
 `<Product Name="Road-650 Red, 44" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="47660">`  
  
 `<Detail SalesOrderID="47660" LineTotal="469.794000" ProductID="765" OrderQty="1">`  
  
 `<Product Name="Road-650 Black, 58" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="49857">`  
  
 `<Detail SalesOrderID="49857" LineTotal="44.994000" ProductID="852" OrderQty="1">`  
  
 `<Product Name="Women's Tights, S" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `...`  
  
 `</Cust>`  
  
## <a name="example-specifying-group-by-and-aggregate-functions"></a><span data-ttu-id="68640-110">範例：指定 GROUP BY 及彙總函式</span><span class="sxs-lookup"><span data-stu-id="68640-110">Example: Specifying GROUP BY and aggregate functions</span></span>  
 <span data-ttu-id="68640-111">下列查詢會傳回個別的客戶識別碼，以及客戶所要求的訂單數量。</span><span class="sxs-lookup"><span data-stu-id="68640-111">The following query returns individual customer IDs and the number of orders that the customer has requested.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT C.CustomerID, COUNT(*) AS NoOfOrders  
FROM Sales.Customer AS C  
INNER JOIN Sales.SalesOrderHeader AS SOH  
On C.CustomerID = SOH.CustomerID  
GROUP BY C.CustomerID  
FOR XML AUTO;This is the partial result:  
```  
  
 `<I CustomerID="11000" NoOfOrders="3" />`  
  
 `<I CustomerID="11001" NoOfOrders="3" />`  
  
 `...`  
  
## <a name="example-specifying-computed-columns-in-auto-mode"></a><span data-ttu-id="68640-112">範例：在 AUTO 模式中指定計算資料行</span><span class="sxs-lookup"><span data-stu-id="68640-112">Example: Specifying computed columns in AUTO mode</span></span>  
 <span data-ttu-id="68640-113">此查詢會傳回串連的個別客戶名稱及訂單資訊。</span><span class="sxs-lookup"><span data-stu-id="68640-113">This query returns concatenated individual customer names and the order information.</span></span> <span data-ttu-id="68640-114">因為計算資料行指派給此時所發現的最內層 (在此範例中為 <`SOH`> 元素)，</span><span class="sxs-lookup"><span data-stu-id="68640-114">Because the computed column is assigned to the innermost level encountered at that point, the <`SOH`> element in this example.</span></span> <span data-ttu-id="68640-115">因此在結果中，串連的客戶名稱會被當成 <`SOH`> 元素的屬性來加入。</span><span class="sxs-lookup"><span data-stu-id="68640-115">The concatenated customer names are added as attributes of the <`SOH`> element in the result.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT P.FirstName + ' ' + P.LastName AS Name,  
       SOH.SalesOrderID  
FROM Sales.Customer AS C  
INNER JOIN Sales.SalesOrderHeader AS SOH  
    ON  C.CustomerID = SOH.CustomerID  
INNER JOIN Person.Person AS P  
    ON P.BusinessEntityID = C.PersonID  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="68640-116">以下是部份結果：</span><span class="sxs-lookup"><span data-stu-id="68640-116">This is the partial result:</span></span>  
  
```  
<SOH Name="Jon Yang" SalesOrderID="43793" />  
<SOH Name="Eugene Huang" SalesOrderID="43767" />  
```  
  
 <span data-ttu-id="68640-117">若要擷取 <`IndividualCustomer`> 元素 (而其 `Name` 屬性中，包含每個銷售訂單的標頭資訊做為子元素)，使用子 Select 來重寫查詢。</span><span class="sxs-lookup"><span data-stu-id="68640-117">To retrieve the <`IndividualCustomer`> elements having the `Name` attribute that contains each sales order header information as a subelement, the query is rewritten using a sub select.</span></span> <span data-ttu-id="68640-118">內部的 Select 會建立暫存的 `IndividualCustomer` 資料表，且其中的計算資料行含有個別客戶的名稱。</span><span class="sxs-lookup"><span data-stu-id="68640-118">The inner select creates a temporary `IndividualCustomer` table with the computed column that contains the names of the individual customers.</span></span> <span data-ttu-id="68640-119">接著此資料表會與 `SalesOrderHeader` 資料表聯結，以取得結果。</span><span class="sxs-lookup"><span data-stu-id="68640-119">This table is then joined to the `SalesOrderHeader` table to obtain the result.</span></span>  
  
 <span data-ttu-id="68640-120">請注意， `Sales.Customer` 資料表會儲存個別客戶的資訊，包括該客戶的 `PersonID` 值。</span><span class="sxs-lookup"><span data-stu-id="68640-120">Note that the `Sales.Customer` table stores individual customer information, including the `PersonID` value for that customer.</span></span> <span data-ttu-id="68640-121">然後再使用此 `PersonID` ，在 `Person.Person` 資料表中尋找連絡人名稱。</span><span class="sxs-lookup"><span data-stu-id="68640-121">This `PersonID` is then used to find the contact name from the `Person.Person` table.</span></span>  
  
```  
SELECT IndividualCustomer.Name, SOH.SalesOrderID  
FROM (SELECT FirstName+ ' '+LastName AS Name, C.PersonID, C.CustomerID  
      FROM Sales.Customer AS C, Person.Person AS P  
      WHERE C.PersonID = P.BusinessEntityID) AS IndividualCustomer  
LEFT OUTER JOIN  Sales.SalesOrderHeader AS SOH  
   ON IndividualCustomer.CustomerID = SOH.CustomerID  
ORDER BY IndividualCustomer.CustomerID, SOH.CustomerIDFOR XML AUTO;  
```  
  
 <span data-ttu-id="68640-122">以下是部份結果：</span><span class="sxs-lookup"><span data-stu-id="68640-122">This is the partial result:</span></span>  
  
 `<IndividualCustomer Name="Jon Yang">`  
  
 `<SOH SalesOrderID="43793" />`  
  
 `<SOH SalesOrderID="51522" />`  
  
 `<SOH SalesOrderID="57418" />`  
  
 `</IndividualCustomer>`  
  
 `...`  
  
 `...`  
  
## <a name="example-returning-binary-data"></a><span data-ttu-id="68640-123">範例：傳回二進位資料</span><span class="sxs-lookup"><span data-stu-id="68640-123">Example: Returning binary data</span></span>  
 <span data-ttu-id="68640-124">此查詢會從 `ProductPhoto` 資料表傳回產品相片。</span><span class="sxs-lookup"><span data-stu-id="68640-124">This query returns a product photo from the `ProductPhoto` table.</span></span> <span data-ttu-id="68640-125">`ThumbNailPhoto` 是 `ProductPhoto` 資料表中的 `varbinary(max)` 資料行。</span><span class="sxs-lookup"><span data-stu-id="68640-125">`ThumbNailPhoto` is an `varbinary(max)` column in the `ProductPhoto` table.</span></span> <span data-ttu-id="68640-126">依預設， `AUTO` 模式會傳回二進位資料的參考，此為執行查詢所在之資料庫虛擬根目錄的相對 URL。</span><span class="sxs-lookup"><span data-stu-id="68640-126">By default, `AUTO` mode returns to the binary data a reference that is a relative URL to the virtual root of the database where the query is executed.</span></span> <span data-ttu-id="68640-127">您必須指定 `ProductPhotoID` 索引鍵屬性來識別影像。</span><span class="sxs-lookup"><span data-stu-id="68640-127">The `ProductPhotoID` key attribute must be specified to identify the image.</span></span> <span data-ttu-id="68640-128">如同此範例所說明，在擷取影像參考時，也必須在 `SELECT` 子句中指定資料表的主索引鍵，以識別具唯一性的資料列。</span><span class="sxs-lookup"><span data-stu-id="68640-128">In retrieving an image reference as illustrated in this example, the primary key of the table must also be specified in the `SELECT` clause to uniquely identify a row.</span></span>  
  
```  
SELECT ProductPhotoID, ThumbNailPhoto  
FROM   Production.ProductPhoto   
WHERE ProductPhotoID=70  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="68640-129">以下是結果：</span><span class="sxs-lookup"><span data-stu-id="68640-129">This is the result:</span></span>  
  
 `-- result`  
  
 `<Production.ProductPhoto`  
  
 `ProductPhotoID="70"`  
  
 `ThumbNailPhoto= "dbobject/Production.ProductPhoto[@ProductPhotoID='70']/@ThumbNailPhoto" />`  
  
 <span data-ttu-id="68640-130">同樣的查詢，可以使用 `BINARY BASE64` 選項執行。</span><span class="sxs-lookup"><span data-stu-id="68640-130">The same query is executed with the `BINARY BASE64` option.</span></span> <span data-ttu-id="68640-131">該查詢會以 Base64 編碼格式傳回二進位資料。</span><span class="sxs-lookup"><span data-stu-id="68640-131">The query returns the binary data in base64-encoded format.</span></span>  
  
```  
SELECT ProductPhotoID, ThumbNailPhoto  
FROM   Production.ProductPhoto   
WHERE ProductPhotoID=70  
FOR XML AUTO, BINARY BASE64;  
```  
  
 <span data-ttu-id="68640-132">以下是結果：</span><span class="sxs-lookup"><span data-stu-id="68640-132">This is the result:</span></span>  
  
 `-- result`  
  
 `<Production.ProductPhoto ProductPhotoID="70" ThumbNailPhoto="Base64 encoded photo" />`  
  
 <span data-ttu-id="68640-133">依預設，當您使用 AUTO 模式來擷取二進位資料時，將會傳回一個參考 (此為執行查詢所在之資料庫虛擬根目錄的相對 URL)，而不會傳回二進位資料。</span><span class="sxs-lookup"><span data-stu-id="68640-133">By default, when you use AUTO mode to retrieve binary data, a reference to a relative URL to the virtual root of the database where the query was executed will be returned instead of the binary data.</span></span> <span data-ttu-id="68640-134">若沒有指定 BINARY BASE64 選項，就會發生這種情形。</span><span class="sxs-lookup"><span data-stu-id="68640-134">This will occur if the BINARY BASE64 option is not specified.</span></span>  
  
 <span data-ttu-id="68640-135">當 AUTO 模式針對不區分大小寫之資料庫中的二進位資料，傳回其 URL 參考，而查詢中所指定的資料表或資料行名稱並不符合資料庫中的資料表或資料行名稱時，查詢仍可執行。</span><span class="sxs-lookup"><span data-stu-id="68640-135">When AUTO mode returns a URL reference to the binary data in case-insensitive databases where a table or column name specified in the query does not match the table or column name in the database, the query executes.</span></span> <span data-ttu-id="68640-136">不過，參考中所傳回的大小寫會不一致。</span><span class="sxs-lookup"><span data-stu-id="68640-136">However, the case returned in the reference will not be consistent.</span></span> <span data-ttu-id="68640-137">例如：</span><span class="sxs-lookup"><span data-stu-id="68640-137">For example:</span></span>  
  
```  
SELECT ProductPhotoID, ThumbnailPhoto  
FROM   Production.ProductPhoto   
WHERE  ProductPhotoID=70  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="68640-138">以下是結果：</span><span class="sxs-lookup"><span data-stu-id="68640-138">This is the result:</span></span>  
  
 `<Production.PRODUCTPHOTO`  
  
 `PRODUCTPHOTOID="70"`  
  
 `THUMBNAILPHOTO= "dbobject/Production.PRODUCTPHOTO[@ProductPhotoID='70']/@ThumbNailPhoto" />`  
  
 <span data-ttu-id="68640-139">這可能會是一個問題，尤其是在針對區分大小寫的資料庫執行 dbobject 查詢時。</span><span class="sxs-lookup"><span data-stu-id="68640-139">This can be a problem particularly when dbobject queries are executed against a case sensitive database.</span></span> <span data-ttu-id="68640-140">為了避免發生這個問題，查詢中指定之資料表或資料行名稱的大小寫，應該要與資料庫中資料表或資料行名稱的大小寫相符。</span><span class="sxs-lookup"><span data-stu-id="68640-140">To avoid this, the case of the table or column name that is specified in the queries should match the case of the table or column name in the database.</span></span>  
  
## <a name="example-understanding-the-encoding"></a><span data-ttu-id="68640-141">範例：了解編碼方式</span><span class="sxs-lookup"><span data-stu-id="68640-141">Example: Understanding the encoding</span></span>  
 <span data-ttu-id="68640-142">此範例顯示結果中所出現的各種編碼方式。</span><span class="sxs-lookup"><span data-stu-id="68640-142">This example shows the various encoding that occurs in the result.</span></span>  
  
 <span data-ttu-id="68640-143">建立下述資料表：</span><span class="sxs-lookup"><span data-stu-id="68640-143">Create this table:</span></span>  
  
```  
CREATE TABLE [Special Chars] (Col1 char(1) primary key, [Col#&2] varbinary(50));  
```  
  
 <span data-ttu-id="68640-144">將下列資料加入資料表：</span><span class="sxs-lookup"><span data-stu-id="68640-144">Add the following data to the table:</span></span>  
  
```  
INSERT INTO [Special Chars] VALUES ('&', 0x20), ('#', 0x20);  
```  
  
 <span data-ttu-id="68640-145">此查詢傳回來自於該資料表的資料。</span><span class="sxs-lookup"><span data-stu-id="68640-145">This query returns the data from the table.</span></span> <span data-ttu-id="68640-146">並已指定 FOR XML AUTO 模式。</span><span class="sxs-lookup"><span data-stu-id="68640-146">The FOR XML AUTO mode is specified.</span></span> <span data-ttu-id="68640-147">二進位資料是以參考來傳回。</span><span class="sxs-lookup"><span data-stu-id="68640-147">Binary data is returned as a reference.</span></span>  
  
```  
SELECT * FROM [Special Chars] FOR XML AUTO;  
```  
  
 <span data-ttu-id="68640-148">以下是結果：</span><span class="sxs-lookup"><span data-stu-id="68640-148">This is the result:</span></span>  
  
 `<Special_x0020_Chars`  
  
 `Col1="#"`  
  
 `Col_x0023__x0026_2="dbobject/Special_x0020_Chars[@Col1='#']/@Col_x0023__x0026_2"`  
  
 `/>`  
  
 `<Special_x0020_Chars`  
  
 `Col1="&"`  
  
 `Col_x0023__x0026_2="dbobject/Special_x0020_Chars[@Col1='&']/@Col_x0023__x0026_2"`  
  
 `/>`  
  
 <span data-ttu-id="68640-149">下述處理序是用來對結果中的特殊字元進行編碼：</span><span class="sxs-lookup"><span data-stu-id="68640-149">This is the process for encoding special characters in the result:</span></span>  
  
-   <span data-ttu-id="68640-150">在查詢結果中，所傳回之元素及屬性名稱中的 XML 與 URL 特殊字元，是使用對應之 Unicode 字元的十六進位值來進行編碼。</span><span class="sxs-lookup"><span data-stu-id="68640-150">In the query result, the special XML and URL characters in the element and attribute names that are returned are encoded by using the hexadecimal value of the corresponding Unicode character.</span></span> <span data-ttu-id="68640-151">在上述結果中，元素名稱 <`Special Chars`> 在傳回時會變成 <`Special_x0020_Chars`>。</span><span class="sxs-lookup"><span data-stu-id="68640-151">In the previous result, the element name <`Special Chars`> is returned as <`Special_x0020_Chars`>.</span></span> <span data-ttu-id="68640-152">屬性名稱 <`Col#&2`> 會以 <`Col_x0023__x0026_2`> 形式傳回。</span><span class="sxs-lookup"><span data-stu-id="68640-152">The attribute name <`Col#&2`> is returned as <`Col_x0023__x0026_2`>.</span></span> <span data-ttu-id="68640-153">XML 和 URL 特殊字元都會加以編碼。</span><span class="sxs-lookup"><span data-stu-id="68640-153">Both XML and URL special characters are encoded.</span></span>  
  
-   <span data-ttu-id="68640-154">如果項目或屬性值包含五種標準 XML 字元實體 ('、""、\<, > 及 &) 的其中任何一種，則一律都會使用 XML 字元編碼方式來編碼這些 XML 特殊字元。</span><span class="sxs-lookup"><span data-stu-id="68640-154">If the values of the elements or attribute contain any of the five standard XML character entities (', "", \<, >, and &), these special XML characters are always encoded using XML character encoding.</span></span> <span data-ttu-id="68640-155">在上述結果中，<`Col1`> 屬性值中的 `&` 值會編碼成 `&`。</span><span class="sxs-lookup"><span data-stu-id="68640-155">In the previous result, the value `&` in the value of attribute <`Col1`> is encoded as `&`.</span></span> <span data-ttu-id="68640-156">不過，# 字元仍保留為 #，因為它是有效的 XML 字元，並非特殊 XML 字元。</span><span class="sxs-lookup"><span data-stu-id="68640-156">However, the # character remains #, because it is a valid XML character and not a special XML character.</span></span>  
  
-   <span data-ttu-id="68640-157">如果元素或屬性的值包含任何於 URL 中是具有特殊意義的 URL 特殊字元，則只有位於 DBOBJECT URL 值內且當特殊字元為資料表或資料行名稱的一部分時，才會對這些字元進行編碼。</span><span class="sxs-lookup"><span data-stu-id="68640-157">If the values of the elements or attributes contain any special URL characters that have special meaning in the URL, they are encoded only in the DBOBJECT URL value and are encoded only when the special character is part of a table or column name.</span></span> <span data-ttu-id="68640-158">在結果中，屬於資料表名稱 `#` 一部分的 `Col#&2` 字元會被編碼成 `_x0023_ in the DBOJBECT URL`。</span><span class="sxs-lookup"><span data-stu-id="68640-158">In the result, the character `#` that is part of table name `Col#&2` is encoded as `_x0023_ in the DBOJBECT URL`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="68640-159">另請參閱</span><span class="sxs-lookup"><span data-stu-id="68640-159">See Also</span></span>  
 [<span data-ttu-id="68640-160">搭配 FOR XML 使用 AUTO 模式</span><span class="sxs-lookup"><span data-stu-id="68640-160">Use AUTO Mode with FOR XML</span></span>](use-auto-mode-with-for-xml.md)  
  
  
