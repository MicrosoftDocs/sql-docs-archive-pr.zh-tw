---
title: OPENXML (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- ColPattern [XML in SQL Server]
- OPENXML statement, about OPENXML statement
- writing XML, OPENXML statement
- OPENXML statement, querying XML
- attribute-centric mapping
- SELECT statement [SQL Server], OPENXML keyword
- column patterns [XML in SQL Server]
- row patterns [XML in SQL Server]
- rowpattern [XML in SQL Server]
- queries [XML in SQL Server], OPENXML statement
- XML [SQL Server], OPENXML statement
- element-centric mapping [SQL Server]
ms.assetid: 060126fc-ed0f-478f-830a-08e418d410dc
author: rothja
ms.author: jroth
ms.openlocfilehash: 1849029e6654fcd629499cceeff9957e5389370f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87710405"
---
# <a name="openxml-sql-server"></a><span data-ttu-id="4c069-102">OPENXML (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="4c069-102">OPENXML (SQL Server)</span></span>
  <span data-ttu-id="4c069-103">OPENXML 是 [!INCLUDE[tsql](../../includes/tsql-md.md)] 關鍵字，可透過類似資料表或檢視表的記憶體中 XML 文件，提供資料列集。</span><span class="sxs-lookup"><span data-stu-id="4c069-103">OPENXML, a [!INCLUDE[tsql](../../includes/tsql-md.md)] keyword, provides a rowset over in-memory XML documents that is similar to a table or a view.</span></span> <span data-ttu-id="4c069-104">OPENXML 允許對 XML 資料的存取像是關聯式資料列集一樣。</span><span class="sxs-lookup"><span data-stu-id="4c069-104">OPENXML allows access to XML data as though it is a relational rowset.</span></span> <span data-ttu-id="4c069-105">其做法是，提供 XML 文件內部表示法的資料列集檢視。</span><span class="sxs-lookup"><span data-stu-id="4c069-105">It does this by providing a rowset view of the internal representation of an XML document.</span></span> <span data-ttu-id="4c069-106">資料列集的記錄可以儲存在資料庫的資料表中。</span><span class="sxs-lookup"><span data-stu-id="4c069-106">The records in the rowset can be stored in database tables.</span></span>

 <span data-ttu-id="4c069-107">OPENXML 可用於 SELECT 及 SELECT INTO 陳述式，其中出現的資料列集提供者、檢視或 OPENROWSET 都可做為來源。</span><span class="sxs-lookup"><span data-stu-id="4c069-107">OPENXML can be used in SELECT and SELECT INTO statements wherever rowset providers, a view, or OPENROWSET can appear as the source.</span></span> <span data-ttu-id="4c069-108">如需 OPENXML 語法的相關資訊，請參閱 [OPENXML &#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="4c069-108">For information about the syntax of OPENXML, see [OPENXML &#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql).</span></span>

 <span data-ttu-id="4c069-109">若要使用 OPENXML 針對 XML 檔撰寫查詢，您必須先呼叫 `sp_xml_preparedocument` 。</span><span class="sxs-lookup"><span data-stu-id="4c069-109">To write queries against an XML document by using OPENXML, you must first call `sp_xml_preparedocument`.</span></span> <span data-ttu-id="4c069-110">這樣會剖析 XML 文件，並將控制代碼傳回至準備要使用的已剖析文件。</span><span class="sxs-lookup"><span data-stu-id="4c069-110">This parses the XML document and returns a handle to the parsed document that is ready for consumption.</span></span> <span data-ttu-id="4c069-111">剖析過的文件就是 XML 文件中，各種節點的文件物件模型 (DOM) 樹狀表示法。</span><span class="sxs-lookup"><span data-stu-id="4c069-111">The parsed document is a document object model (DOM) tree representation of various nodes in the XML document.</span></span> <span data-ttu-id="4c069-112">接著文件控制代碼會傳遞至 OPENXML。</span><span class="sxs-lookup"><span data-stu-id="4c069-112">The document handle is passed to OPENXML.</span></span> <span data-ttu-id="4c069-113">然後 OPENXML 會依據傳給它的參數，提供該文件的資料列集檢視。</span><span class="sxs-lookup"><span data-stu-id="4c069-113">OPENXML then provides a rowset view of the document, based on the parameters passed to it.</span></span>

> [!NOTE]
>  <span data-ttu-id="4c069-114">`sp_xml_preparedocument`會使用 SQL 更新版本的 MSXML 剖析器，Msxmlsql.dll。</span><span class="sxs-lookup"><span data-stu-id="4c069-114">`sp_xml_preparedocument` uses a SQL-updated version of the MSXML parser, Msxmlsql.dll.</span></span> <span data-ttu-id="4c069-115">這個版本的 MSXML 剖析器的設計目的，是要支援 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 並維持與 MSXML 2.6 舊版的相容性。</span><span class="sxs-lookup"><span data-stu-id="4c069-115">This version of the MSXML parser was designed to support [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and remain backward compatible with MSXML version 2.6.</span></span>

 <span data-ttu-id="4c069-116">若要釋放記憶體空間，必須呼叫 **sp_xml_removedocument** 系統預存程序，將 XML 文件的內部表示法從記憶體中移除。</span><span class="sxs-lookup"><span data-stu-id="4c069-116">The internal representation of an XML document must be removed from memory by calling the **sp_xml_removedocument** system stored procedure to free the memory.</span></span>

 <span data-ttu-id="4c069-117">下圖說明此程序。</span><span class="sxs-lookup"><span data-stu-id="4c069-117">The following illustration shows the process.</span></span>

 <span data-ttu-id="4c069-118">![使用 OPENXML 剖析 XML](../../database-engine/media/xmlsp.gif "使用 OPENXML 剖析 XML")</span><span class="sxs-lookup"><span data-stu-id="4c069-118">![Parsing XML with OPENXML](../../database-engine/media/xmlsp.gif "Parsing XML with OPENXML")</span></span>

 <span data-ttu-id="4c069-119">請注意，若要了解 OPENXML，您必須先熟悉 XPath 查詢，並了解 XML。</span><span class="sxs-lookup"><span data-stu-id="4c069-119">Note that to understand OPENXML, familiarity with XPath queries and an understanding of XML is required.</span></span> <span data-ttu-id="4c069-120">如需 SQL Server 中 XPath 支援的詳細資訊，請參閱 [在 SQLXML 4.0 中使用 XPath 查詢](../sqlxml-annotated-xsd-schemas-xpath-queries/using-xpath-queries-in-sqlxml-4-0.md)。</span><span class="sxs-lookup"><span data-stu-id="4c069-120">For more information about XPath support in SQL Server, see [Using XPath Queries in SQLXML 4.0](../sqlxml-annotated-xsd-schemas-xpath-queries/using-xpath-queries-in-sqlxml-4-0.md).</span></span>

> [!NOTE]
>  <span data-ttu-id="4c069-121">OpenXML 允許將資料列及資料行的 XPath 模式參數化為變數。</span><span class="sxs-lookup"><span data-stu-id="4c069-121">OpenXML allows the row and column XPath patterns to be parameterized as variables.</span></span> <span data-ttu-id="4c069-122">如果程式設計人員將參數化內容向外部使用者公開 (例如，透過從外部呼叫的預存程序提供參數)，則這些參數化內容可能會導致 XPath 運算式的植入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="4c069-122">Such parameterization could lead to XPath expression injections, if the programmer exposes the parameterization to outside users (for example, if the parameters are provided via an externally called stored procedure).</span></span> <span data-ttu-id="4c069-123">為避免這些潛在的安全性問題，建議您絕不要對外部呼叫端公開 XPath 參數。</span><span class="sxs-lookup"><span data-stu-id="4c069-123">To avoid such potential security issues, it is recommended that XPath parameters should never be exposed to external callers.</span></span>

## <a name="example"></a><span data-ttu-id="4c069-124">範例</span><span class="sxs-lookup"><span data-stu-id="4c069-124">Example</span></span>
 <span data-ttu-id="4c069-125">`OPENXML` 下列範例示範在 `INSERT` 陳述式和 `SELECT` 陳述式中使用 。</span><span class="sxs-lookup"><span data-stu-id="4c069-125">The following example shows the use of `OPENXML` in an `INSERT` statement and a `SELECT` statement.</span></span> <span data-ttu-id="4c069-126">`<Customers>` 範例 XML 文件包含 `<Orders>` 和  元素。</span><span class="sxs-lookup"><span data-stu-id="4c069-126">The sample XML document contains `<Customers>` and `<Orders>` elements.</span></span>

 <span data-ttu-id="4c069-127">首先， `sp_xml_preparedocument` 預存程序會剖析 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="4c069-127">First, the `sp_xml_preparedocument` stored procedure parses the XML document.</span></span> <span data-ttu-id="4c069-128">這份已剖析的文件以樹狀目錄表示 XML 文件中之節點 (元素、屬性、文字及註解)。</span><span class="sxs-lookup"><span data-stu-id="4c069-128">The parsed document is a tree representation of the nodes (elements, attributes, text, and comments) in the XML document.</span></span> <span data-ttu-id="4c069-129">`OPENXML` 之後會參照這份已剖析的 XML 文件，並提供這份 XML 文件的所有或部分資料列集檢視。</span><span class="sxs-lookup"><span data-stu-id="4c069-129">`OPENXML` then refers to this parsed XML document and provides a rowset view of all or parts of this XML document.</span></span> <span data-ttu-id="4c069-130">`INSERT` 使用 `OPENXML` 的  陳述式，便可從這樣的資料列集將資料插入資料庫資料表。</span><span class="sxs-lookup"><span data-stu-id="4c069-130">An `INSERT` statement using `OPENXML` can insert data from such a rowset into a database table.</span></span> <span data-ttu-id="4c069-131">`OPENXML` 有數個  呼叫可用來提供 XML 文件各個部分的資料列集檢視並處理它們，例如，將它們插入不同的資料表。</span><span class="sxs-lookup"><span data-stu-id="4c069-131">Several `OPENXML` calls can be used to provide a rowset view of various parts of the XML document and process them, for example, by inserting them into different tables.</span></span> <span data-ttu-id="4c069-132">此處理序又稱為將 XML 切割成資料表。</span><span class="sxs-lookup"><span data-stu-id="4c069-132">This process is also referred to as shredding XML into tables.</span></span>

 <span data-ttu-id="4c069-133">`<Customers>` 下列範例將 XML 文件分成兩部分的方法是使用兩個 `Customers` 陳述式，將其 `<Orders>` 元素儲存在 `Orders` 資料表中，以及將其 `INSERT` 元素儲存在  資料表中。</span><span class="sxs-lookup"><span data-stu-id="4c069-133">In the following example, an XML document is shredded in a way that `<Customers>` elements are stored in the `Customers` table and `<Orders>` elements are stored in the `Orders` table by using two `INSERT` statements.</span></span> <span data-ttu-id="4c069-134">`SELECT` 此範例同時也顯示帶有 `OPENXML` 的 `CustomerID` 陳述式，從 XML 文件中擷取 `OrderDate` 和 。</span><span class="sxs-lookup"><span data-stu-id="4c069-134">The example also shows a `SELECT` statement with `OPENXML` that retrieves `CustomerID` and `OrderDate` from the XML document.</span></span> <span data-ttu-id="4c069-135">`sp_xml_removedocument`在此程序中的最一個步驟是呼叫 。</span><span class="sxs-lookup"><span data-stu-id="4c069-135">The last step in the process is to call `sp_xml_removedocument`.</span></span> <span data-ttu-id="4c069-136">這是為了釋放已配置的記憶體，該記憶體是用來包含在剖析階段期間所建立的內部 XML 樹狀表示法。</span><span class="sxs-lookup"><span data-stu-id="4c069-136">This is done in order to release the memory allocated to contain the internal XML tree representation that was created during the parse phase.</span></span>

```
-- Create tables for later population using OPENXML.
CREATE TABLE Customers (CustomerID varchar(20) primary key,
                ContactName varchar(20), 
                CompanyName varchar(20));
GO
CREATE TABLE Orders( CustomerID varchar(20), OrderDate datetime);
GO
DECLARE @docHandle int;
DECLARE @xmlDocument nvarchar(max); -- or xml type
SET @xmlDocument = N'<ROOT>
<Customers CustomerID="XYZAA" ContactName="Joe" CompanyName="Company1">
<Orders CustomerID="XYZAA" OrderDate="2000-08-25T00:00:00"/>
<Orders CustomerID="XYZAA" OrderDate="2000-10-03T00:00:00"/>
</Customers>
<Customers CustomerID="XYZBB" ContactName="Steve"
CompanyName="Company2">No Orders yet!
</Customers>
</ROOT>';
EXEC sp_xml_preparedocument @docHandle OUTPUT, @xmlDocument;
-- Use OPENXML to provide rowset consisting of customer data.
INSERT Customers 
SELECT * 
FROM OPENXML(@docHandle, N'/ROOT/Customers') 
  WITH Customers;
-- Use OPENXML to provide rowset consisting of order data.
INSERT Orders 
SELECT * 
FROM OPENXML(@docHandle, N'//Orders') 
  WITH Orders;
-- Using OPENXML in a SELECT statement.
SELECT * FROM OPENXML(@docHandle, N'/ROOT/Customers/Orders') WITH (CustomerID nchar(5) '../@CustomerID', OrderDate datetime);
-- Remove the internal representation of the XML document.
EXEC sp_xml_removedocument @docHandle; 
```

 <span data-ttu-id="4c069-137">下圖針對先前使用 sp_xml_preparedocument 所建立的 XML 文件，顯示其剖析後的 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="4c069-137">The following illustration shows the parsed XML tree of the previous XML document that was created by using sp_xml_preparedocument.</span></span>

 <span data-ttu-id="4c069-138">![剖析的 XML 樹狀結構](../../database-engine/media/xmlparsedtree.gif "剖析的 XML 樹狀結構")</span><span class="sxs-lookup"><span data-stu-id="4c069-138">![Parsed XML tree](../../database-engine/media/xmlparsedtree.gif "Parsed XML tree")</span></span>

## <a name="openxml-parameters"></a><span data-ttu-id="4c069-139">OPENXML 參數</span><span class="sxs-lookup"><span data-stu-id="4c069-139">OPENXML Parameters</span></span>
 <span data-ttu-id="4c069-140">OPENXML 的參數包括：</span><span class="sxs-lookup"><span data-stu-id="4c069-140">The parameters to OPENXML include the following:</span></span>

-   <span data-ttu-id="4c069-141">XML 文件控制代碼 (*idoc*)</span><span class="sxs-lookup"><span data-stu-id="4c069-141">An XML document handle (*idoc*)</span></span>

-   <span data-ttu-id="4c069-142">XPath 運算式，用來識別要對應到資料列的節點 (*rowpattern*)</span><span class="sxs-lookup"><span data-stu-id="4c069-142">An XPath expression to identify the nodes to be mapped to rows (*rowpattern*)</span></span>

-   <span data-ttu-id="4c069-143">所要產生資料列集的描述</span><span class="sxs-lookup"><span data-stu-id="4c069-143">A description of the rowset to be generated</span></span>

-   <span data-ttu-id="4c069-144">資料列集資料行與 XML 節點之間的對應</span><span class="sxs-lookup"><span data-stu-id="4c069-144">Mapping between the rowset columns and the XML nodes</span></span>

### <a name="xml-document-handle-idoc"></a><span data-ttu-id="4c069-145">XML 文件控制代碼 (idoc)</span><span class="sxs-lookup"><span data-stu-id="4c069-145">XML Document Handle (idoc)</span></span>
 <span data-ttu-id="4c069-146">預存程式會傳回檔案控制代碼 `sp_xml_preparedocument` 。</span><span class="sxs-lookup"><span data-stu-id="4c069-146">The document handle is returned by the `sp_xml_preparedocument` stored procedure.</span></span>

### <a name="xpath-expression-to-identify-the-nodes-to-be-processed-rowpattern"></a><span data-ttu-id="4c069-147">用來識別欲處理之節點的 XPath 運算式 (rowpattern)</span><span class="sxs-lookup"><span data-stu-id="4c069-147">XPath Expression to Identify the Nodes to Be Processed (rowpattern)</span></span>
 <span data-ttu-id="4c069-148"> 指定為 rowpattern的 XPath 運算式識別 XML 文件中的節點集。</span><span class="sxs-lookup"><span data-stu-id="4c069-148">The XPath expression specified as *rowpattern* identifies a set of nodes in the XML document.</span></span> <span data-ttu-id="4c069-149"> 每個由 rowpattern 識別的節點，都會對應到由 OPENXML 所產生之資料列集中的單一資料列。</span><span class="sxs-lookup"><span data-stu-id="4c069-149">Each node that is identified by *rowpattern* corresponds to a single row in the rowset that is generated by OPENXML.</span></span>

 <span data-ttu-id="4c069-150">由 XPath 運算式所識別的節點，可以是 XML 文件中的任何 XML 節點。</span><span class="sxs-lookup"><span data-stu-id="4c069-150">The nodes identified by the XPath expression can be any XML node in the XML document.</span></span> <span data-ttu-id="4c069-151"> 若 rowpattern 識別 XML 文件中的一組元素，則每個元素節點在資料列集中都有一識別的資料列。</span><span class="sxs-lookup"><span data-stu-id="4c069-151">If *rowpattern* identifies a set of elements in the XML document, there is one row in the rowset for each element node identified.</span></span> <span data-ttu-id="4c069-152"> 例如，若 *rowpattern*在屬性中結束，將會為每個 rowpattern 所選取的屬性節點建立資料列。</span><span class="sxs-lookup"><span data-stu-id="4c069-152">For example, if *rowpattern* ends in an attribute, a row is created for each attribute node selected by *rowpattern*.</span></span>

### <a name="description-of-the-rowset-to-be-generated"></a><span data-ttu-id="4c069-153">欲產生的資料列集說明</span><span class="sxs-lookup"><span data-stu-id="4c069-153">Description of the Rowset to Be Generated</span></span>
 <span data-ttu-id="4c069-154">OPENXML 會使用資料列集結構描述，來產生結果資料列集。</span><span class="sxs-lookup"><span data-stu-id="4c069-154">A rowset schema is used by OPENXML to generate the resulting rowset.</span></span> <span data-ttu-id="4c069-155">指定資料列集結構描述時，可以使用下列選項。</span><span class="sxs-lookup"><span data-stu-id="4c069-155">You can use the following options when specifying a rowset schema.</span></span>

#### <a name="using-the-edge-table-format"></a><span data-ttu-id="4c069-156">使用邊緣資料表格式</span><span class="sxs-lookup"><span data-stu-id="4c069-156">Using the Edge Table Format</span></span>
 <span data-ttu-id="4c069-157">您應使用邊緣資料表格式來指定資料列集結構描述。</span><span class="sxs-lookup"><span data-stu-id="4c069-157">You should use the edge table format to specify a rowset schema.</span></span> <span data-ttu-id="4c069-158">請不要使用 WITH 子句。</span><span class="sxs-lookup"><span data-stu-id="4c069-158">Do not use the WITH clause.</span></span>

 <span data-ttu-id="4c069-159">當您這麼做時，OPENXML 會以邊緣資料表格式來傳回資料列集。</span><span class="sxs-lookup"><span data-stu-id="4c069-159">When you do this, OPENXML returns a rowset in the edge table format.</span></span> <span data-ttu-id="4c069-160">之所以稱為邊緣資料表，是因為已剖析之 XML 文件樹狀目錄中的每個邊緣，都會對應到資料列集中的一個資料列。</span><span class="sxs-lookup"><span data-stu-id="4c069-160">This is referred to as an edge table, because every edge in the parsed XML document tree maps to a row in the rowset.</span></span>

 <span data-ttu-id="4c069-161">在單一資料表中，邊緣資料表代表了較細部的 XML 文件結構。</span><span class="sxs-lookup"><span data-stu-id="4c069-161">Edge tables represent within a single table the fine-grained XML document structure.</span></span> <span data-ttu-id="4c069-162">此結構包含元素和屬性名稱、文件階層、命名空間及處理指示。</span><span class="sxs-lookup"><span data-stu-id="4c069-162">This structure includes the element and attribute names, the document hierarchy, the namespaces, and the processing instructions.</span></span> <span data-ttu-id="4c069-163">邊緣資料表的格式可讓您取得未透過中繼屬性公開的額外資訊。</span><span class="sxs-lookup"><span data-stu-id="4c069-163">The edge table format allows you to obtain additional information that is not exposed through the metaproperties.</span></span> <span data-ttu-id="4c069-164">[Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md)如需有關中繼內容的詳細資訊，請參閱＜＞。</span><span class="sxs-lookup"><span data-stu-id="4c069-164">For more information about metaproperties, see [Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md).</span></span>

 <span data-ttu-id="4c069-165">邊緣資料表所提供的額外資訊，可讓您儲存及查詢元素和屬性的資料類型，以及節點類型，也可以儲存及查詢 XML 文件結構的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4c069-165">The additional information provided by an edge table allows you to store and query the data type of an element and attribute, and the node type, and also store and query information about the XML document structure.</span></span> <span data-ttu-id="4c069-166">有了這項額外資訊，您還可能建立自己的 XML 文件管理系統。</span><span class="sxs-lookup"><span data-stu-id="4c069-166">With this additional information, it may also be possible to build your own XML document management system.</span></span>

 <span data-ttu-id="4c069-167">藉由使用邊緣資料表，您可以撰寫預存程序以將 XML 文件當作二進位大型物件 (BLOB) 輸入、產生邊緣資料表，然後在更詳細的層級中擷取及分析文件。</span><span class="sxs-lookup"><span data-stu-id="4c069-167">By using an edge table, you can write stored procedures that take XML documents as binary large object (BLOB) input, produce the edge table, and then extract and analyze the document on a more detailed level.</span></span> <span data-ttu-id="4c069-168">此詳細層級可以包含尋找文件階層、元素和屬性名稱、命名空間及處理指示。</span><span class="sxs-lookup"><span data-stu-id="4c069-168">This detailed level could include finding the document hierarchy, the element and attribute names, the namespaces, and the processing instructions.</span></span>

 <span data-ttu-id="4c069-169">當對應至其他關聯格式不合邏輯，且 ntext 欄位未能提供足夠的結構資訊時，邊緣資料表也可以當作 XML 文件的儲存格式。</span><span class="sxs-lookup"><span data-stu-id="4c069-169">The edge table also can serve as a storage format for XML documents when mapping to other relational formats is not logical and an ntext field is not providing enough structural information.</span></span>

 <span data-ttu-id="4c069-170">在您可以使用 XML 剖析器來檢查 XML 文件的情況下，您都可以改用邊緣資料表來取得同樣的資訊。</span><span class="sxs-lookup"><span data-stu-id="4c069-170">In situations where you can use an XML parser to examine an XML document, you can use an edge table instead to obtain the same information.</span></span>

 <span data-ttu-id="4c069-171">下表說明邊緣資料表的結構。</span><span class="sxs-lookup"><span data-stu-id="4c069-171">The following table describes the structure of the edge table.</span></span>

|<span data-ttu-id="4c069-172">資料行名稱</span><span class="sxs-lookup"><span data-stu-id="4c069-172">Column name</span></span>|<span data-ttu-id="4c069-173">資料類型</span><span class="sxs-lookup"><span data-stu-id="4c069-173">Data type</span></span>|<span data-ttu-id="4c069-174">描述</span><span class="sxs-lookup"><span data-stu-id="4c069-174">Description</span></span>|
|-----------------|---------------|-----------------|
|<span data-ttu-id="4c069-175">**id**</span><span class="sxs-lookup"><span data-stu-id="4c069-175">**id**</span></span>|<span data-ttu-id="4c069-176">**bigint**</span><span class="sxs-lookup"><span data-stu-id="4c069-176">**bigint**</span></span>|<span data-ttu-id="4c069-177">這是文件節點的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="4c069-177">Is the unique ID of the document node.</span></span><br /><br /> <span data-ttu-id="4c069-178">根元素具有識別碼值 0；</span><span class="sxs-lookup"><span data-stu-id="4c069-178">The root element has an ID value of 0.</span></span> <span data-ttu-id="4c069-179">負的識別碼值會保留。</span><span class="sxs-lookup"><span data-stu-id="4c069-179">The negative ID values are reserved.</span></span>|
|<span data-ttu-id="4c069-180">**parentid**</span><span class="sxs-lookup"><span data-stu-id="4c069-180">**parentid**</span></span>|<span data-ttu-id="4c069-181">**bigint**</span><span class="sxs-lookup"><span data-stu-id="4c069-181">**bigint**</span></span>|<span data-ttu-id="4c069-182">識別節點的父系。</span><span class="sxs-lookup"><span data-stu-id="4c069-182">Identifies the parent of the node.</span></span> <span data-ttu-id="4c069-183">此識別碼所識別的父系，不一定就是父元素；</span><span class="sxs-lookup"><span data-stu-id="4c069-183">The parent identified by this ID is not necessarily the parent element.</span></span> <span data-ttu-id="4c069-184">這一點需根據此識別碼所識別父系的節點 NodeType 而定。</span><span class="sxs-lookup"><span data-stu-id="4c069-184">However, this depends on the NodeType of the node whose parent is identified by this ID.</span></span> <span data-ttu-id="4c069-185">例如，若該節點是文字節點，其父系可能是屬性節點。</span><span class="sxs-lookup"><span data-stu-id="4c069-185">For example, if the node is a text node, its parent may be an attribute node.</span></span><br /><br /> <span data-ttu-id="4c069-186"> 如果節點位於 XML 文件的最上層，其 ParentID 為 NULL。</span><span class="sxs-lookup"><span data-stu-id="4c069-186">If the node is at the top level in the XML document, its **ParentID** is NULL.</span></span>|
|<span data-ttu-id="4c069-187">**node type**</span><span class="sxs-lookup"><span data-stu-id="4c069-187">**node type**</span></span>|<span data-ttu-id="4c069-188">**int**</span><span class="sxs-lookup"><span data-stu-id="4c069-188">**int**</span></span>|<span data-ttu-id="4c069-189">用以識別節點類型，而且是對應於 XML 物件模型 (DOM) 節點類型編號的整數。</span><span class="sxs-lookup"><span data-stu-id="4c069-189">Identifies the node type and is an integer that corresponds to the XML object model (DOM) node type numbering.</span></span><br /><br /> <span data-ttu-id="4c069-190">以下是可以出現在此資料行中，用來指出節點類型的值：</span><span class="sxs-lookup"><span data-stu-id="4c069-190">Following are the values that can appear in this column to indicate the node type:</span></span><br /><br /> <span data-ttu-id="4c069-191">**1** = 元素節點</span><span class="sxs-lookup"><span data-stu-id="4c069-191">**1** = Element node</span></span><br /><br /> <span data-ttu-id="4c069-192">**2** = 屬性節點</span><span class="sxs-lookup"><span data-stu-id="4c069-192">**2** = Attribute node</span></span><br /><br /> <span data-ttu-id="4c069-193">**3** = 文字節點</span><span class="sxs-lookup"><span data-stu-id="4c069-193">**3** = Text node</span></span><br /><br /> <span data-ttu-id="4c069-194">**4** = CDATA 區段節點</span><span class="sxs-lookup"><span data-stu-id="4c069-194">**4** = CDATA section node</span></span><br /><br /> <span data-ttu-id="4c069-195">**5** = 實體參考節點</span><span class="sxs-lookup"><span data-stu-id="4c069-195">**5** = Entity reference node</span></span><br /><br /> <span data-ttu-id="4c069-196">**6** = 實體節點</span><span class="sxs-lookup"><span data-stu-id="4c069-196">**6** = Entity node</span></span><br /><br /> <span data-ttu-id="4c069-197">**7** = 處理指示節點</span><span class="sxs-lookup"><span data-stu-id="4c069-197">**7** = Processing instruction node</span></span><br /><br /> <span data-ttu-id="4c069-198">**8** = 註解節點</span><span class="sxs-lookup"><span data-stu-id="4c069-198">**8** = Comment node</span></span><br /><br /> <span data-ttu-id="4c069-199">**9** = 文件節點</span><span class="sxs-lookup"><span data-stu-id="4c069-199">**9** = Document node</span></span><br /><br /> <span data-ttu-id="4c069-200">**10** = 文件類型節點</span><span class="sxs-lookup"><span data-stu-id="4c069-200">**10** = Document Type node</span></span><br /><br /> <span data-ttu-id="4c069-201">**11** = 文件片段節點</span><span class="sxs-lookup"><span data-stu-id="4c069-201">**11** = Document Fragment node</span></span><br /><br /> <span data-ttu-id="4c069-202">**12** = 標記法節點</span><span class="sxs-lookup"><span data-stu-id="4c069-202">**12** = Notation node</span></span><br /><br /> <span data-ttu-id="4c069-203">如需詳細資訊，請參閱 Microsoft XML (MSXML) SDK 中的＜nodeType 屬性＞主題。</span><span class="sxs-lookup"><span data-stu-id="4c069-203">For more information, see the "nodeType Property" topic in the Microsoft XML (MSXML) SDK.</span></span>|
|<span data-ttu-id="4c069-204">**localname**</span><span class="sxs-lookup"><span data-stu-id="4c069-204">**localname**</span></span>|<span data-ttu-id="4c069-205">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="4c069-205">**nvarchar(max)**</span></span>|<span data-ttu-id="4c069-206">提供元素或屬性的本機名稱。</span><span class="sxs-lookup"><span data-stu-id="4c069-206">Gives the local name of the element or attribute.</span></span> <span data-ttu-id="4c069-207">如果 DOM 物件不具有名稱，則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="4c069-207">Is NULL if the DOM object does not have a name.</span></span>|
|<span data-ttu-id="4c069-208">**prefix**</span><span class="sxs-lookup"><span data-stu-id="4c069-208">**prefix**</span></span>|<span data-ttu-id="4c069-209">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="4c069-209">**nvarchar(max)**</span></span>|<span data-ttu-id="4c069-210">這是節點名稱的命名空間前置詞。</span><span class="sxs-lookup"><span data-stu-id="4c069-210">Is the namespace prefix of the node name.</span></span>|
|<span data-ttu-id="4c069-211">**namespaceuri**</span><span class="sxs-lookup"><span data-stu-id="4c069-211">**namespaceuri**</span></span>|<span data-ttu-id="4c069-212">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="4c069-212">**nvarchar(max)**</span></span>|<span data-ttu-id="4c069-213">這是節點的命名空間 URI。</span><span class="sxs-lookup"><span data-stu-id="4c069-213">Is the namespace URI of the node.</span></span> <span data-ttu-id="4c069-214">如果值是 NULL，表示沒有命名空間。</span><span class="sxs-lookup"><span data-stu-id="4c069-214">If the value is NULL, no namespace is present.</span></span>|
|<span data-ttu-id="4c069-215">**datatype**</span><span class="sxs-lookup"><span data-stu-id="4c069-215">**datatype**</span></span>|<span data-ttu-id="4c069-216">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="4c069-216">**nvarchar(max)**</span></span>|<span data-ttu-id="4c069-217">是元素或屬性資料列的實際資料類型，否則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="4c069-217">Is the actual data type of the element or attribute row and is otherwise NULL.</span></span> <span data-ttu-id="4c069-218">資料類型是從內嵌 DTD 或內嵌結構描述推斷。</span><span class="sxs-lookup"><span data-stu-id="4c069-218">The data type is inferred from the inline DTD or from the inline schema.</span></span>|
|<span data-ttu-id="4c069-219">**prev**</span><span class="sxs-lookup"><span data-stu-id="4c069-219">**prev**</span></span>|<span data-ttu-id="4c069-220">**bigint**</span><span class="sxs-lookup"><span data-stu-id="4c069-220">**bigint**</span></span>|<span data-ttu-id="4c069-221">這是前一個同層級元素的 XML 識別碼。</span><span class="sxs-lookup"><span data-stu-id="4c069-221">Is the XML ID of the previous sibling element.</span></span> <span data-ttu-id="4c069-222">如果沒有直接的前一個同層級，則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="4c069-222">Is NULL if there is no direct previous sibling.</span></span>|
|<span data-ttu-id="4c069-223">**text**</span><span class="sxs-lookup"><span data-stu-id="4c069-223">**text**</span></span>|<span data-ttu-id="4c069-224">**ntext**</span><span class="sxs-lookup"><span data-stu-id="4c069-224">**ntext**</span></span>|<span data-ttu-id="4c069-225">包含文字格式的屬性值或元素內容。</span><span class="sxs-lookup"><span data-stu-id="4c069-225">Contains the attribute value or the element content in text form.</span></span> <span data-ttu-id="4c069-226">若邊緣資料表項目不需要值，則為 NULL。</span><span class="sxs-lookup"><span data-stu-id="4c069-226">Or is NULL, if the edge table entry does not need a value.</span></span>|

#### <a name="using-the-with-clause-to-specify-an-existing-table"></a><span data-ttu-id="4c069-227">使用 WITH 子句指定現有的資料表</span><span class="sxs-lookup"><span data-stu-id="4c069-227">Using the WITH Clause to Specify an Existing Table</span></span>
 <span data-ttu-id="4c069-228">您可以使用 WITH 子句來指定現有資料表的名稱。</span><span class="sxs-lookup"><span data-stu-id="4c069-228">You can use the WITH clause to specify the name of an existing table.</span></span> <span data-ttu-id="4c069-229">若要這麼做，只需指定現有的資料表名稱，而此資料表的結構描述可讓 OPENXML 用來產生資料列集。</span><span class="sxs-lookup"><span data-stu-id="4c069-229">To do this, just specify an existing table name whose schema can be used by OPENXML to generate the rowset.</span></span>

#### <a name="using-the-with-clause-to-specify-a-schema"></a><span data-ttu-id="4c069-230">使用 WITH 子句指定結構描述</span><span class="sxs-lookup"><span data-stu-id="4c069-230">Using the WITH Clause to Specify a Schema</span></span>
 <span data-ttu-id="4c069-231">您可以使用 WITH 子句來指定完整的結構描述。</span><span class="sxs-lookup"><span data-stu-id="4c069-231">You can use the WITH Clause to specify a complete schema.</span></span> <span data-ttu-id="4c069-232">在指定資料列集結構描述時，您需指定資料行名稱、其資料類型，以及其與 XML 文件的對應。</span><span class="sxs-lookup"><span data-stu-id="4c069-232">In specifying the rowset schema, you specify the column names, their data types, and their mapping to the XML document.</span></span>

 <span data-ttu-id="4c069-233">您可以利用 SchemaDeclaration 中的 ColPattern 參數來指定資料行模式。</span><span class="sxs-lookup"><span data-stu-id="4c069-233">You can specify the column pattern by using the ColPattern parameter in the SchemaDeclaration.</span></span> <span data-ttu-id="4c069-234">所指定的資料行模式可用來將資料列集資料行對應到由 rowpattern 識別的 XML 節點，並可用來決定對應類型。</span><span class="sxs-lookup"><span data-stu-id="4c069-234">The specified column pattern is used to map a rowset column to the XML node that is identified by rowpattern and is also used to determine the type of mapping.</span></span>

 <span data-ttu-id="4c069-235">*flags* 如果沒有為資料行指定 ColPattern，資料列集資料行會根據  參數所指定的對應，對應至具有相同名稱的 XML 節點。</span><span class="sxs-lookup"><span data-stu-id="4c069-235">If ColPattern is not specified for a column, the rowset column maps to the XML node with the same name, based on the mapping specified by the *flags* parameter.</span></span> <span data-ttu-id="4c069-236">*flags* 但若在 WITH 子句中將 ColPattern 指定成結構描述規格的一部份，則 ColPattern 會覆寫  參數中所指定的對應。</span><span class="sxs-lookup"><span data-stu-id="4c069-236">However, if ColPattern is specified as part of the schema specification in the WITH clause, it overwrites the mapping that is specified in the *flags* parameter.</span></span>

### <a name="mapping-between-the-rowset-columns-and-the-xml-nodes"></a><span data-ttu-id="4c069-237">資料列集資料行與 XML 節點之間的對應</span><span class="sxs-lookup"><span data-stu-id="4c069-237">Mapping Between the Rowset Columns and the XML Nodes</span></span>
 <span data-ttu-id="4c069-238">在 OPENXML 陳述式中，您可以選擇在資料列集資料行以及 *rowpattern*所識別的 XML 節點之間，指定對應的類型，例如：屬性中心或元素中心。</span><span class="sxs-lookup"><span data-stu-id="4c069-238">In the OPENXML statement, you can optionally specify the type of mapping, such as attribute-centric or element-centric, between the rowset columns and the XML nodes that are identified by the *rowpattern*.</span></span> <span data-ttu-id="4c069-239">這項資訊是用於 XML 節點與資料列集資料行之間的轉換。</span><span class="sxs-lookup"><span data-stu-id="4c069-239">This information is used in the transformation between the XML nodes and the rowset columns.</span></span>

 <span data-ttu-id="4c069-240">您可以用兩種方式來指定對應，也可以兩個項目都指定：</span><span class="sxs-lookup"><span data-stu-id="4c069-240">You can specify the mapping in two ways, and you can also specify both:</span></span>

-   <span data-ttu-id="4c069-241"> 使用 flags 參數</span><span class="sxs-lookup"><span data-stu-id="4c069-241">By using the *flags* parameter</span></span>

     <span data-ttu-id="4c069-242"> 由 flags 參數所指定的對應會假設下列條件的名稱對應：XML 節點對應至具有相同名稱的對應資料列集資料行。</span><span class="sxs-lookup"><span data-stu-id="4c069-242">The mapping that is specified by the *flags* parameter assumes name correspondence in which the XML nodes map to the corresponding rowset columns with same name.</span></span>

-   <span data-ttu-id="4c069-243"> 使用 ColPattern 參數</span><span class="sxs-lookup"><span data-stu-id="4c069-243">By using the *ColPattern* parameter</span></span>

     <span data-ttu-id="4c069-244">*ColPattern*為 XPath 運算式，在 WITH 子句中指定為 *SchemaDeclaration* 的一部份。</span><span class="sxs-lookup"><span data-stu-id="4c069-244">*ColPattern*, an XPath expression, is specified as part of *SchemaDeclaration* in the WITH clause.</span></span> <span data-ttu-id="4c069-245"> 在 *ColPattern* 中指定的對應，會覆寫由 flags 參數所指定的對應。</span><span class="sxs-lookup"><span data-stu-id="4c069-245">The mapping specified in *ColPattern* overwrites the mapping specified by the *flags* parameter.</span></span>

     <span data-ttu-id="4c069-246">*ColPattern* 可用來指定對應的類型 (例如屬性中心或元素中心)，以覆寫或加強 *flags*所指定的預設對應。</span><span class="sxs-lookup"><span data-stu-id="4c069-246">*ColPattern* can be used to specify the type of mapping, such as attribute-centric or element-centric, that overwrites or enhances the default mapping indicated by the *flags*.</span></span>

     <span data-ttu-id="4c069-247"> 在下列情況下，會指定 ColPattern：</span><span class="sxs-lookup"><span data-stu-id="4c069-247">*ColPattern* is specified under the following circumstances:</span></span>

    -   <span data-ttu-id="4c069-248">資料列集中的資料行名稱，與其對應的元素或屬性名稱不同。</span><span class="sxs-lookup"><span data-stu-id="4c069-248">The column name in the rowset is different from the element or attribute name to which it is mapped.</span></span> <span data-ttu-id="4c069-249"> 在此情況下，ColPattern 是用來識別資料列集資料行所對應的 XML 元素及屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="4c069-249">In this case, *ColPattern* is used to identify the XML element and attribute name to which the rowset column maps.</span></span>

    -   <span data-ttu-id="4c069-250">您希望將中繼屬性的屬性對應到資料行。</span><span class="sxs-lookup"><span data-stu-id="4c069-250">You want to map a metaproperty attribute to the column.</span></span> <span data-ttu-id="4c069-251"> 在此情況下，ColPattern 是用來識別資料列集資料行對應的中繼屬性。</span><span class="sxs-lookup"><span data-stu-id="4c069-251">In this case, *ColPattern* is used to identify the metaproperty to which the rowset column maps.</span></span> <span data-ttu-id="4c069-252">如需如何使用中繼屬性的詳細資訊，請參閱 [在 OPENXML 中指定中繼屬性](../xml/specify-metaproperties-in-openxml.md)。</span><span class="sxs-lookup"><span data-stu-id="4c069-252">For more information about how to use metaproperties, see [Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md).</span></span>

 <span data-ttu-id="4c069-253">*flags* 和 *ColPattern* 參數均是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="4c069-253">Both the *flags* and *ColPattern* parameters are optional.</span></span> <span data-ttu-id="4c069-254">如果未指定對應，則會採用屬性中心對應。</span><span class="sxs-lookup"><span data-stu-id="4c069-254">If no mapping is specified, attribute-centric mapping is assumed.</span></span> <span data-ttu-id="4c069-255">屬性中心對應是 *flags* 參數的預設值。</span><span class="sxs-lookup"><span data-stu-id="4c069-255">Attribute-centric mapping is the default value of the *flags* parameter.</span></span>

#### <a name="attribute-centric-mapping"></a><span data-ttu-id="4c069-256">以屬性為主的對應</span><span class="sxs-lookup"><span data-stu-id="4c069-256">Attribute-centric Mapping</span></span>
 <span data-ttu-id="4c069-257">在 OPENXML 中將 *flags* 參數設為 1 (XML_ATTRIBUTES)，就是指定 **屬性中心** 對應。</span><span class="sxs-lookup"><span data-stu-id="4c069-257">Setting the *flags* parameter in OPENXML to 1 (XML_ATTRIBUTES) specifies **attribute-centric** mapping.</span></span> <span data-ttu-id="4c069-258">如果 *flags* 包含 XML_ATTRIBUTES，所公開的資料列集就會提供或取用以每個 XML 元素各代表一個資料列的資料列。</span><span class="sxs-lookup"><span data-stu-id="4c069-258">If *flags* contains XML_ ATTRIBUTES, the exposed rowset provides or consumes rows where each XML element is represented as a row.</span></span> <span data-ttu-id="4c069-259">依據名稱對應，XML 屬性會對應至 SchemaDeclaration 中所定義的屬性，或是對應至由 WITH 子句的 Tablename 所提供的屬性。</span><span class="sxs-lookup"><span data-stu-id="4c069-259">The XML attributes are mapped to the attributes that are defined in the SchemaDeclaration or that are provided by the Tablename of the WITH clause, based on name correspondence.</span></span> <span data-ttu-id="4c069-260">名稱對應意味著，特定名稱的 XML 屬性會以相同的名稱儲存在資料列集的資料行中。</span><span class="sxs-lookup"><span data-stu-id="4c069-260">Name correspondence means that the XML attributes of a particular name are stored in a column in the rowset with the same name.</span></span>

 <span data-ttu-id="4c069-261"> 若資料行名稱與其所對應的屬性名稱不同，則必須指定 ColPattern。</span><span class="sxs-lookup"><span data-stu-id="4c069-261">If the column name is different from the attribute name that it maps to, *ColPattern* must be specified.</span></span>

 <span data-ttu-id="4c069-262">若 XML 屬性具有命名空間限定詞，則資料列集的資料行名稱也必須具有限定詞。</span><span class="sxs-lookup"><span data-stu-id="4c069-262">If the XML attribute has a namespace qualifier, the column name in the rowset must also have the qualifier.</span></span>

#### <a name="element-centric-mapping"></a><span data-ttu-id="4c069-263">元素中心的對應</span><span class="sxs-lookup"><span data-stu-id="4c069-263">Element-centric Mapping</span></span>
 <span data-ttu-id="4c069-264">在 OPENXML 中將 *flags* 參數設為 2 (XML_ELEMENTS)，就是指定 **元素中心** 對應。</span><span class="sxs-lookup"><span data-stu-id="4c069-264">Setting the *flags* parameter in OPENXML to 2 (XML_ELEMENTS) specifies **element-centric** mapping.</span></span> <span data-ttu-id="4c069-265">它和 **屬性中心** 對應類似，但有以下的差別：</span><span class="sxs-lookup"><span data-stu-id="4c069-265">It is similar to **attribute-centric** mapping, except for the following differences:</span></span>

-   <span data-ttu-id="4c069-266">除非指定了資料行層級模式，否則對應範例的名稱對應 (例如，資料行對應至具有相同名稱的 XML 元素) 將會選擇非複合式子元素。</span><span class="sxs-lookup"><span data-stu-id="4c069-266">The name correspondence of the mapping example, a column mapping to an XML element with the same name chooses the noncomplex subelements, unless a column-level pattern is specified.</span></span> <span data-ttu-id="4c069-267">在擷取的過程中，若子元素是複合式的 (因為含有額外的子元素)，則資料行將設為 NULL。</span><span class="sxs-lookup"><span data-stu-id="4c069-267">In the retrieval process, if the subelement is complex because it contains additional subelements, the column is set to NULL.</span></span> <span data-ttu-id="4c069-268">所以會忽略子元素的屬性值。</span><span class="sxs-lookup"><span data-stu-id="4c069-268">Attribute values of the subelements are then ignored.</span></span>

-   <span data-ttu-id="4c069-269">若有多個具相同名稱的子元素，則會傳回第一個節點。</span><span class="sxs-lookup"><span data-stu-id="4c069-269">For multiple subelements that have the same name, the first node is returned.</span></span>

## <a name="see-also"></a><span data-ttu-id="4c069-270">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4c069-270">See Also</span></span>
 <span data-ttu-id="4c069-271">[sp_xml_preparedocument &#40;transact-sql&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-preparedocument-transact-sql) [sp_xml_removedocument &#40;](/sql/relational-databases/system-stored-procedures/sp-xml-removedocument-transact-sql) Transact-sql&#41;[OPENXML &#40;transact-sql](/sql/t-sql/functions/openxml-transact-sql)&#41;[xml 資料 &#40;](../xml/xml-data-sql-server.md) SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="4c069-271">[sp_xml_preparedocument &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-preparedocument-transact-sql) [sp_xml_removedocument &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-removedocument-transact-sql) [OPENXML &#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql) [XML Data &#40;SQL Server&#41;](../xml/xml-data-sql-server.md)</span></span>


