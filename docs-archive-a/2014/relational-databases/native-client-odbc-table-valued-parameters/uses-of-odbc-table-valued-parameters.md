---
title: 使用 ODBC 資料表值參數 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87708246"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="f3132-102">使用 ODBC 資料表值參數</span><span class="sxs-lookup"><span data-stu-id="f3132-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="f3132-103">本主題將討論搭配 ODBC 使用資料表值參數的主要使用者案例：</span><span class="sxs-lookup"><span data-stu-id="f3132-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="f3132-104">完整繫結多資料列緩衝區之下的資料表值參數 (使用記憶體中的所有值，將資料當做 TVP 傳送)</span><span class="sxs-lookup"><span data-stu-id="f3132-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="f3132-105">以資料流方式傳送資料列的資料表值參數 (使用資料執行中，將資料當做 TVP 傳送)</span><span class="sxs-lookup"><span data-stu-id="f3132-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="f3132-106">從系統目錄擷取資料表值參數中繼資料</span><span class="sxs-lookup"><span data-stu-id="f3132-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="f3132-107">針對準備好的陳述式擷取資料表值參數中繼資料</span><span class="sxs-lookup"><span data-stu-id="f3132-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="f3132-108">完整繫結多資料列緩衝區之下的資料表值參數 (使用記憶體中的所有值，將資料當做 TVP 傳送)</span><span class="sxs-lookup"><span data-stu-id="f3132-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="f3132-109">當搭配完整繫結的多資料列緩衝區使用時，記憶體中將提供所有參數值。</span><span class="sxs-lookup"><span data-stu-id="f3132-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="f3132-110">例如，這對於 OLTP 交易而言就是典型的情況，在這類交易中，資料表值參數可以封裝到單一預存程序中。</span><span class="sxs-lookup"><span data-stu-id="f3132-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="f3132-111">如果沒有資料表值參數，這會牽涉到動態產生複雜的多重陳述式批次，或是對伺服器進行多次呼叫。</span><span class="sxs-lookup"><span data-stu-id="f3132-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="f3132-112">資料表值參數本身會使用[SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328)和其他參數來系結。</span><span class="sxs-lookup"><span data-stu-id="f3132-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="f3132-113">所有參數都已系結之後，應用程式會在每個資料表值參數上設定參數焦點屬性 SQL_SOPT_SS_PARAM_FOCUS，並針對資料表值參數的資料行呼叫 SQLBindParameter。</span><span class="sxs-lookup"><span data-stu-id="f3132-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="f3132-114">資料表值參數的伺服器類型是 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 所特有的新類型 SQL_SS_TABLE。</span><span class="sxs-lookup"><span data-stu-id="f3132-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="f3132-115">SQL_SS_TABLE 的繫結 C 類型一定必須是 SQL_C_DEFAULT。</span><span class="sxs-lookup"><span data-stu-id="f3132-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="f3132-116">資料表值參數繫結的參數不會傳送任何資料；它是用來傳遞資料表中繼資料，以及控制要如何傳遞資料表值參數之組成資料行中的資料。</span><span class="sxs-lookup"><span data-stu-id="f3132-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="f3132-117">資料表值參數的長度會設定為傳送給伺服器的資料列數。</span><span class="sxs-lookup"><span data-stu-id="f3132-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="f3132-118">資料表值參數的 SQLBindParameter 的*ColumnSize*參數會指定可以傳送的最大資料列數;這是資料行緩衝區的陣列大小。</span><span class="sxs-lookup"><span data-stu-id="f3132-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="f3132-119">*ParameterValuePtr*是參數緩衝區，適用于 SQLBindParameter 中的資料表值參數。</span><span class="sxs-lookup"><span data-stu-id="f3132-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="f3132-120">*ParameterValuePtr*及其相關聯的*BufferLength*會在需要時用來傳遞資料表值參數的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="f3132-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="f3132-121">此類型名稱不是預存程序呼叫所需，但為 SQL 陳述式所需。</span><span class="sxs-lookup"><span data-stu-id="f3132-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="f3132-122">當資料表值參數類型名稱是在呼叫 SQLBindParameter 時指定時，一定要將它指定為 Unicode 值，即使在以 ANSI 應用程式形式建立的應用程式中也是如此。</span><span class="sxs-lookup"><span data-stu-id="f3132-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="f3132-123">當您使用 SQLSetDescField 指定資料表值參數類型名稱時，可以使用符合應用程式建立方式的常值。</span><span class="sxs-lookup"><span data-stu-id="f3132-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="f3132-124">ODBC 驅動程式管理員將會執行所有必要的 Unicode 轉換。</span><span class="sxs-lookup"><span data-stu-id="f3132-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="f3132-125">您可以使用 SQLGetDescRec、SQLSetDescRec、SQLGetDescField 和 SQLSetDescField，個別且明確地運算元據表值參數和資料表值參數資料行的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="f3132-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="f3132-126">不過，多載 SQLBindParameter 通常更方便，而且在大部分情況下都不需要明確的描述項存取。</span><span class="sxs-lookup"><span data-stu-id="f3132-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="f3132-127">這種方法與其他資料類型的 SQLBindParameter 定義一致，不同之處在于，針對資料表值參數，受影響的描述項欄位會稍有不同。</span><span class="sxs-lookup"><span data-stu-id="f3132-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="f3132-128">有時應用程式會搭配動態 SQL 使用資料表值參數，而且必須提供此資料表值參數的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="f3132-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="f3132-129">如果是這種情況，而且目前的連接預設架構中未定義資料表值參數，SQL_CA_SS_TYPE_CATALOG_NAME 和 SQL_CA_SS_TYPE_SCHEMA_NAME 就必須使用 SQLSetDescField 來設定。</span><span class="sxs-lookup"><span data-stu-id="f3132-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="f3132-130">因為資料表類型定義和資料表值參數必須在相同的資料庫中，所以如果應用程式使用資料表值參數，就不能設定 SQL_CA_SS_TYPE_CATALOG_NAME。</span><span class="sxs-lookup"><span data-stu-id="f3132-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="f3132-131">否則，SQLSetDescField 會報告錯誤。</span><span class="sxs-lookup"><span data-stu-id="f3132-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="f3132-132">此案例的範例程式碼位於 `demo_fixed_TVP_binding` [使用資料表值參數 &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)中。</span><span class="sxs-lookup"><span data-stu-id="f3132-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="f3132-133">以資料流方式傳送資料列的資料表值參數 (使用資料執行中，將資料當做 TVP 傳送)</span><span class="sxs-lookup"><span data-stu-id="f3132-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="f3132-134">在此案例中，應用程式會在要求時提供資料列給驅動程式，然後以資料流方式將資料列傳送給伺服器。</span><span class="sxs-lookup"><span data-stu-id="f3132-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="f3132-135">如此就不需要在記憶體中緩衝處理所有資料列。</span><span class="sxs-lookup"><span data-stu-id="f3132-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="f3132-136">這是大量插入/更新案例的代表。</span><span class="sxs-lookup"><span data-stu-id="f3132-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="f3132-137">資料表值參數會提供參數陣列與大量複製之間某一處的效能點。</span><span class="sxs-lookup"><span data-stu-id="f3132-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="f3132-138">也就是說，編寫資料表值參數就跟參數陣列一樣輕鬆，但是資料表值參數在伺服器上提供更大的彈性。</span><span class="sxs-lookup"><span data-stu-id="f3132-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="f3132-139">如同上一節「完整繫結多資料列緩衝區之下的資料表值參數」所討論，資料表值參數和它的資料行會繫結在一起，但是資料表值參數本身的長度指標會設定為 SQL_DATA_AT_EXEC。</span><span class="sxs-lookup"><span data-stu-id="f3132-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="f3132-140">驅動程式會以一般方式回應資料執行中參數的 SQLExecute 或 SQLExecuteDirect，也就是藉由傳回 SQL_NEED_DATA。</span><span class="sxs-lookup"><span data-stu-id="f3132-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="f3132-141">當驅動程式準備好接受資料表值參數的資料時，SQLParamData 會傳回 SQLBindParameter 中的*ParameterValuePtr*值。</span><span class="sxs-lookup"><span data-stu-id="f3132-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="f3132-142">應用程式會使用 SQLPutData 做為資料表值參數，以指出資料表值參數組成資料行的資料可用性。</span><span class="sxs-lookup"><span data-stu-id="f3132-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="f3132-143">針對資料表值參數呼叫 SQLPutData 時， *DataPtr*必須一律為 null，而且*StrLen_or_Ind*必須是0或小於或等於為數據表值參數緩衝區指定的陣列大小， (SQLBindParameter) 的*ColumnSize*參數。</span><span class="sxs-lookup"><span data-stu-id="f3132-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="f3132-144">0 表示資料表值參數沒有其他資料列，而且此驅動程式將會繼續處理下一個實際程序參數。</span><span class="sxs-lookup"><span data-stu-id="f3132-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="f3132-145">當*StrLen_or_Ind*不是0時，驅動程式將會以與非資料表值參數系結參數相同的方式來處理資料表值參數組成資料行：每個資料表值參數資料行都可以指定其實際的資料長度，SQL_Null_DATA，或可以透過其長度/指標緩衝區來指定執行中的資料。</span><span class="sxs-lookup"><span data-stu-id="f3132-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="f3132-146">資料表值參數資料行值可透過重複呼叫 SQLPutData 的方式傳遞，如同平常傳遞字元或二進位值時一樣。</span><span class="sxs-lookup"><span data-stu-id="f3132-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="f3132-147">當所有資料表值參數資料行都已經處理過之後，此驅動程式會回到資料表值參數來進一步處理資料表值參數資料的資料列。</span><span class="sxs-lookup"><span data-stu-id="f3132-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="f3132-148">因此，如果是資料執行中的資料表值參數，此驅動程式不會遵循一般的繫結參數循序掃描。</span><span class="sxs-lookup"><span data-stu-id="f3132-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="f3132-149">系結資料表值參數將會輪詢，直到*StrLen_Or_IndPtr*等於0的 SQLPutData 呼叫為止，此時驅動程式會略過資料表值參數資料行，並移至下一個實際的預存程式參數。</span><span class="sxs-lookup"><span data-stu-id="f3132-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="f3132-150">當 SQLPutData 傳遞大於或等於1的指標值時，驅動程式會依序處理資料表值參數資料行和資料列，直到它具有所有系結的資料列和資料行的值為止。</span><span class="sxs-lookup"><span data-stu-id="f3132-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="f3132-151">然後此驅動程式會回到資料表值參數。</span><span class="sxs-lookup"><span data-stu-id="f3132-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="f3132-152">在從 SQLParamData 接收資料表值參數的 token，並針對資料表值參數呼叫 SQLPutData (hstmt、Null、n) 之間，應用程式必須針對要傳遞至伺服器的下一個或多個資料列，設定資料表值參數組成資料行資料和指標緩衝區內容。</span><span class="sxs-lookup"><span data-stu-id="f3132-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="f3132-153">此案例的範例程式碼位於 `demo_variable_TVP_binding` [使用資料表值參數 &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)的常式中。</span><span class="sxs-lookup"><span data-stu-id="f3132-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="f3132-154">從系統目錄擷取資料表值參數中繼資料</span><span class="sxs-lookup"><span data-stu-id="f3132-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="f3132-155">當應用程式針對具有資料表值參數參數的程式呼叫 SQLProcedureColumns 時，會以 SQL_SS_TABLE 傳回 DATA_TYPE，而 TYPE_NAME 是資料表值參數之資料表類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="f3132-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="f3132-156">SQLProcedureColumns 傳回的結果集中會加入兩個額外的資料行： SS_TYPE_CATALOG_NAME 會傳回定義資料表值參數之資料表類型的目錄名稱，而 SS_TYPE_SCHEMA_NAME 會傳回架構的名稱，其中定義了資料表值參數的資料表類型。</span><span class="sxs-lookup"><span data-stu-id="f3132-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="f3132-157">依照 ODBC 規格規定，SS_TYPE_CATALOG_NAME 和 SS_TYPE_SCHEMA_NAME 會出現在舊版 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 中所加入的所有驅動程式特有資料行之前，以及 ODBC 本身所託管的所有資料行之後。</span><span class="sxs-lookup"><span data-stu-id="f3132-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="f3132-158">新的資料行不但會針對資料表值參數擴展，也會針對 CLR 使用者定義型別參數擴展。</span><span class="sxs-lookup"><span data-stu-id="f3132-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="f3132-159">仍然會擴展 UDT 參數現有的結構描述和目錄資料行，但是讓需要的資料類型擁有共同的結構描述和目錄資料行將會簡化未來的應用程式開發過程 </span><span class="sxs-lookup"><span data-stu-id="f3132-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="f3132-160">(請注意，XML 結構描述集合會有些不同，而且未包含在這項變更中)。</span><span class="sxs-lookup"><span data-stu-id="f3132-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="f3132-161">應用程式會使用 SQLTables 來判斷資料表類型的名稱，其方式與持續性資料表、系統資料表和視圖相同。</span><span class="sxs-lookup"><span data-stu-id="f3132-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="f3132-162">新的資料表類型 TABLE TYPE 已經導入，可讓應用程式識別與資料表值參數相關聯的資料表類型。</span><span class="sxs-lookup"><span data-stu-id="f3132-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="f3132-163">資料表類型和一般表格會使用不同的命名空間。</span><span class="sxs-lookup"><span data-stu-id="f3132-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="f3132-164">這表示，您可以將相同的名稱用於資料表類型和實際資料表。</span><span class="sxs-lookup"><span data-stu-id="f3132-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="f3132-165">為了處理這個情況，已經導入了新的陳述式屬性 SQL_SOPT_SS_NAME_SCOPE。</span><span class="sxs-lookup"><span data-stu-id="f3132-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="f3132-166">這個屬性會指定以資料表名稱做為參數的 SQLTables 和其他目錄函數是否應將資料表名稱解讀為實際資料表的名稱或資料表類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="f3132-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="f3132-167">應用程式會使用 SQLColumns 來判斷資料表類型的資料行，其方式與針對持續性資料表相同，但必須先設定 SQL_SOPT_SS_NAME_SCOPE，以指出它是使用資料表類型，而不是實際資料表。</span><span class="sxs-lookup"><span data-stu-id="f3132-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="f3132-168">SQLPrimaryKeys 也可以搭配資料表類型使用，再次使用 SQL_SOPT_SS_NAME_SCOPE。</span><span class="sxs-lookup"><span data-stu-id="f3132-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="f3132-169">此案例的範例程式碼位於 `demo_metadata_from_catalog_APIs` [使用資料表值參數 &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)的常式中。</span><span class="sxs-lookup"><span data-stu-id="f3132-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="f3132-170">針對準備好的陳述式擷取資料表值參數中繼資料</span><span class="sxs-lookup"><span data-stu-id="f3132-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="f3132-171">在此案例中，應用程式會使用 SQLNumParameters 和 SQLDescribeParam 來抓取資料表值參數的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="f3132-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="f3132-172">IPD 欄位 SQL_CA_SS_TYPE_NAME 是用來擷取資料表值參數的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="f3132-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="f3132-173">IPD 欄位 SQL_CA_SS_TYPE_SCHEMA_NAME 和 SQL_CA_SS_TYPE_CATALOG_NAME 是分別用來擷取它的目錄和結構描述。</span><span class="sxs-lookup"><span data-stu-id="f3132-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="f3132-174">資料表類型定義和資料表值參數必須在相同的資料庫中。</span><span class="sxs-lookup"><span data-stu-id="f3132-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="f3132-175">如果應用程式在使用資料表值參數時設定 SQL_CA_SS_TYPE_CATALOG_NAME，則 SQLSetDescField 會報告錯誤。</span><span class="sxs-lookup"><span data-stu-id="f3132-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="f3132-176">SQL_CA_SS_TYPE_CATALOG_NAME 和 SQL_CA_SS_TYPE_SCHEMA_NAME 也可以用來擷取與 CLR 使用者定義型別參數相關聯的目錄和結構描述。</span><span class="sxs-lookup"><span data-stu-id="f3132-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="f3132-177">SQL_CA_SS_TYPE_CATALOG_NAME 和 SQL_CA_SS_TYPE_SCHEMA_NAME 是 CLR UDT 類型的現有類型特有之目錄結構描述屬性的替代方式。</span><span class="sxs-lookup"><span data-stu-id="f3132-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="f3132-178">在此情況下，應用程式會使用 SQLColumns 來抓取資料表值參數的資料行中繼資料，因為 SQLDescribeParam 不會傳回資料表值參數資料行的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="f3132-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="f3132-179">此使用案例的範例程式碼位於 `demo_metadata_from_prepared_statement` [使用資料表值參數 &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)的常式中。</span><span class="sxs-lookup"><span data-stu-id="f3132-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f3132-180">另請參閱</span><span class="sxs-lookup"><span data-stu-id="f3132-180">See Also</span></span>  
 [<span data-ttu-id="f3132-181">ODBC&#41;&#40;的資料表值參數</span><span class="sxs-lookup"><span data-stu-id="f3132-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
