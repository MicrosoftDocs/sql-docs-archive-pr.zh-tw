---
title: 主要與外部索引鍵條件約束 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- foreign keys [SQL Server], cascading referential integrity
- FOREIGN KEY constraints
- foreign keys [SQL Server]
- foreign keys [SQL Server], about foreign key constraints
ms.assetid: 31fbcc9f-2dc5-4bf9-aa50-ed70ec7b5bcd
author: stevestein
ms.author: sstein
ms.openlocfilehash: b6e7b88de880348fabb00cb46d3028716441bc2b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87598763"
---
# <a name="primary-and-foreign-key-constraints"></a><span data-ttu-id="4f949-102">主要與外部索引鍵條件約束</span><span class="sxs-lookup"><span data-stu-id="4f949-102">Primary and Foreign Key Constraints</span></span>
  <span data-ttu-id="4f949-103">主索引鍵和外部索引鍵是兩種類型的條件約束，可用以強制執行 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 資料表中的資料完整性。</span><span class="sxs-lookup"><span data-stu-id="4f949-103">Primary keys and foreign keys are two types of constraints that can be used to enforce data integrity in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] tables.</span></span> <span data-ttu-id="4f949-104">這些都是重要的資料庫物件。</span><span class="sxs-lookup"><span data-stu-id="4f949-104">These are important database objects.</span></span>

 <span data-ttu-id="4f949-105">本主題包含下列各節。</span><span class="sxs-lookup"><span data-stu-id="4f949-105">This topic contains the following sections.</span></span>

 [<span data-ttu-id="4f949-106">主索引鍵條件約束</span><span class="sxs-lookup"><span data-stu-id="4f949-106">Primary Key Constraints</span></span>](../tables/primary-and-foreign-key-constraints.md#PKeys)

 [<span data-ttu-id="4f949-107">Foreign Key Constraints</span><span class="sxs-lookup"><span data-stu-id="4f949-107">Foreign Key Constraints</span></span>](../tables/primary-and-foreign-key-constraints.md#FKeys)

 [<span data-ttu-id="4f949-108">相關工作</span><span class="sxs-lookup"><span data-stu-id="4f949-108">Related Tasks</span></span>](../tables/primary-and-foreign-key-constraints.md#Tasks)

##  <a name="primary-key-constraints"></a><a name="PKeys"></a> <span data-ttu-id="4f949-109">主索引鍵條件約束</span><span class="sxs-lookup"><span data-stu-id="4f949-109">Primary Key Constraints</span></span>
 <span data-ttu-id="4f949-110">資料表中通常會有一個或多個資料行包含可唯一識別資料表中每個資料列的值。</span><span class="sxs-lookup"><span data-stu-id="4f949-110">A table typically has a column or combination of columns that contain values that uniquely identify each row in the table.</span></span> <span data-ttu-id="4f949-111">此資料行稱為資料表的主索引鍵 (PK)，強制資料表具有實體完整性。</span><span class="sxs-lookup"><span data-stu-id="4f949-111">This column, or columns, is called the primary key (PK) of the table and enforces the entity integrity of the table.</span></span> <span data-ttu-id="4f949-112">主索引鍵條件約束保證唯一的資料，因此通常是定義在識別欄位上。</span><span class="sxs-lookup"><span data-stu-id="4f949-112">Because primary key constraints guarantee unique data, they are frequently defined on an identity column.</span></span>

 <span data-ttu-id="4f949-113">當您為資料表指定主索引鍵條件約束時， [!INCLUDE[ssDE](../../includes/ssde-md.md)] 會自動為主索引鍵資料行建立唯一的索引，以強制資料的唯一性。</span><span class="sxs-lookup"><span data-stu-id="4f949-113">When you specify a primary key constraint for a table, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] enforces data uniqueness by automatically creating a unique index for the primary key columns.</span></span> <span data-ttu-id="4f949-114">當主索引鍵用於查詢時，此索引也可讓您快速地存取資料。</span><span class="sxs-lookup"><span data-stu-id="4f949-114">This index also permits fast access to data when the primary key is used in queries.</span></span> <span data-ttu-id="4f949-115">若主索引鍵條件約束定義於多個資料行，則某個資料行內的值可能會重複，但主索引鍵條件約束定義中所有資料行的每個值組合都必須是唯一的。</span><span class="sxs-lookup"><span data-stu-id="4f949-115">If a primary key constraint is defined on more than one column, values may be duplicated within one column, but each combination of values from all the columns in the primary key constraint definition must be unique.</span></span>

 <span data-ttu-id="4f949-116">如下圖所示， **Purchasing.ProductVendor** 資料表中的 **ProductID** 和 **VendorID** 資料行形成此資料表的複合主索引鍵條件約束。</span><span class="sxs-lookup"><span data-stu-id="4f949-116">As shown in the following illustration, the **ProductID** and **VendorID** columns in the **Purchasing.ProductVendor** table form a composite primary key constraint for this table.</span></span> <span data-ttu-id="4f949-117">這樣可確保 **ProductVendor** 資料表中的每個資料列都有唯一的 **ProductID** 與 **VendorID** 組合。</span><span class="sxs-lookup"><span data-stu-id="4f949-117">This makes sure that every row in the **ProductVendor** table has a unique combination of **ProductID** and **VendorID**.</span></span> <span data-ttu-id="4f949-118">如此可防止插入重複的資料列。</span><span class="sxs-lookup"><span data-stu-id="4f949-118">This prevents the insertion of duplicate rows.</span></span>

 <span data-ttu-id="4f949-119">![複合 PRIMARY KEY 條件約束](../../database-engine/media/fund04.gif "複合 PRIMARY KEY 條件約束")</span><span class="sxs-lookup"><span data-stu-id="4f949-119">![Composite PRIMARY KEY constraint](../../database-engine/media/fund04.gif "Composite PRIMARY KEY constraint")</span></span>

-   <span data-ttu-id="4f949-120">一份資料表只能有一個主索引鍵條件約束。</span><span class="sxs-lookup"><span data-stu-id="4f949-120">A table can contain only one primary key constraint.</span></span>

-   <span data-ttu-id="4f949-121">主索引鍵不能超出 16 個資料行，總索引鍵長度則不能超出 900 個位元組。</span><span class="sxs-lookup"><span data-stu-id="4f949-121">A primary key cannot exceed 16 columns and a total key length of 900 bytes.</span></span>

-   <span data-ttu-id="4f949-122">主索引鍵條件約束所產生的索引無法讓資料表的索引數目超出 999 個非叢集索引和 1 個叢集索引。</span><span class="sxs-lookup"><span data-stu-id="4f949-122">The index generated by a primary key constraint cannot cause the number of indexes on the table to exceed 999 nonclustered indexes and 1 clustered index.</span></span>

-   <span data-ttu-id="4f949-123">如果未指定主索引鍵條件約束的叢集或非叢集，則會在資料表上沒有叢集索引時使用叢集。</span><span class="sxs-lookup"><span data-stu-id="4f949-123">If clustered or nonclustered is not specified for a primary key constraint, clustered is used if there no clustered index on the table.</span></span>

-   <span data-ttu-id="4f949-124">主索引鍵條件約束內定義的所有資料行都必須定義為非 Null。</span><span class="sxs-lookup"><span data-stu-id="4f949-124">All columns defined within a primary key constraint must be defined as not null.</span></span> <span data-ttu-id="4f949-125">如果未指定 Null 屬性，參與主索引鍵條件約束之所有資料行的 Null 屬性都會設成非 Null。</span><span class="sxs-lookup"><span data-stu-id="4f949-125">If nullability is not specified, all columns participating in a primary key constraint have their nullability set to not null.</span></span>

-   <span data-ttu-id="4f949-126">如果在 CLR 使用者定義的類型資料行上定義主索引鍵，類型的實作必須支援二進位排序。</span><span class="sxs-lookup"><span data-stu-id="4f949-126">If a primary key is defined on a CLR user-defined type column, the implementation of the type must support binary ordering.</span></span>

##  <a name="foreign-key-constraints"></a><a name="FKeys"></a> <span data-ttu-id="4f949-127">Foreign Key Constraints</span><span class="sxs-lookup"><span data-stu-id="4f949-127">Foreign Key Constraints</span></span>
 <span data-ttu-id="4f949-128">外部索引鍵 (FK) 是可用來建立與強制兩資料表的資料之間連結的一個資料行或資料行組合，以控制外部索引鍵資料表中可儲存的資料。</span><span class="sxs-lookup"><span data-stu-id="4f949-128">A foreign key (FK) is a column or combination of columns that is used to establish and enforce a link between the data in two tables to control the data that can be stored in the foreign key table.</span></span> <span data-ttu-id="4f949-129">在外部索引鍵參考中，當存放一個資料表的主索引鍵值的資料行被另一個資料表的資料行參考時，兩資料表之間會建立連結。</span><span class="sxs-lookup"><span data-stu-id="4f949-129">In a foreign key reference, a link is created between two tables when the column or columns that hold the primary key value for one table are referenced by the column or columns in another table.</span></span> <span data-ttu-id="4f949-130">此資料行會成為第二個資料表的外部索引鍵。</span><span class="sxs-lookup"><span data-stu-id="4f949-130">This column becomes a foreign key in the second table.</span></span>

 <span data-ttu-id="4f949-131">例如， **Sales.SalesOrderHeader** 資料表具有與 **Sales.SalesPerson** 資料表的外部索引鍵連結，因為銷售訂單與銷售人員之間存在邏輯關聯性。</span><span class="sxs-lookup"><span data-stu-id="4f949-131">For example, the **Sales.SalesOrderHeader** table has a foreign key link to the **Sales.SalesPerson** table because there is a logical relationship between sales orders and salespeople.</span></span> <span data-ttu-id="4f949-132">**SalesOrderHeader** 資料表中的 **SalesPersonID** 資料行符合 **SalesPerson** 資料表的主索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="4f949-132">The **SalesPersonID** column in the **SalesOrderHeader** table matches the primary key column of the **SalesPerson** table.</span></span> <span data-ttu-id="4f949-133">**SalesOrderHeader** 資料表中的 **SalesPersonID** 資料行是 **SalesPerson** 資料表的外部索引鍵。</span><span class="sxs-lookup"><span data-stu-id="4f949-133">The **SalesPersonID** column in the **SalesOrderHeader** table is the foreign key to the **SalesPerson** table.</span></span> <span data-ttu-id="4f949-134">透過建立這個外部索引鍵關聯性，如果 **SalesPersonID** 的值尚未存在於 **SalesPerson** 資料表中，就不能將其插入至 **SalesOrderHeader** 資料表。</span><span class="sxs-lookup"><span data-stu-id="4f949-134">By creating this foreign key relationship, a value for **SalesPersonID** cannot be inserted into the **SalesOrderHeader** table if it does not already exist in the **SalesPerson** table.</span></span>

### <a name="indexes-on-foreign-key-constraints"></a><span data-ttu-id="4f949-135">外部索引鍵條件約束上的索引</span><span class="sxs-lookup"><span data-stu-id="4f949-135">Indexes on Foreign Key Constraints</span></span>
 <span data-ttu-id="4f949-136">與主索引鍵條件約束不同，建立外部索引鍵條件約束並不會自動建立對應的索引。</span><span class="sxs-lookup"><span data-stu-id="4f949-136">Unlike primary key constraints, creating a foreign key constraint does not automatically create a corresponding index.</span></span> <span data-ttu-id="4f949-137">不過，基於下列原因，在外部索引鍵上手動建立索引通常很有幫助：</span><span class="sxs-lookup"><span data-stu-id="4f949-137">However, manually creating an index on a foreign key is often useful for the following reasons:</span></span>

-   <span data-ttu-id="4f949-138">當關聯資料表的資料藉著將資料表的外部索引鍵條件約束和另一個資料表的主要或唯一索引鍵資料行進行比對，而合併於查詢中時，通常會使用外部索引鍵資料行來聯結準則。</span><span class="sxs-lookup"><span data-stu-id="4f949-138">Foreign key columns are frequently used in join criteria when the data from related tables is combined in queries by matching the column or columns in the foreign key constraint of one table with the primary or unique key column or columns in the other table.</span></span> <span data-ttu-id="4f949-139">索引可讓 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 在外部索引鍵資料表中快速尋找相關資料。</span><span class="sxs-lookup"><span data-stu-id="4f949-139">An index enables the [!INCLUDE[ssDE](../../includes/ssde-md.md)] to quickly find related data in the foreign key table.</span></span> <span data-ttu-id="4f949-140">不過，建立此索引並非必要。</span><span class="sxs-lookup"><span data-stu-id="4f949-140">However, creating this index is not required.</span></span> <span data-ttu-id="4f949-141">即使資料表之間未定義主索引鍵或外部索引鍵條件約束，仍可合併兩個相關資料表的資料，不過兩個資料表之間的外部索引鍵關聯性代表這兩個資料表已經過最佳化，可合併於使用該索引鍵做為準則的查詢中。</span><span class="sxs-lookup"><span data-stu-id="4f949-141">Data from two related tables can be combined even if no primary key or foreign key constraints are defined between the tables, but a foreign key relationship between two tables indicates that the two tables have been optimized to be combined in a query that uses the keys as its criteria.</span></span>

-   <span data-ttu-id="4f949-142">系統會檢查主索引鍵條件約束的變更與相關資料表中的外部索引鍵條件約束。</span><span class="sxs-lookup"><span data-stu-id="4f949-142">Changes to primary key constraints are checked with foreign key constraints in related tables.</span></span>

### <a name="referential-integrity"></a><span data-ttu-id="4f949-143">參考完整性</span><span class="sxs-lookup"><span data-stu-id="4f949-143">Referential Integrity</span></span>
 <span data-ttu-id="4f949-144">雖然外部索引鍵條件約束的主要用途是控制可儲存在外部索引鍵資料表中的資料，但是它也可控制主索引鍵資料表中資料的變更。</span><span class="sxs-lookup"><span data-stu-id="4f949-144">Although the main purpose of a foreign key constraint is to control the data that can be stored in the foreign key table, it also controls changes to data in the primary key table.</span></span> <span data-ttu-id="4f949-145">例如，將銷售員的資料列從 **Sales.SalesPerson** 資料表中刪除，而該銷售員的識別碼是用於 **Sales.SalesOrderHeader** 資料表的銷售訂單中，則會中斷這兩個資料表的關聯完整性；會遺棄 **SalesOrderHeader** 資料表中所刪除銷售員的銷售訂單，因為無法連結到 **SalesPerson** 資料表中的資料。</span><span class="sxs-lookup"><span data-stu-id="4f949-145">For example, if the row for a salesperson is deleted from the **Sales.SalesPerson** table, and the salesperson's ID is used for sales orders in the **Sales.SalesOrderHeader** table, the relational integrity between the two tables is broken; the deleted salesperson's sales orders are orphaned in the **SalesOrderHeader** table without a link to the data in the **SalesPerson** table.</span></span>

 <span data-ttu-id="4f949-146">外部索引鍵條件約束可防止這種情況。</span><span class="sxs-lookup"><span data-stu-id="4f949-146">A foreign key constraint prevents this situation.</span></span> <span data-ttu-id="4f949-147">若針對主索引鍵資料表的資料所做的變更，會讓指到外部索引鍵資料表內資料的連結無效，則此條件約束會禁止執行此變更，以強制參考完整性。</span><span class="sxs-lookup"><span data-stu-id="4f949-147">The constraint enforces referential integrity by guaranteeing that changes cannot be made to data in the primary key table if those changes invalidate the link to data in the foreign key table.</span></span> <span data-ttu-id="4f949-148">若您想刪除主索引鍵資料表中的資料列，或變更主索引鍵值，則在刪除或變更的主索引鍵值對應至另一個資料表之外部索引鍵條件約束中的值時，此動作將會失敗。</span><span class="sxs-lookup"><span data-stu-id="4f949-148">If an attempt is made to delete the row in a primary key table or to change a primary key value, the action will fail when the deleted or changed primary key value corresponds to a value in the foreign key constraint of another table.</span></span> <span data-ttu-id="4f949-149">若要順利變更或刪除外部索引鍵條件約束中的資料列，則必須先刪除外部索引鍵資料表中的外部索引鍵資料，或變更外部索引鍵資料表中的外部索引鍵資料，這樣會將外部索引鍵連結至不同的主索引鍵資料。</span><span class="sxs-lookup"><span data-stu-id="4f949-149">To successfully change or delete a row in a foreign key constraint, you must first either delete the foreign key data in the foreign key table or change the foreign key data in the foreign key table, which links the foreign key to different primary key data.</span></span>

#### <a name="cascading-referential-integrity"></a><span data-ttu-id="4f949-150">串聯式參考完整性</span><span class="sxs-lookup"><span data-stu-id="4f949-150">Cascading Referential Integrity</span></span>
 <span data-ttu-id="4f949-151">使用串聯式參考完整性條件約束，就可以定義使用者嘗試刪除或更新現有外部索引鍵所指向的索引鍵時， [!INCLUDE[ssDE](../../includes/ssde-md.md)] 所採取的動作。</span><span class="sxs-lookup"><span data-stu-id="4f949-151">By using cascading referential integrity constraints, you can define the actions that the [!INCLUDE[ssDE](../../includes/ssde-md.md)] takes when a user tries to delete or update a key to which existing foreign keys point.</span></span> <span data-ttu-id="4f949-152">可以定義下列串聯式動作。</span><span class="sxs-lookup"><span data-stu-id="4f949-152">The following cascading actions can be defined.</span></span>

 <span data-ttu-id="4f949-153">沒有動作 [!INCLUDE[ssDE](../../includes/ssde-md.md)] ：會引發錯誤，而且會回復父資料表中資料列的刪除或更新動作。</span><span class="sxs-lookup"><span data-stu-id="4f949-153">NO ACTION The [!INCLUDE[ssDE](../../includes/ssde-md.md)] raises an error and the delete or update action on the row in the parent table is rolled back.</span></span>

 <span data-ttu-id="4f949-154">當父資料表中的資料列更新或刪除時，會在參考資料表中更新或刪除 CASCADE 對應的資料列。</span><span class="sxs-lookup"><span data-stu-id="4f949-154">CASCADE Corresponding rows are updated or deleted in the referencing table when that row is updated or deleted in the parent table.</span></span> <span data-ttu-id="4f949-155">如果 `timestamp` 資料行是外部索引鍵或被參考索引鍵的一部分，就無法指定 CASCADE。</span><span class="sxs-lookup"><span data-stu-id="4f949-155">CASCADE cannot be specified if a `timestamp` column is part of either the foreign key or the referenced key.</span></span> <span data-ttu-id="4f949-156">如果資料表有 INSTEAD OF DELETE 觸發程序，則不能指定 ON DELETE CASCADE。</span><span class="sxs-lookup"><span data-stu-id="4f949-156">ON DELETE CASCADE cannot be specified for a table that has an INSTEAD OF DELETE trigger.</span></span> <span data-ttu-id="4f949-157">如果資料表有 INSTEAD OF UPDATE 觸發程序，則不能指定 ON UPDATE CASCADE。</span><span class="sxs-lookup"><span data-stu-id="4f949-157">ON UPDATE CASCADE cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="4f949-158">SET Null：當更新或刪除父資料表中對應的資料列時，所有組成外鍵的值都會設為 Null。</span><span class="sxs-lookup"><span data-stu-id="4f949-158">SET NULL All the values that make up the foreign key are set to NULL when the corresponding row in the parent table is updated or deleted.</span></span> <span data-ttu-id="4f949-159">若要執行這個條件約束，外部索引鍵資料行必須可為 Null。</span><span class="sxs-lookup"><span data-stu-id="4f949-159">For this constraint to execute, the foreign key columns must be nullable.</span></span> <span data-ttu-id="4f949-160">如果資料表有 INSTEAD OF UPDATE 觸發程序，則不能予以指定。</span><span class="sxs-lookup"><span data-stu-id="4f949-160">Cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="4f949-161">SET DEFAULT 如果父資料表中對應的資料列已更新或刪除，則所有組成外鍵的值都會設為其預設值。</span><span class="sxs-lookup"><span data-stu-id="4f949-161">SET DEFAULT All the values that make up the foreign key are set to their default values if the corresponding row in the parent table is updated or deleted.</span></span> <span data-ttu-id="4f949-162">若要執行這個條件約束，所有外部索引鍵資料行都必須有預設定義。</span><span class="sxs-lookup"><span data-stu-id="4f949-162">For this constraint to execute, all foreign key columns must have default definitions.</span></span> <span data-ttu-id="4f949-163">如果有可為 Null 的資料行，但沒有設定明確的預設值，NULL 便成為這個資料行的隱含預設值。</span><span class="sxs-lookup"><span data-stu-id="4f949-163">If a column is nullable, and there is no explicit default value set, NULL becomes the implicit default value of the column.</span></span> <span data-ttu-id="4f949-164">如果資料表有 INSTEAD OF UPDATE 觸發程序，則不能予以指定。</span><span class="sxs-lookup"><span data-stu-id="4f949-164">Cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="4f949-165">您可以在相互具有參考關聯性的資料表上，組合 CASCADE、SET NULL、SET DEFAULT 和 NO ACTION。</span><span class="sxs-lookup"><span data-stu-id="4f949-165">CASCADE, SET NULL, SET DEFAULT and NO ACTION can be combined on tables that have referential relationships with each other.</span></span> <span data-ttu-id="4f949-166">如果 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 發現 NO ACTION，它會停止和回復相關的 CASCADE、SET NULL 和 SET DEFAULT 動作。</span><span class="sxs-lookup"><span data-stu-id="4f949-166">If the [!INCLUDE[ssDE](../../includes/ssde-md.md)] encounters NO ACTION, it stops and rolls back related CASCADE, SET NULL and SET DEFAULT actions.</span></span> <span data-ttu-id="4f949-167">當 DELETE 陳述式造成 CASCADE、SET NULL、SET DEFAULT 和 NO ACTION 等動作的組合時，在 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 檢查任何 NO ACTION 之前，會先套用 CASCADE、SET NULL 及 SET DEFAULT 等動作。</span><span class="sxs-lookup"><span data-stu-id="4f949-167">When a DELETE statement causes a combination of CASCADE, SET NULL, SET DEFAULT and NO ACTION actions, all the CASCADE, SET NULL and SET DEFAULT actions are applied before the [!INCLUDE[ssDE](../../includes/ssde-md.md)] checks for any NO ACTION.</span></span>

### <a name="triggers-and-cascading-referential-actions"></a><span data-ttu-id="4f949-168">觸發程序與串聯式參考動作</span><span class="sxs-lookup"><span data-stu-id="4f949-168">Triggers and Cascading Referential Actions</span></span>
 <span data-ttu-id="4f949-169">串聯式參考動作會以下列方式引發 AFTER UPDATE 或 AFTER DELETE 觸發程序：</span><span class="sxs-lookup"><span data-stu-id="4f949-169">Cascading referential actions fire the AFTER UPDATE or AFTER DELETE triggers in the following manner:</span></span>

-   <span data-ttu-id="4f949-170">直接由原始 DELETE 或 UPDATE 造成的所有串聯式參考動作會最先執行。</span><span class="sxs-lookup"><span data-stu-id="4f949-170">All the cascading referential actions directly caused by the original DELETE or UPDATE are performed first.</span></span>

-   <span data-ttu-id="4f949-171">如果已在受影響的資料表上定義任何 AFTER 觸發程序，這些觸發程序將會在執行所有串聯式動作後引發。</span><span class="sxs-lookup"><span data-stu-id="4f949-171">If there are any AFTER triggers defined on the affected tables, these triggers fire after all cascading actions are performed.</span></span> <span data-ttu-id="4f949-172">這些觸發程序的引發順序，將會與串聯式動作相反。</span><span class="sxs-lookup"><span data-stu-id="4f949-172">These triggers fire in opposite order of the cascading action.</span></span> <span data-ttu-id="4f949-173">如果單一資料表上有多個觸發程序，則除非資料表有專用的第一個或最後一個觸發程序，否則將會以隨機順序引發。</span><span class="sxs-lookup"><span data-stu-id="4f949-173">If there are multiple triggers on a single table, they fire in random order, unless there is a dedicated first or last trigger for the table.</span></span> <span data-ttu-id="4f949-174">這個順序是使用 [sp_settriggerorder](/sql/relational-databases/system-stored-procedures/sp-settriggerorder-transact-sql)指定。</span><span class="sxs-lookup"><span data-stu-id="4f949-174">This order is as specified by using [sp_settriggerorder](/sql/relational-databases/system-stored-procedures/sp-settriggerorder-transact-sql).</span></span>

-   <span data-ttu-id="4f949-175">若有多個串聯式鏈結源自 UPDATE 或 DELETE 動作的直接目標資料表，則這些鏈結引發其各自觸發程序的順序未定。</span><span class="sxs-lookup"><span data-stu-id="4f949-175">If multiple cascading chains originate from the table that was the direct target of an UPDATE or DELETE action, the order in which these chains fire their respective triggers is unspecified.</span></span> <span data-ttu-id="4f949-176">不過，一定會等到一個鏈結引發完其所有觸發程序後，才引發另外一個鏈結。</span><span class="sxs-lookup"><span data-stu-id="4f949-176">However, one chain always fires all its triggers before another chain starts firing.</span></span>

-   <span data-ttu-id="4f949-177">不論是否有任何資料列受到影響，UPDATE 或 DELETE 動作都會引發直接目標資料表上的 AFTER 觸發程序。</span><span class="sxs-lookup"><span data-stu-id="4f949-177">An AFTER trigger on the table that is the direct target of an UPDATE or DELETE action fires regardless of whether any rows are affected.</span></span> <span data-ttu-id="4f949-178">在此情況下，沒有任何其他資料會受到串聯的影響。</span><span class="sxs-lookup"><span data-stu-id="4f949-178">There are no other tables affected by cascading in this case.</span></span>

-   <span data-ttu-id="4f949-179">若有任何一個先前的觸發程序在其他資料表上執行 UPDATE 或 DELETE 作業，這些動作便形成次要串聯式鏈結。</span><span class="sxs-lookup"><span data-stu-id="4f949-179">If any one of the previous triggers perform UPDATE or DELETE operations on other tables, these actions can start secondary cascading chains.</span></span> <span data-ttu-id="4f949-180">每個 UPDATE 或 DELETE 作業的次要鏈結會在所有主要鏈結的所有觸發程序之後的某個時間處理。</span><span class="sxs-lookup"><span data-stu-id="4f949-180">These secondary chains are processed for each UPDATE or DELETE operation at a time after all triggers on all primary chains fire.</span></span> <span data-ttu-id="4f949-181">這個處理序可能會針對後續的 UPDATE 或 DELETE 作業不斷重複。</span><span class="sxs-lookup"><span data-stu-id="4f949-181">This process may be recursively repeated for subsequent UPDATE or DELETE operations.</span></span>

-   <span data-ttu-id="4f949-182">在觸發程序內執行 CREATE、ALTER、DELETE 或其他資料定義語言 (DDL) 作業，可能會導致引發 DDL 觸發程序。</span><span class="sxs-lookup"><span data-stu-id="4f949-182">Performing CREATE, ALTER, DELETE, or other data definition language (DDL) operations inside the triggers may cause DDL triggers to fire.</span></span> <span data-ttu-id="4f949-183">這可能會接著執行 DELETE 或 UPDATE 作業，開始其他串聯式鏈結與觸發程序。</span><span class="sxs-lookup"><span data-stu-id="4f949-183">This may subsequently perform DELETE or UPDATE operations that start additional cascading chains and triggers.</span></span>

-   <span data-ttu-id="4f949-184">如果任何特定串聯式參考動作鏈結內產生錯誤，則會引發錯誤，此時並不會在該鏈結中引發任何 AFTER 觸發程序，而且會回復建立該鏈結的 DELETE 或 UPDATE 作業。</span><span class="sxs-lookup"><span data-stu-id="4f949-184">If an error is generated inside any particular cascading referential action chain, an error is raised, no AFTER triggers are fired in that chain, and the DELETE or UPDATE operation that created the chain is rolled back.</span></span>

-   <span data-ttu-id="4f949-185">具有 INSTEAD OF 觸發程序的資料表不能也具有指定串聯動作的 REFERENCES 子句。</span><span class="sxs-lookup"><span data-stu-id="4f949-185">A table that has an INSTEAD OF trigger cannot also have a REFERENCES clause that specifies a cascading action.</span></span> <span data-ttu-id="4f949-186">不過，串聯式動作所處理之資料表上的 AFTER 觸發程序，可在另一個資料表或檢視表上執行 INSERT、UPDATE 或 DELETE 陳述式，以引發該物件所定義的 INSTEAD OF 觸發程序。</span><span class="sxs-lookup"><span data-stu-id="4f949-186">However, an AFTER trigger on a table targeted by a cascading action can execute an INSERT, UPDATE, or DELETE statement on another table or view that fires an INSTEAD OF trigger defined on that object.</span></span>

##  <a name="related-tasks"></a><a name="Tasks"></a> <span data-ttu-id="4f949-187">相關工作</span><span class="sxs-lookup"><span data-stu-id="4f949-187">Related Tasks</span></span>
 <span data-ttu-id="4f949-188">下表列出與主索引鍵和外部索引鍵條件約束相關聯的一般工作。</span><span class="sxs-lookup"><span data-stu-id="4f949-188">The following table lists the common tasks associated with primary key and foreign key constraints.</span></span>

|<span data-ttu-id="4f949-189">Task</span><span class="sxs-lookup"><span data-stu-id="4f949-189">Task</span></span>|<span data-ttu-id="4f949-190">主題</span><span class="sxs-lookup"><span data-stu-id="4f949-190">Topic</span></span>|
|----------|-----------|
|<span data-ttu-id="4f949-191">描述如何建立主索引鍵。</span><span class="sxs-lookup"><span data-stu-id="4f949-191">Describes how to create a primary key.</span></span>|[<span data-ttu-id="4f949-192">建立主索引鍵</span><span class="sxs-lookup"><span data-stu-id="4f949-192">Create Primary Keys</span></span>](../tables/create-primary-keys.md)|
|<span data-ttu-id="4f949-193">描述如何刪除主索引鍵。</span><span class="sxs-lookup"><span data-stu-id="4f949-193">Describes how to delete a primary key.</span></span>|[<span data-ttu-id="4f949-194">刪除主索引鍵</span><span class="sxs-lookup"><span data-stu-id="4f949-194">Delete Primary Keys</span></span>](../tables/delete-primary-keys.md)|
|<span data-ttu-id="4f949-195">描述如何修改主索引鍵。</span><span class="sxs-lookup"><span data-stu-id="4f949-195">Describes how to modify a primary key.</span></span>|[<span data-ttu-id="4f949-196">修改主索引鍵</span><span class="sxs-lookup"><span data-stu-id="4f949-196">Modify Primary Keys</span></span>](../tables/modify-primary-keys.md)|
|<span data-ttu-id="4f949-197">描述如何建立外部索引鍵關聯性。</span><span class="sxs-lookup"><span data-stu-id="4f949-197">Describes how to create foreign key relationships</span></span>|[<span data-ttu-id="4f949-198">建立外部索引鍵關聯性</span><span class="sxs-lookup"><span data-stu-id="4f949-198">Create Foreign Key Relationships</span></span>](../tables/create-foreign-key-relationships.md)|
|<span data-ttu-id="4f949-199">描述如何修改外部索引鍵關聯性。</span><span class="sxs-lookup"><span data-stu-id="4f949-199">Describes how to modify foreign key relationships.</span></span>|[<span data-ttu-id="4f949-200">修改外部索引鍵關聯性</span><span class="sxs-lookup"><span data-stu-id="4f949-200">Modify Foreign Key Relationships</span></span>](../tables/modify-foreign-key-relationships.md)|
|<span data-ttu-id="4f949-201">描述如何刪除外部索引鍵關聯性。</span><span class="sxs-lookup"><span data-stu-id="4f949-201">Describes how to delete foreign key relationships.</span></span>|[<span data-ttu-id="4f949-202">刪除外部索引鍵關聯性</span><span class="sxs-lookup"><span data-stu-id="4f949-202">Delete Foreign Key Relationships</span></span>](../tables/delete-foreign-key-relationships.md)|
|<span data-ttu-id="4f949-203">描述如何檢視外部索引鍵屬性。</span><span class="sxs-lookup"><span data-stu-id="4f949-203">Describes how to view foreign key properties.</span></span>|[<span data-ttu-id="4f949-204">檢視外部索引鍵屬性</span><span class="sxs-lookup"><span data-stu-id="4f949-204">View Foreign Key Properties</span></span>](../tables/view-foreign-key-properties.md)|
|<span data-ttu-id="4f949-205">描述如何停用複寫的外部索引鍵條件約束。</span><span class="sxs-lookup"><span data-stu-id="4f949-205">Describes how to disable foreign key constraints for replication.</span></span>|[<span data-ttu-id="4f949-206">停用複寫的外部索引鍵條件約束</span><span class="sxs-lookup"><span data-stu-id="4f949-206">Disable Foreign Key Constraints for Replication</span></span>](../tables/disable-foreign-key-constraints-for-replication.md)|
|<span data-ttu-id="4f949-207">描述如何在 INSERT 或 UPDATE 陳述式期間停用外部索引鍵條件約束。</span><span class="sxs-lookup"><span data-stu-id="4f949-207">Describes how to disable foreign key constraints during an INSERT or UPDATE statement.</span></span>|[<span data-ttu-id="4f949-208">停用 INSERT 和 UPDATE 陳述式的外部索引鍵條件約束</span><span class="sxs-lookup"><span data-stu-id="4f949-208">Disable Foreign Key Constraints with INSERT and UPDATE Statements</span></span>](../tables/disable-foreign-key-constraints-with-insert-and-update-statements.md)|


