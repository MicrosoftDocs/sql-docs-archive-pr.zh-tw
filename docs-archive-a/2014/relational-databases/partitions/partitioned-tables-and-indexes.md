---
title: 資料分割資料表與索引 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87707418"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="0e842-102">分割資料表與索引</span><span class="sxs-lookup"><span data-stu-id="0e842-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="0e842-103">支援資料表和索引資料分割。</span><span class="sxs-lookup"><span data-stu-id="0e842-103">supports table and index partitioning.</span></span> <span data-ttu-id="0e842-104">資料分割資料表和索引的資料，已分成可以在資料庫中的多個檔案群組之間分佈的單位。</span><span class="sxs-lookup"><span data-stu-id="0e842-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="0e842-105">資料是以水平方式分割，因此資料列的群組可對應至個別的資料分割。</span><span class="sxs-lookup"><span data-stu-id="0e842-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="0e842-106">單一索引或資料表的所有分割區必須在同一個資料庫中。</span><span class="sxs-lookup"><span data-stu-id="0e842-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="0e842-107">在資料上執行查詢或更新時，資料表或索引會被視為單一邏輯實體。</span><span class="sxs-lookup"><span data-stu-id="0e842-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="0e842-108">並非每個 [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 版本都可使用資料分割資料表和索引。</span><span class="sxs-lookup"><span data-stu-id="0e842-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="0e842-109">如需版本支援的功能清單 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ，請參閱[SQL Server 2014 版本支援的功能](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md)。</span><span class="sxs-lookup"><span data-stu-id="0e842-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="0e842-110">預設最多支援 15,000 個資料分割。</span><span class="sxs-lookup"><span data-stu-id="0e842-110">supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="0e842-111">在 [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]之前版本中，資料分割數目預設限制為 1,000。在 x86 型系統上，可以建立超過 1000 個資料分割的資料表或索引，但不予支援。</span><span class="sxs-lookup"><span data-stu-id="0e842-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="0e842-112">資料分割的優點</span><span class="sxs-lookup"><span data-stu-id="0e842-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="0e842-113">對大型資料表或索引進行資料分割，可以具有下列管理能力和效能優點。</span><span class="sxs-lookup"><span data-stu-id="0e842-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="0e842-114">您可以快速並有效率地傳送或存取資料子集，同時維護資料集合的完整性。</span><span class="sxs-lookup"><span data-stu-id="0e842-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="0e842-115">例如，將資料從 OLTP 載入至 OLAP 系統這類作業只需要數秒的時間，而不用像未對資料進行資料分割時，需要數分鐘或數小時的時間才能執行作業。</span><span class="sxs-lookup"><span data-stu-id="0e842-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="0e842-116">您可以更快速地對一個或多個分割區執行維護作業。</span><span class="sxs-lookup"><span data-stu-id="0e842-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="0e842-117">作業只處理這些資料子集，而非整個資料表，因此會更有效率。</span><span class="sxs-lookup"><span data-stu-id="0e842-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="0e842-118">例如，您可以選擇壓縮一個或多個分割區中的資料，或是重建索引的一個或多個分割區。</span><span class="sxs-lookup"><span data-stu-id="0e842-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="0e842-119">您可以提升查詢效能，不過這要視您經常執行的查詢類型和硬體組態而定。</span><span class="sxs-lookup"><span data-stu-id="0e842-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="0e842-120">例如，因為您可以聯結分割區本身，則在資料表中的分割資料行相同時，查詢最佳化工具可以更快速地處理兩個以上資料分割資料表之間的等聯結 (Equi-Join) 查詢。</span><span class="sxs-lookup"><span data-stu-id="0e842-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="0e842-121">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 在為 I/O 作業執行資料排序時，會先依資料分割排序資料。</span><span class="sxs-lookup"><span data-stu-id="0e842-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="0e842-122">一次會存取一台磁碟機，而這樣會降低效能。</span><span class="sxs-lookup"><span data-stu-id="0e842-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="0e842-123">若要改善資料排序效能，請設定 RAID，以將分割區的資料檔案分割到多個磁碟上。</span><span class="sxs-lookup"><span data-stu-id="0e842-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="0e842-124">利用這種方式，雖然 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 仍然會依資料分割排序資料，但它可以同時存取每個資料分割的所有磁碟機。</span><span class="sxs-lookup"><span data-stu-id="0e842-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="0e842-125">此外，您可以啟用分割區層級的鎖定擴大 (而非整個資料表) 來提升效能。</span><span class="sxs-lookup"><span data-stu-id="0e842-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="0e842-126">這可以減少資料表上的鎖定競爭。</span><span class="sxs-lookup"><span data-stu-id="0e842-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="0e842-127">元件和概念</span><span class="sxs-lookup"><span data-stu-id="0e842-127">Components and Concepts</span></span>  
 <span data-ttu-id="0e842-128">下列詞彙適用於資料表和索引資料分割。</span><span class="sxs-lookup"><span data-stu-id="0e842-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="0e842-129">分割區函數</span><span class="sxs-lookup"><span data-stu-id="0e842-129">Partition function</span></span>  
 <span data-ttu-id="0e842-130">一種資料庫物件，可定義資料表或索引的資料列如何根據某些資料行 (稱為分割資料行) 的值對應至資料分割集。</span><span class="sxs-lookup"><span data-stu-id="0e842-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="0e842-131">也就是說，分割區函數會定義資料表擁有的分割區數目，以及分割區界限的定義方式。</span><span class="sxs-lookup"><span data-stu-id="0e842-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="0e842-132">例如，如果資料表包含銷售訂單資料，您可能想要根據 `datetime` 資料行 (例如銷售日期) 將資料表分割為 12 個 (每月) 分割區。</span><span class="sxs-lookup"><span data-stu-id="0e842-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="0e842-133">分割區配置</span><span class="sxs-lookup"><span data-stu-id="0e842-133">Partition scheme</span></span>  
 <span data-ttu-id="0e842-134">將分割區函數的資料分割對應至一組檔案群組的資料庫物件。</span><span class="sxs-lookup"><span data-stu-id="0e842-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="0e842-135">將分割區放在不同檔案群組的主要理由是可以確保能夠對分割區獨立執行備份作業。</span><span class="sxs-lookup"><span data-stu-id="0e842-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="0e842-136">這是因為您可以對個別檔案群組執行備份。</span><span class="sxs-lookup"><span data-stu-id="0e842-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="0e842-137">資料分割資料行</span><span class="sxs-lookup"><span data-stu-id="0e842-137">Partitioning column</span></span>  
 <span data-ttu-id="0e842-138">分割區函數用於分割資料表或索引的資料表或索引資料行。</span><span class="sxs-lookup"><span data-stu-id="0e842-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="0e842-139">參與分割區函數的計算資料行必須明確地標示為 PERSISTED。</span><span class="sxs-lookup"><span data-stu-id="0e842-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="0e842-140">所有適用於做為索引資料行的資料類型都可以做為分割資料行，但 `timestamp` 除外。</span><span class="sxs-lookup"><span data-stu-id="0e842-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="0e842-141">無法指定 `ntext`、`text`、`image`、`xml`、`varchar(max)`、`nvarchar(max)` 或 `varbinary(max)` 資料類型。</span><span class="sxs-lookup"><span data-stu-id="0e842-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="0e842-142">此外，也無法指定 Microsoft .NET Framework Common Language Runtime (CLR) 使用者定義型別及別名資料類型資料行。</span><span class="sxs-lookup"><span data-stu-id="0e842-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="0e842-143">對齊的索引</span><span class="sxs-lookup"><span data-stu-id="0e842-143">Aligned index</span></span>  
 <span data-ttu-id="0e842-144">在與對應資料表相同的分割區配置上建立的索引。</span><span class="sxs-lookup"><span data-stu-id="0e842-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="0e842-145">資料表與其索引對齊時，SQL Server 可以在維護資料表及其索引之分割區結構的同時，快速且有效地切換分割區。</span><span class="sxs-lookup"><span data-stu-id="0e842-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="0e842-146">索引不需要參與相同的具名分割區函數，即可對齊其基底資料表。</span><span class="sxs-lookup"><span data-stu-id="0e842-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="0e842-147">不過，索引和基底資料表的分割區函數本質上必須相同，也就是說 1) 這兩種分割區函數的引數具有相同的資料類型，2) 它們都定義相同數目的分割區，3) 對分割區都定義相同的界限值。</span><span class="sxs-lookup"><span data-stu-id="0e842-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="0e842-148">非對齊的索引</span><span class="sxs-lookup"><span data-stu-id="0e842-148">Nonaligned index</span></span>  
 <span data-ttu-id="0e842-149">與其對應資料表分開進行資料分割的索引。</span><span class="sxs-lookup"><span data-stu-id="0e842-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="0e842-150">亦即，索引具有不同的分割區配置，或放在與基底資料表不同的檔案群組中。</span><span class="sxs-lookup"><span data-stu-id="0e842-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="0e842-151">在下列情況中，設計非對齊的資料分割索引可能十分有用：</span><span class="sxs-lookup"><span data-stu-id="0e842-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="0e842-152">尚未對基底資料表進行資料分割。</span><span class="sxs-lookup"><span data-stu-id="0e842-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="0e842-153">索引鍵是唯一的，並且不含資料表的分割資料行。</span><span class="sxs-lookup"><span data-stu-id="0e842-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="0e842-154">您希望使用不同的聯結資料行，讓基底資料表參與具有多個資料表的共置聯結。</span><span class="sxs-lookup"><span data-stu-id="0e842-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="0e842-155">分割區刪除</span><span class="sxs-lookup"><span data-stu-id="0e842-155">Partition elimination</span></span>  
 <span data-ttu-id="0e842-156">查詢最佳化工具用來只存取相關分割區以滿足查詢篩選準則的程序。</span><span class="sxs-lookup"><span data-stu-id="0e842-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="0e842-157">效能方針</span><span class="sxs-lookup"><span data-stu-id="0e842-157">Performance Guidelines</span></span>  
 <span data-ttu-id="0e842-158">15,000 個分割區中新的且較高的限制會影響記憶體、資料分割索引作業、DBCC 命令和查詢。</span><span class="sxs-lookup"><span data-stu-id="0e842-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="0e842-159">此節描述將分割區數目增加為超過 1,000 個的效能含意，並視需要提供解決方案。</span><span class="sxs-lookup"><span data-stu-id="0e842-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="0e842-160">具有最大分割區數目增加為 15,000 的限制，就可以較長時間地儲存資料。</span><span class="sxs-lookup"><span data-stu-id="0e842-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="0e842-161">不過，您只應該保留必要的資料，並維護效能與資料分割數目之間的平衡。</span><span class="sxs-lookup"><span data-stu-id="0e842-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="0e842-162">記憶體使用量和方針</span><span class="sxs-lookup"><span data-stu-id="0e842-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="0e842-163">如果正在使用大量分割區，則建議您至少使用 16 GB 的 RAM。</span><span class="sxs-lookup"><span data-stu-id="0e842-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="0e842-164">如果系統的記憶體不足，則資料操作語言 (DML) 陳述式、資料定義語言 (DDL) 陳述式和其他作業可能會因記憶體不足而失敗。</span><span class="sxs-lookup"><span data-stu-id="0e842-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="0e842-165">RAM 為 16 GB 且執行許多記憶體密集處理序的系統，可能會在針對大量分割區執行的作業時記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="0e842-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="0e842-166">因此，記憶體愈多 (超過 16 GB)，發生效能和記憶體問題的機會可能就愈少。</span><span class="sxs-lookup"><span data-stu-id="0e842-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="0e842-167">記憶體限制會影響 SQL Server 建立資料分割索引的效能或能力。</span><span class="sxs-lookup"><span data-stu-id="0e842-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="0e842-168">如果資料表有適用的叢集索引，當索引沒有對齊基底資料表或沒有對齊叢集索引時，特別會發生這種狀況。</span><span class="sxs-lookup"><span data-stu-id="0e842-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="0e842-169">資料分割索引作業</span><span class="sxs-lookup"><span data-stu-id="0e842-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="0e842-170">記憶體限制會影響 SQL Server 建立資料分割索引的效能或能力。</span><span class="sxs-lookup"><span data-stu-id="0e842-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="0e842-171">這特別適用於非對齊索引。</span><span class="sxs-lookup"><span data-stu-id="0e842-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="0e842-172">您可以對包含超過 1,000 個分割區的資料表，建立及重建不以資料表為準的索引，但不予支援。</span><span class="sxs-lookup"><span data-stu-id="0e842-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="0e842-173">此做法可能會導致在作業期間效能降低或耗用過多記憶體。</span><span class="sxs-lookup"><span data-stu-id="0e842-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="0e842-174">建立和重建對齊索引所需的執行時間，可能會隨著分割區數目的增加而增加。</span><span class="sxs-lookup"><span data-stu-id="0e842-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="0e842-175">建議您不要同時執行多個建立和重建索引命令，這樣做可能會造成效能和記憶體問題。</span><span class="sxs-lookup"><span data-stu-id="0e842-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="0e842-176">SQL Server 執行排序以建立資料分割索引時，會先對每個分割區建立一個排序表。</span><span class="sxs-lookup"><span data-stu-id="0e842-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="0e842-177">接著會在每個分割區的個別檔案群組中建立排序表，而如果指定 SORT_IN_TEMPDB 索引選項，則會在 `tempdb` 中建立排序表。</span><span class="sxs-lookup"><span data-stu-id="0e842-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="0e842-178">每個排序表都需要最小量的記憶體才能建立。</span><span class="sxs-lookup"><span data-stu-id="0e842-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="0e842-179">當您在建立對齊基底資料表的資料分割索引時，會使用少量記憶體一次建立一個排序表。</span><span class="sxs-lookup"><span data-stu-id="0e842-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="0e842-180">不過，當您在建立非對齊資料分割索引時，則會同時建立排序表。</span><span class="sxs-lookup"><span data-stu-id="0e842-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="0e842-181">因此，必須有足夠的記憶體才能處理這些並行排序作業。</span><span class="sxs-lookup"><span data-stu-id="0e842-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="0e842-182">分割區的數量越大的話，則需要越多記憶體。</span><span class="sxs-lookup"><span data-stu-id="0e842-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="0e842-183">對每個分割區來說，每個排序表的大小下限為 40 個頁面，而每一頁都為 8 KB。</span><span class="sxs-lookup"><span data-stu-id="0e842-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="0e842-184">例如，具有 100 個分割區的非對齊資料分割索引，需要足夠的記憶體，才能同時連續排序 4,000 (40 \* 100) 頁。</span><span class="sxs-lookup"><span data-stu-id="0e842-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="0e842-185">如果有可用的記憶體，則建立作業會成功，但效能會變差。</span><span class="sxs-lookup"><span data-stu-id="0e842-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="0e842-186">如果無法使用這個數量的記憶體，建立作業會失敗。</span><span class="sxs-lookup"><span data-stu-id="0e842-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="0e842-187">此外，具有 100 個分割區的對齊資料分割索引只需要足夠排序 40 頁的記憶體，因為並不會同時執行排序作業。</span><span class="sxs-lookup"><span data-stu-id="0e842-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="0e842-188">若為對齊和非對齊索引，如果 SQL Server 將平行處理原則的程度套用至多處理器電腦上的建立作業，則記憶體需求會比較大。</span><span class="sxs-lookup"><span data-stu-id="0e842-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="0e842-189">這是因為平行處理原則的程度越大，則記憶體需求也越大。</span><span class="sxs-lookup"><span data-stu-id="0e842-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="0e842-190">例如，如果 SQL Server 將平行處理原則的程度設為 4，則具有 100 個分割區的非對齊資料分割索引需要四個處理器的足夠記憶體，才能同時排序 4,000 頁或 16,000 頁。</span><span class="sxs-lookup"><span data-stu-id="0e842-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="0e842-191">如果已對齊資料分割索引，則記憶體需求會降低為四個處理器排序 40 頁，或 160 (4 \* 40) 頁。</span><span class="sxs-lookup"><span data-stu-id="0e842-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="0e842-192">您可以使用 MAXDOP 索引選項，以手動方式降低平行處理原則的程度。</span><span class="sxs-lookup"><span data-stu-id="0e842-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="0e842-193">DBCC 命令</span><span class="sxs-lookup"><span data-stu-id="0e842-193">DBCC Commands</span></span>  
 <span data-ttu-id="0e842-194">如果具有較大的分割區數目，則 DBCC 命令所需的執行時間可能會隨著分割區數目的增加而增加。</span><span class="sxs-lookup"><span data-stu-id="0e842-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="0e842-195">查詢</span><span class="sxs-lookup"><span data-stu-id="0e842-195">Queries</span></span>  
 <span data-ttu-id="0e842-196">使用分割區刪除的查詢，可能會具有較大分割區數目的可比較或改善效能。</span><span class="sxs-lookup"><span data-stu-id="0e842-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="0e842-197">未使用分割區刪除的查詢，所需執行時間可能會隨著分割區數目的增加而增加。</span><span class="sxs-lookup"><span data-stu-id="0e842-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="0e842-198">例如，假設資料表有 1 億個資料列和資料行 `A`、 `B`和 `C`。</span><span class="sxs-lookup"><span data-stu-id="0e842-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="0e842-199">在案例 1 中，資料表的資料行 `A`上分成 1000 個分割區。</span><span class="sxs-lookup"><span data-stu-id="0e842-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="0e842-200">在案例 2 中，資料表的資料行 `A`上分成 10,000 個資料分區。</span><span class="sxs-lookup"><span data-stu-id="0e842-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="0e842-201">資料表上具有篩選資料行 `A` 之 WHERE 子句的查詢，會執行資料分割刪除，並掃描一個資料分割。</span><span class="sxs-lookup"><span data-stu-id="0e842-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="0e842-202">在案例 2 中，因為分割區中要掃描的資料列較少，所以這個相同查詢的執行速度會較快。</span><span class="sxs-lookup"><span data-stu-id="0e842-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="0e842-203">具有篩選資料行 B 之 WHERE 子句的查詢會掃描所有分割區。</span><span class="sxs-lookup"><span data-stu-id="0e842-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="0e842-204">在案例 1 中，因為要掃描的分割區較少，所以此查詢的執行速度會比案例 2 還要快。</span><span class="sxs-lookup"><span data-stu-id="0e842-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="0e842-205">如果查詢在分割資料行以外的資料行上使用類似 TOP 或 MAX/MIN 的運算子，則可能會因為資料分割而遇到效能降低的情況，因為所有分割區都必須評估。</span><span class="sxs-lookup"><span data-stu-id="0e842-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="0e842-206">資料分割索引作業期間統計資料計算的行為變更</span><span class="sxs-lookup"><span data-stu-id="0e842-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="0e842-207">從 [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]開始，並不會在建立或重建資料分割索引之後掃描資料表中所有的資料列建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="0e842-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="0e842-208">反之，查詢最佳化工具會使用預設的採樣演算法來產生統計資料。</span><span class="sxs-lookup"><span data-stu-id="0e842-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="0e842-209">升級具有分割區索引的資料庫之後，可能會注意到這些索引之長條圖資料的差異。</span><span class="sxs-lookup"><span data-stu-id="0e842-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="0e842-210">此行為變更可能不會影響查詢效能。</span><span class="sxs-lookup"><span data-stu-id="0e842-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="0e842-211">如果要在掃描資料表中所有資料列時取得分割區索引的統計資料，請使用 CREATE STATISTICS 或 UPDATE STATISTICS 搭配 FULLSCAN 子句。</span><span class="sxs-lookup"><span data-stu-id="0e842-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="0e842-212">相關工作</span><span class="sxs-lookup"><span data-stu-id="0e842-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="0e842-213">**工作**</span><span class="sxs-lookup"><span data-stu-id="0e842-213">**Tasks**</span></span>|<span data-ttu-id="0e842-214">**主題**</span><span class="sxs-lookup"><span data-stu-id="0e842-214">**Topic**</span></span>|  
|<span data-ttu-id="0e842-215">描述如何建立分割區函數和分割區配置，然後將它們套用至資料表和索引。</span><span class="sxs-lookup"><span data-stu-id="0e842-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="0e842-216">建立分割區資料表及索引</span><span class="sxs-lookup"><span data-stu-id="0e842-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="0e842-217">相關內容</span><span class="sxs-lookup"><span data-stu-id="0e842-217">Related Content</span></span>  
 <span data-ttu-id="0e842-218">您可能會發現下列資料分割資料表和索引策略和實作白皮書十分有用。</span><span class="sxs-lookup"><span data-stu-id="0e842-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="0e842-219">[使用 SQL Server 2008 的資料分割資料表和索引策略](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="0e842-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="0e842-220">[如何實作自動滑動視窗](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="0e842-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="0e842-221">大量載入至資料分割資料表</span><span class="sxs-lookup"><span data-stu-id="0e842-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="0e842-222">分割資料表和索引上的查詢處理增強功能</span><span class="sxs-lookup"><span data-stu-id="0e842-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="0e842-223">建立大規模關聯式資料倉儲的前 10 大最佳作法</span><span class="sxs-lookup"><span data-stu-id="0e842-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
