---
title: 正在提取結果資料 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87709333"
---
# <a name="fetching-result-data"></a><span data-ttu-id="f01fa-102">提取結果資料</span><span class="sxs-lookup"><span data-stu-id="f01fa-102">Fetching Result Data</span></span>
  <span data-ttu-id="f01fa-103">ODBC 應用程式具備三個提取結果資料的選項。</span><span class="sxs-lookup"><span data-stu-id="f01fa-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="f01fa-104">第一個選項是以[SQLBindCol](../native-client-odbc-api/sqlbindcol.md)為基礎。</span><span class="sxs-lookup"><span data-stu-id="f01fa-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="f01fa-105">在提取結果集之前，應用程式會使用**SQLBindCol** ，將結果集中的每個資料行系結至程式變數。</span><span class="sxs-lookup"><span data-stu-id="f01fa-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="f01fa-106">系結資料行之後，此驅動程式會在每次應用程式呼叫**SQLFetch**或[SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md)時，將目前資料列的資料傳送到系結至結果集資料行的變數。</span><span class="sxs-lookup"><span data-stu-id="f01fa-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="f01fa-107">如果結果集資料行和程式變數的資料類型不同，驅動程式會處理資料轉換。</span><span class="sxs-lookup"><span data-stu-id="f01fa-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="f01fa-108">如果應用程式 SQL_ATTR_ROW_ARRAY_SIZE 設定大於1，它可以將結果資料行系結至變數陣列，這將會在每次呼叫**SQLFetchScroll**時填滿。</span><span class="sxs-lookup"><span data-stu-id="f01fa-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="f01fa-109">第二個選項是以[SQLGetData](../native-client-odbc-api/sqlgetdata.md)為基礎。</span><span class="sxs-lookup"><span data-stu-id="f01fa-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="f01fa-110">應用程式不會使用**SQLBindCol**將結果集資料行系結至程式變數。</span><span class="sxs-lookup"><span data-stu-id="f01fa-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="f01fa-111">在每次呼叫**SQLFetch**之後，應用程式會針對結果集中的每個資料行呼叫**SQLGetData**一次。</span><span class="sxs-lookup"><span data-stu-id="f01fa-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="f01fa-112">**SQLGetData**會指示驅動程式將資料從特定的結果集資料行傳送到特定的程式變數，並指定資料行和變數的資料類型。</span><span class="sxs-lookup"><span data-stu-id="f01fa-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="f01fa-113">如果結果資料行和程式變數的資料類型不同，這會讓驅動程式轉換資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="f01fa-114">**Text**、 **Ntext**和**image**資料行通常太大而無法放入程式變數中，但仍可使用**SQLGetData**來抓取。</span><span class="sxs-lookup"><span data-stu-id="f01fa-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="f01fa-115">如果 [結果] 資料行中的**text**、 **Ntext**或**image**資料大於程式變數，則**SQLGetData**會傳回 SQL_SUCCESS_WITH_INFO 和 SQLSTATE 01004 (字串資料，正確地截斷) 。</span><span class="sxs-lookup"><span data-stu-id="f01fa-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="f01fa-116">後續的**SQLGetData**呼叫會傳回**文字**或**影像**資料的連續區塊。</span><span class="sxs-lookup"><span data-stu-id="f01fa-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="f01fa-117">當到達資料的結尾時， **SQLGetData**會傳回 SQL_SUCCESS。</span><span class="sxs-lookup"><span data-stu-id="f01fa-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="f01fa-118">如果 SQL_ATTR_ROW_ARRAY_SIZE 大於 1，每次提取都會傳回一組資料列或資料列集。</span><span class="sxs-lookup"><span data-stu-id="f01fa-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="f01fa-119">使用**SQLGetData**之前，您必須先使用**SQLSetPos**來指定資料列集內的特定資料列，做為目前的資料列。</span><span class="sxs-lookup"><span data-stu-id="f01fa-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="f01fa-120">第三個選項是混合使用**SQLBindCol**和**SQLGetData**。</span><span class="sxs-lookup"><span data-stu-id="f01fa-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="f01fa-121">例如，應用程式可以系結結果集的前10個數據行，然後在每次提取時呼叫**SQLGetData**三次，以從三個未系結的資料行中取出資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="f01fa-122">當結果集包含一或多個**text**或**image**資料行時，通常會使用此方法。</span><span class="sxs-lookup"><span data-stu-id="f01fa-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="f01fa-123">根據針對結果集所設定的資料指標選項，應用程式也可以使用**SQLFetchScroll**的滾動選項來在結果集周圍進行滾動。</span><span class="sxs-lookup"><span data-stu-id="f01fa-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="f01fa-124">過度使用**SQLBindCol**將結果集資料行系結至程式變數的成本很高，因為**SQLBINDCOL**會導致 ODBC 驅動程式配置記憶體。</span><span class="sxs-lookup"><span data-stu-id="f01fa-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="f01fa-125">當您將結果資料行系結至變數時，該系結會維持有效，直到您呼叫[SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md)釋放語句控制碼，或呼叫[SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md)並將*fOption*設定為 SQL_UNBIND。</span><span class="sxs-lookup"><span data-stu-id="f01fa-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="f01fa-126">當陳述式完成時，不會自動復原繫結。</span><span class="sxs-lookup"><span data-stu-id="f01fa-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="f01fa-127">此邏輯可讓您利用不同的參數，有效地處理執行相同的 SELECT 陳述式數次。</span><span class="sxs-lookup"><span data-stu-id="f01fa-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="f01fa-128">由於結果集會保留相同的結構，因此您可以系結結果集一次、處理所有 SELECT 語句，然後在最後一次執行之後，將*fOption*設為 SQL_UNBIND 來呼叫**SQLFreeStmt** 。</span><span class="sxs-lookup"><span data-stu-id="f01fa-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="f01fa-129">您不應該呼叫**SQLBindCol**來系結結果集中的資料行，而不需要先呼叫**SQLFreeStmt**並將*fOption*設為 SQL_UNBIND 來釋放任何先前的系結。</span><span class="sxs-lookup"><span data-stu-id="f01fa-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="f01fa-130">使用**SQLBindCol**時，您可以執行資料列取向或資料行取向的系結。</span><span class="sxs-lookup"><span data-stu-id="f01fa-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="f01fa-131">資料列取向的繫結比資料行取向的繫結稍快。</span><span class="sxs-lookup"><span data-stu-id="f01fa-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="f01fa-132">您可以使用**SQLGetData** ，逐一抓取資料行，而不是使用**SQLBindCol**系結結果集資料行。</span><span class="sxs-lookup"><span data-stu-id="f01fa-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="f01fa-133">如果結果集只包含幾個資料列，使用**SQLGetData**而不是**SQLBindCol**會更快;否則， **SQLBindCol**會提供最佳效能。</span><span class="sxs-lookup"><span data-stu-id="f01fa-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="f01fa-134">如果您不一定要將資料放在一組相同的變數中，就應該使用**SQLGetData** ，而不是經常重新系結。</span><span class="sxs-lookup"><span data-stu-id="f01fa-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="f01fa-135">當所有資料行都與**SQLBindCol**系結之後，您只能在選取清單中的資料行上使用**SQLGetData** 。</span><span class="sxs-lookup"><span data-stu-id="f01fa-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="f01fa-136">資料行也必須出現在您已使用**SQLGetData**的任何資料行之後。</span><span class="sxs-lookup"><span data-stu-id="f01fa-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="f01fa-137">處理將資料移入或移出程式變數（例如**SQLGetData**、 **SQLBindCol**和[SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md)）的 ODBC 函數，支援隱含的資料類型轉換。</span><span class="sxs-lookup"><span data-stu-id="f01fa-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="f01fa-138">例如，如果應用程式將整數資料行繫結至字元字串程式變數，驅動程式會先自動將資料從整數轉換為字元，然後再將其放入程式變數中。</span><span class="sxs-lookup"><span data-stu-id="f01fa-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="f01fa-139">在應用程式中進行的資料轉換應該降至最低。</span><span class="sxs-lookup"><span data-stu-id="f01fa-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="f01fa-140">出非需要進行資料轉換才能讓應用程式完成處理，否則，應用程式應該將資料行和參數繫結至相同資料類型的程式變數。</span><span class="sxs-lookup"><span data-stu-id="f01fa-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="f01fa-141">不過，如果資料必須從一種類型轉換為另一種類型，讓驅動程式執行轉換比在應用程式中進行轉換還要有效率。</span><span class="sxs-lookup"><span data-stu-id="f01fa-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="f01fa-142">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC 驅動程式一般只會直接將資料從網路緩衝區轉換到應用程式的變數。</span><span class="sxs-lookup"><span data-stu-id="f01fa-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="f01fa-143">要求驅動程式執行資料轉換會強制驅動程式緩衝處理資料，並使用 CPU 循環轉換資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="f01fa-144">除了**text**、 **Ntext**和**image**資料以外，程式變數應該夠大，以保存從資料行傳入的資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="f01fa-145">如果應用程式嘗試擷取結果集資料，並將其放入太小而無法容納它的變數中，驅動程式會產生警告。</span><span class="sxs-lookup"><span data-stu-id="f01fa-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="f01fa-146">這會強迫驅動程式為訊息配置記憶體，而且驅動程式和應用程式都必須花費 CPU 循環來處理訊息並進行錯誤處理。</span><span class="sxs-lookup"><span data-stu-id="f01fa-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="f01fa-147">應用程式應該配置夠大的變數來容納要擷取的資料，或使用選取清單中的 SUBSTRING 函數來縮減資料行在結果集中的大小。</span><span class="sxs-lookup"><span data-stu-id="f01fa-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="f01fa-148">使用 SQL_C_DEFAULT 來指定 C 變數的類型時請務必小心。</span><span class="sxs-lookup"><span data-stu-id="f01fa-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="f01fa-149">SQL_C_DEFAULT 指定 C 變數的類型必須符合資料行或參數的 SQL 資料類型。</span><span class="sxs-lookup"><span data-stu-id="f01fa-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="f01fa-150">如果為**Ntext**、 **Nchar**或**Nvarchar**資料行指定了 SQL_C_DEFAULT，則會將 Unicode 資料傳回給應用程式。</span><span class="sxs-lookup"><span data-stu-id="f01fa-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="f01fa-151">如果尚未撰寫應用程式的程式碼來處理 Unicode 資料，這可能會導致各種問題。</span><span class="sxs-lookup"><span data-stu-id="f01fa-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="f01fa-152">**Uniqueidentifier** (SQL_GUID) 資料類型可能會發生相同類型的問題。</span><span class="sxs-lookup"><span data-stu-id="f01fa-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="f01fa-153">**text**、 **Ntext**和**image**資料通常太大，無法放入單一程式變數中，而且通常會使用**SQLGetData** （而非**SQLBindCol**）進行處理。</span><span class="sxs-lookup"><span data-stu-id="f01fa-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="f01fa-154">使用伺服器資料指標時， [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native CLIENT ODBC 驅動程式會經過優化，而不會在提取資料列時傳送未系結之**text**、 **Ntext**或**image**資料行的資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="f01fa-155">在應用程式發出資料行的**SQLGetData**之前，不會實際從伺服器抓取**text**、 **Ntext**或**image**資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="f01fa-156">這種優化可以套用至應用程式，如此一來，當使用者在游標上向上和向下滾動時，就不會顯示**text**、 **Ntext**或**image**資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="f01fa-157">在使用者選取資料列之後，應用程式可以呼叫**SQLGetData**來取出**text**、 **Ntext**或**image**資料。</span><span class="sxs-lookup"><span data-stu-id="f01fa-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="f01fa-158">這會儲存使用者未選取之任何資料列的**text**、 **Ntext**或**image**資料傳輸，而且可以節省非常大量資料的傳輸。</span><span class="sxs-lookup"><span data-stu-id="f01fa-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f01fa-159">另請參閱</span><span class="sxs-lookup"><span data-stu-id="f01fa-159">See Also</span></span>  
 [<span data-ttu-id="f01fa-160">&#40;ODBC&#41;處理結果</span><span class="sxs-lookup"><span data-stu-id="f01fa-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
