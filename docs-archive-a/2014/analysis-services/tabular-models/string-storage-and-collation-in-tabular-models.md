---
title: 表格式模型中的字串儲存和定序 |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: 8516f0ad-32ee-4688-a304-e705143642ca
author: minewiskan
ms.author: owend
ms.openlocfilehash: 3aad4cf16c39897bc0796f4fb161eaf39abdb5fd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87706789"
---
# <a name="string-storage-and-collation-in-tabular-models"></a>表格式模型中的字串儲存和定序
  字串 (文字值) 以高度壓縮的格式儲存在表格式模型中；由於此壓縮，您在擷取整個或部分字串時可能會得到意外結果。 此外，因為字串地區設定和定序是繼承自階層結構上最接近的父物件，所以如果未明確定義字串語言，父物件的地區設定和定序可能會影響各字串的儲存方式以及字串是唯一還是與父定序所定義的相似字串合併。  
  
 此主題描述壓縮和儲存字串的機制，並且提供一些範例，說明定序和語言如何影響表格式模型中文字公式的結果。  
  
## <a name="storage"></a>儲存體  
 在表格式模型中，所有資料都是高度壓縮，以更好地放入記憶體中。 因此，可視為語彙相等的所有字串只儲存一次。 該字串的第一個執行個體做為標準表示，並將此後每個相等字串編制索引為與第一次出現字串相同的壓縮值。  
  
 關鍵問題是：語彙相等字串的構成要素為何？ 如果兩個字串可視為相同字組，它們就是視為語彙相等。 例如，在英語中，當您在字典中搜尋 **violin** 一字時，根據字典的編輯原則，可能會找到項目 **Violin** 或 **violin**，但通常您會認為這兩個字是相等的，並且忽略大小寫的差異。 在表格式模型中，決定兩個字串是否語彙相等的因素不是編輯原則或甚至是使用者喜好設定，而是指派給資料行的地區設定和定序順序。  
  
 因此，將大寫和小寫字母視為相同或不同來處理的決定取決於定序和地區設定。 對於該地區設定內的任何特定字組，在特定資料行內第一次出現的字組會做為該字組的標準表示，並且該字串以未壓縮的格式儲存。  所有其他字串都會針對第一次出現項目進行測試，如果它們符合相等測試，就會指派給它們第一次出現項目的壓縮值。 以後，在擷取壓縮值時，就會使用第一次出現字串的未壓縮值來表示。  
  
 範例有助於澄清此運作方式。 下列資料行 "Classification - English" 是從包含植物和樹木的資料表擷取的。 對於每種植物 (此處未顯示植物名稱)，分類資料行顯示植物的一般類別。  
  
|Classification - English|  
|-------------------------------|  
|trEE|  
|PlAnT|  
|trEE|  
|PlAnT|  
|PlAnT|  
|樹狀結構|  
|PlAnT|  
|trEE|  
|tree|  
|PlAnT|  
|trEE|  
  
 資料可能來自許多不同的來源，因此大小寫和腔調字的使用不一致，並且關聯式資料庫依原狀儲存這些差異。 但值大致上是 **Plant** 或 **Tree**，只是大小寫有差異。  
  
 將這些值載入表格式模型時，會使用預設的定序和排序次序（英文） (美國) ，大小寫並不重要，因此整個資料行只會儲存兩個值：  
  
|Classification - English|  
|-------------------------------|  
|trEE|  
|PlAnT|  
  
 如果您在模型中使用「**分類-英文**」資料行，只要您顯示植物分類，就不會看到原始值，其各種使用大小寫，但只有第一個實例。 原因是 **tree** 的所有大小寫變體在此定序和地區設定中都是視為相等；因此，只保存一個字串，系統遇到的該字串的第一個執行個體就是儲存的字串。  
  
> [!WARNING]  
>  您可能決定要根據自己的判斷，來定義哪個字串做為第一個儲存的字串，但可能很難這樣做。 因為有鑑於所有值都是視為相同，沒有簡單的方法可以事先判斷引擎應該先處理哪個資料列。 反之，如果您需要設定標準值，則應在載入模型前清理所有字串。  
  
## <a name="locale-and-collation-order"></a>地區設定和定序順序  
 在比較字串 (文字值) 時，相等的定義要素通常是有關如何解釋這類字串的文化特性方面。 在某些文化特性中，字元的腔調字或大小寫可能會完全變更字串的意義；因此，在判斷任何特定語言或地區的相等時，通常要考慮這類差異。  
  
 通常當您使用電腦時，電腦已設定為符合您自己的文化特性期望和語言行為，並且文字值排序和比較等字串作業會如預期般運作。 控制語言特定行為的設定是透過 Windows [地區及語言選項]**** 設定來定義。 應用程式會讀取這些設定，並據此變更其行為。 在某些情況下，應用程式具有的功能可讓您變更應用程式的文化特性行為或比較字串的方式。  
  
 在您建立表格式模型資料庫時，根據預設資料庫會以語言識別碼和定序的形式繼承這些文化特性和語言設定。  
  
-   語言識別碼定義要根據文化特性用於字串的字元集。  
  
-   定序定義字元的順序及其相等。  
  
 請務必注意，語言識別碼不僅識別語言，也識別使用該語言的國家或地區。 每個語言識別碼還具有預設的定序規格。 如需有關語言識別碼的詳細資訊，請參閱＜ [Microsoft 指派的地區設定識別碼](https://msdn.microsoft.com/goglobal/bb964664.aspx)＞。 您可以使用 LCID Dec 資料行，在手動插入值時取得正確的識別碼。 如需有關 SQL 定序概念的詳細資訊，請參閱 [COLLATE &#40;Transact-SQL&#41;](/sql/t-sql/statements/collations)。 如需有關定序指定項和 Windows 定序名稱比較樣式的詳細資訊，請參閱 [Windows 定序名稱 &#40;Transact-SQL&#41;](/sql/t-sql/statements/windows-collation-name-transact-sql)。 主題 [SQL Server 定序名稱 &#40;Transact-SQL&#41;](/sql/t-sql/statements/sql-server-collation-name-transact-sql) 將 Windows 定序名稱對應至用於 SQL 的名稱。  
  
 一旦建立您的表格式模型資料庫之後，該模型中的所有新物件都會從資料庫屬性繼承語言和定序屬性。 所有物件都是這樣的。 繼承路徑從物件開始，查看父系中是否有要繼承的任何語言和定序屬性，如果找不到，則繼續向上在資料庫層級尋找語言和定序屬性。 換言之，如果您沒有為物件指定語言和定序屬性，則根據預設，物件會繼承其最接近的父系的屬性。  
  
 資料行會根據下列規則，在建立時繼承語言和定序屬性：  
  
1.  搜尋父維度物件中是否有語言和定序屬性。 如果這兩個值存在，則將它們複製到資料行屬性中；如果只存在一個值，則從現有值推斷另一個值並且指派這兩個值；如果兩個值都不存在，則移至下一步。  
  
2.  使用步驟 1 所述維度的相同程序搜尋資料庫物件；如果找不到任何屬性，則移至下一步。  
  
3.  使用步驟 1 所述維度的相同程序搜尋伺服器物件；如果找不到任何屬性，則資料行使用 Windows 語言識別碼並且從該值推斷定序屬性。  
  
 請務必注意，來源資料庫中的語言識別碼和定序順序通常對表格式模型資料行中儲存值的方式影響很小，甚至沒有影響。 例外是當來源資料庫轉換或篩選要求的值時。  
  
  
