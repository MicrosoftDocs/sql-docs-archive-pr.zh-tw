---
title: 表格式模型中的字串儲存和定序 |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: 8516f0ad-32ee-4688-a304-e705143642ca
author: minewiskan
ms.author: owend
ms.openlocfilehash: 3aad4cf16c39897bc0796f4fb161eaf39abdb5fd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87706789"
---
# <a name="string-storage-and-collation-in-tabular-models"></a><span data-ttu-id="8aa38-102">表格式模型中的字串儲存和定序</span><span class="sxs-lookup"><span data-stu-id="8aa38-102">String Storage and Collation in Tabular Models</span></span>
  <span data-ttu-id="8aa38-103">字串 (文字值) 以高度壓縮的格式儲存在表格式模型中；由於此壓縮，您在擷取整個或部分字串時可能會得到意外結果。</span><span class="sxs-lookup"><span data-stu-id="8aa38-103">Strings (text values) are stored in a highly compressed format in tabular models; because of this compression, you can get unexpected results when you retrieve entire or partial strings.</span></span> <span data-ttu-id="8aa38-104">此外，因為字串地區設定和定序是繼承自階層結構上最接近的父物件，所以如果未明確定義字串語言，父物件的地區設定和定序可能會影響各字串的儲存方式以及字串是唯一還是與父定序所定義的相似字串合併。</span><span class="sxs-lookup"><span data-stu-id="8aa38-104">Also, because string locale and collations are inherited hierarchically from the closest parent object, if the string language is not explicitly defined, the locale and collation of the parent can affect how each string is stored and whether the string is unique or conflated with similar strings as defined by the parent collation.</span></span>  
  
 <span data-ttu-id="8aa38-105">此主題描述壓縮和儲存字串的機制，並且提供一些範例，說明定序和語言如何影響表格式模型中文字公式的結果。</span><span class="sxs-lookup"><span data-stu-id="8aa38-105">This topic describes the mechanism by which strings are compressed and stored, and provides examples of how collation and language affect the results of text formulas in tabular models.</span></span>  
  
## <a name="storage"></a><span data-ttu-id="8aa38-106">儲存體</span><span class="sxs-lookup"><span data-stu-id="8aa38-106">Storage</span></span>  
 <span data-ttu-id="8aa38-107">在表格式模型中，所有資料都是高度壓縮，以更好地放入記憶體中。</span><span class="sxs-lookup"><span data-stu-id="8aa38-107">In tabular models all data is highly compressed to better fit in memory.</span></span> <span data-ttu-id="8aa38-108">因此，可視為語彙相等的所有字串只儲存一次。</span><span class="sxs-lookup"><span data-stu-id="8aa38-108">As a consequence, all strings that can be considered lexically equivalent are stored only once.</span></span> <span data-ttu-id="8aa38-109">該字串的第一個執行個體做為標準表示，並將此後每個相等字串編制索引為與第一次出現字串相同的壓縮值。</span><span class="sxs-lookup"><span data-stu-id="8aa38-109">The first instance of the string is used as the canonical representation and thereafter each equivalent string is indexed to the same compressed value as the first occurrence.</span></span>  
  
 <span data-ttu-id="8aa38-110">關鍵問題是：語彙相等字串的構成要素為何？</span><span class="sxs-lookup"><span data-stu-id="8aa38-110">The key question is: what constitutes a lexically equivalent string?</span></span> <span data-ttu-id="8aa38-111">如果兩個字串可視為相同字組，它們就是視為語彙相等。</span><span class="sxs-lookup"><span data-stu-id="8aa38-111">Two strings are considered lexically equivalent if they can be considered as the same word.</span></span> <span data-ttu-id="8aa38-112">例如，在英語中，當您在字典中搜尋 **violin** 一字時，根據字典的編輯原則，可能會找到項目 **Violin** 或 **violin**，但通常您會認為這兩個字是相等的，並且忽略大小寫的差異。</span><span class="sxs-lookup"><span data-stu-id="8aa38-112">For example, in English when you search for the word **violin** in a dictionary, you might find the entry **Violin** or **violin**, depending on the editorial policy of the dictionary, but generally you consider both words equivalent, and disregard the difference in capitalization.</span></span> <span data-ttu-id="8aa38-113">在表格式模型中，決定兩個字串是否語彙相等的因素不是編輯原則或甚至是使用者喜好設定，而是指派給資料行的地區設定和定序順序。</span><span class="sxs-lookup"><span data-stu-id="8aa38-113">In a tabular model, the factor that determines whether two strings are lexically equivalent is not editorial policy or even user preference, but the locale and collation order assigned to the column.</span></span>  
  
 <span data-ttu-id="8aa38-114">因此，將大寫和小寫字母視為相同或不同來處理的決定取決於定序和地區設定。</span><span class="sxs-lookup"><span data-stu-id="8aa38-114">Therefore, the decision of whether uppercase and lowercase letters should be handled as the same or different depends on the collation and locale.</span></span> <span data-ttu-id="8aa38-115">對於該地區設定內的任何特定字組，在特定資料行內第一次出現的字組會做為該字組的標準表示，並且該字串以未壓縮的格式儲存。</span><span class="sxs-lookup"><span data-stu-id="8aa38-115">For any particular word within that locale, the first occurrence of the word that is found within a particular column therefore serves as the canonical representation of that word and that string is stored in uncompressed format.</span></span>  <span data-ttu-id="8aa38-116">所有其他字串都會針對第一次出現項目進行測試，如果它們符合相等測試，就會指派給它們第一次出現項目的壓縮值。</span><span class="sxs-lookup"><span data-stu-id="8aa38-116">All other strings are tested against the first occurrence, and if they match the equivalence test, they are assigned to the compressed value of the first occurrence.</span></span> <span data-ttu-id="8aa38-117">以後，在擷取壓縮值時，就會使用第一次出現字串的未壓縮值來表示。</span><span class="sxs-lookup"><span data-stu-id="8aa38-117">Later, when the compressed values are retrieved they are represented using the uncompressed value of the first occurrence of the string.</span></span>  
  
 <span data-ttu-id="8aa38-118">範例有助於澄清此運作方式。</span><span class="sxs-lookup"><span data-stu-id="8aa38-118">An example will help to clarify how this works.</span></span> <span data-ttu-id="8aa38-119">下列資料行 "Classification - English" 是從包含植物和樹木的資料表擷取的。</span><span class="sxs-lookup"><span data-stu-id="8aa38-119">The following column "Classification - English" was extracted from a table that contains information about plants and trees.</span></span> <span data-ttu-id="8aa38-120">對於每種植物 (此處未顯示植物名稱)，分類資料行顯示植物的一般類別。</span><span class="sxs-lookup"><span data-stu-id="8aa38-120">For each plant (the names of the plants are not shown here) the classification column shows the general category of plant.</span></span>  
  
|<span data-ttu-id="8aa38-121">Classification - English</span><span class="sxs-lookup"><span data-stu-id="8aa38-121">Classification - English</span></span>|  
|-------------------------------|  
|<span data-ttu-id="8aa38-122">trEE</span><span class="sxs-lookup"><span data-stu-id="8aa38-122">trEE</span></span>|  
|<span data-ttu-id="8aa38-123">PlAnT</span><span class="sxs-lookup"><span data-stu-id="8aa38-123">PlAnT</span></span>|  
|<span data-ttu-id="8aa38-124">trEE</span><span class="sxs-lookup"><span data-stu-id="8aa38-124">TREE</span></span>|  
|<span data-ttu-id="8aa38-125">PlAnT</span><span class="sxs-lookup"><span data-stu-id="8aa38-125">PLANT</span></span>|  
|<span data-ttu-id="8aa38-126">PlAnT</span><span class="sxs-lookup"><span data-stu-id="8aa38-126">Plant</span></span>|  
|<span data-ttu-id="8aa38-127">樹狀結構</span><span class="sxs-lookup"><span data-stu-id="8aa38-127">Tree</span></span>|  
|<span data-ttu-id="8aa38-128">PlAnT</span><span class="sxs-lookup"><span data-stu-id="8aa38-128">plant</span></span>|  
|<span data-ttu-id="8aa38-129">trEE</span><span class="sxs-lookup"><span data-stu-id="8aa38-129">tReE</span></span>|  
|<span data-ttu-id="8aa38-130">tree</span><span class="sxs-lookup"><span data-stu-id="8aa38-130">tree</span></span>|  
|<span data-ttu-id="8aa38-131">PlAnT</span><span class="sxs-lookup"><span data-stu-id="8aa38-131">pLaNt</span></span>|  
|<span data-ttu-id="8aa38-132">trEE</span><span class="sxs-lookup"><span data-stu-id="8aa38-132">tREE</span></span>|  
  
 <span data-ttu-id="8aa38-133">資料可能來自許多不同的來源，因此大小寫和腔調字的使用不一致，並且關聯式資料庫依原狀儲存這些差異。</span><span class="sxs-lookup"><span data-stu-id="8aa38-133">Perhaps the data came from many different sources, and so the casing and use of accents was inconsistent, and the relational database stored those differences as is.</span></span> <span data-ttu-id="8aa38-134">但值大致上是 **Plant** 或 **Tree**，只是大小寫有差異。</span><span class="sxs-lookup"><span data-stu-id="8aa38-134">But in general the values are either **Plant** or **Tree**, just with different casing.</span></span>  
  
 <span data-ttu-id="8aa38-135">將這些值載入表格式模型時，會使用預設的定序和排序次序（英文） (美國) ，大小寫並不重要，因此整個資料行只會儲存兩個值：</span><span class="sxs-lookup"><span data-stu-id="8aa38-135">When these values are loaded into a tabular model that uses the default collation and sorting order for English (United States), case is not important, so only two values would be stored for the entire column:</span></span>  
  
|<span data-ttu-id="8aa38-136">Classification - English</span><span class="sxs-lookup"><span data-stu-id="8aa38-136">Classification - English</span></span>|  
|-------------------------------|  
|<span data-ttu-id="8aa38-137">trEE</span><span class="sxs-lookup"><span data-stu-id="8aa38-137">trEE</span></span>|  
|<span data-ttu-id="8aa38-138">PlAnT</span><span class="sxs-lookup"><span data-stu-id="8aa38-138">PlAnT</span></span>|  
  
 <span data-ttu-id="8aa38-139">如果您在模型中使用「**分類-英文**」資料行，只要您顯示植物分類，就不會看到原始值，其各種使用大小寫，但只有第一個實例。</span><span class="sxs-lookup"><span data-stu-id="8aa38-139">If you use the column, **Classification - English**, in your model, wherever you display plant classification you will see not the original values, with their various uses of upper and lower case, but only the first instance.</span></span> <span data-ttu-id="8aa38-140">原因是 **tree** 的所有大小寫變體在此定序和地區設定中都是視為相等；因此，只保存一個字串，系統遇到的該字串的第一個執行個體就是儲存的字串。</span><span class="sxs-lookup"><span data-stu-id="8aa38-140">The reason is that all the uppercase and lowercase variants of **tree** are considered equivalent in this collation and locale; therefore, only one string was preserved and the first instance of that string that is encountered by the system is the one that is saved.</span></span>  
  
> [!WARNING]  
>  <span data-ttu-id="8aa38-141">您可能決定要根據自己的判斷，來定義哪個字串做為第一個儲存的字串，但可能很難這樣做。</span><span class="sxs-lookup"><span data-stu-id="8aa38-141">You might decide that you want to define which string will be the first to store, according to what you consider correct, but this could be very hard to so.</span></span> <span data-ttu-id="8aa38-142">因為有鑑於所有值都是視為相同，沒有簡單的方法可以事先判斷引擎應該先處理哪個資料列。</span><span class="sxs-lookup"><span data-stu-id="8aa38-142">There is no simple way to determine in advance which row should be processed first by the engine, given that all values are considered to be the same.</span></span> <span data-ttu-id="8aa38-143">反之，如果您需要設定標準值，則應在載入模型前清理所有字串。</span><span class="sxs-lookup"><span data-stu-id="8aa38-143">Instead, if you need to set the standard value, you should cleanse all your strings before loading the model.</span></span>  
  
## <a name="locale-and-collation-order"></a><span data-ttu-id="8aa38-144">地區設定和定序順序</span><span class="sxs-lookup"><span data-stu-id="8aa38-144">Locale and Collation Order</span></span>  
 <span data-ttu-id="8aa38-145">在比較字串 (文字值) 時，相等的定義要素通常是有關如何解釋這類字串的文化特性方面。</span><span class="sxs-lookup"><span data-stu-id="8aa38-145">When comparing strings (text values), what defines equivalence is normally the cultural aspect of how such strings are interpreted.</span></span> <span data-ttu-id="8aa38-146">在某些文化特性中，字元的腔調字或大小寫可能會完全變更字串的意義；因此，在判斷任何特定語言或地區的相等時，通常要考慮這類差異。</span><span class="sxs-lookup"><span data-stu-id="8aa38-146">In some cultures an accent or the capitalization of a character can completely change the meaning of the string; therefore, typically such differences are considered when determining equivalency for any particular language or region.</span></span>  
  
 <span data-ttu-id="8aa38-147">通常當您使用電腦時，電腦已設定為符合您自己的文化特性期望和語言行為，並且文字值排序和比較等字串作業會如預期般運作。</span><span class="sxs-lookup"><span data-stu-id="8aa38-147">Usually, when you use your computer it is already configured to match your own cultural expectations and linguistic behavior, and string operations such as sorting and comparing text values behaves as you would expect.</span></span> <span data-ttu-id="8aa38-148">控制語言特定行為的設定是透過 Windows [地區及語言選項]\*\*\*\* 設定來定義。</span><span class="sxs-lookup"><span data-stu-id="8aa38-148">The settings that control language-specific behavior are defined through the **Locale and Regional** settings in Windows.</span></span> <span data-ttu-id="8aa38-149">應用程式會讀取這些設定，並據此變更其行為。</span><span class="sxs-lookup"><span data-stu-id="8aa38-149">Applications read those settings and change their behavior accordingly.</span></span> <span data-ttu-id="8aa38-150">在某些情況下，應用程式具有的功能可讓您變更應用程式的文化特性行為或比較字串的方式。</span><span class="sxs-lookup"><span data-stu-id="8aa38-150">In some cases, an application might have a feature that allows you to change the cultural behavior of the application or the way in which strings are compared.</span></span>  
  
 <span data-ttu-id="8aa38-151">在您建立表格式模型資料庫時，根據預設資料庫會以語言識別碼和定序的形式繼承這些文化特性和語言設定。</span><span class="sxs-lookup"><span data-stu-id="8aa38-151">When you are creating a tabular model database, by default the database inherits these cultural and linguistic settings in the form of a language identifier and collation.</span></span>  
  
-   <span data-ttu-id="8aa38-152">語言識別碼定義要根據文化特性用於字串的字元集。</span><span class="sxs-lookup"><span data-stu-id="8aa38-152">The language identifier defines the character set you want to use for your strings according to your culture.</span></span>  
  
-   <span data-ttu-id="8aa38-153">定序定義字元的順序及其相等。</span><span class="sxs-lookup"><span data-stu-id="8aa38-153">The collation defines the ordering of the characters and their equivalence.</span></span>  
  
 <span data-ttu-id="8aa38-154">請務必注意，語言識別碼不僅識別語言，也識別使用該語言的國家或地區。</span><span class="sxs-lookup"><span data-stu-id="8aa38-154">It is important to note that a language identifier not only identifies a language but, also the country or region where the language is used.</span></span> <span data-ttu-id="8aa38-155">每個語言識別碼還具有預設的定序規格。</span><span class="sxs-lookup"><span data-stu-id="8aa38-155">Each language identifier also has a default collation specification.</span></span> <span data-ttu-id="8aa38-156">如需有關語言識別碼的詳細資訊，請參閱＜ [Microsoft 指派的地區設定識別碼](https://msdn.microsoft.com/goglobal/bb964664.aspx)＞。</span><span class="sxs-lookup"><span data-stu-id="8aa38-156">For more information about language identifiers, see [Locale IDs Assigned by Microsoft](https://msdn.microsoft.com/goglobal/bb964664.aspx).</span></span> <span data-ttu-id="8aa38-157">您可以使用 LCID Dec 資料行，在手動插入值時取得正確的識別碼。</span><span class="sxs-lookup"><span data-stu-id="8aa38-157">You can use the LCID Dec column to get the correct ID when manually inserting a value.</span></span> <span data-ttu-id="8aa38-158">如需有關 SQL 定序概念的詳細資訊，請參閱 [COLLATE &#40;Transact-SQL&#41;](/sql/t-sql/statements/collations)。</span><span class="sxs-lookup"><span data-stu-id="8aa38-158">For more information about the SQL concept of collations, see [COLLATE &#40;Transact-SQL&#41;](/sql/t-sql/statements/collations).</span></span> <span data-ttu-id="8aa38-159">如需有關定序指定項和 Windows 定序名稱比較樣式的詳細資訊，請參閱 [Windows 定序名稱 &#40;Transact-SQL&#41;](/sql/t-sql/statements/windows-collation-name-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="8aa38-159">For information about the collation designators and the comparison styles for Windows collation names, see [Windows Collation Name &#40;Transact-SQL&#41;](/sql/t-sql/statements/windows-collation-name-transact-sql).</span></span> <span data-ttu-id="8aa38-160">主題 [SQL Server 定序名稱 &#40;Transact-SQL&#41;](/sql/t-sql/statements/sql-server-collation-name-transact-sql) 將 Windows 定序名稱對應至用於 SQL 的名稱。</span><span class="sxs-lookup"><span data-stu-id="8aa38-160">The topic, [SQL Server Collation Name &#40;Transact-SQL&#41;](/sql/t-sql/statements/sql-server-collation-name-transact-sql), maps the Windows collation names to the names used for SQL.</span></span>  
  
 <span data-ttu-id="8aa38-161">一旦建立您的表格式模型資料庫之後，該模型中的所有新物件都會從資料庫屬性繼承語言和定序屬性。</span><span class="sxs-lookup"><span data-stu-id="8aa38-161">Once your tabular model database has been created, all new objects in the model will inherit the language and collation attributes from the database attributes.</span></span> <span data-ttu-id="8aa38-162">所有物件都是這樣的。</span><span class="sxs-lookup"><span data-stu-id="8aa38-162">This is true for all objects.</span></span> <span data-ttu-id="8aa38-163">繼承路徑從物件開始，查看父系中是否有要繼承的任何語言和定序屬性，如果找不到，則繼續向上在資料庫層級尋找語言和定序屬性。</span><span class="sxs-lookup"><span data-stu-id="8aa38-163">The inheritance path begins at the object, looks at the parent for any language and collation attributes to inherit, and if none are found, continues to the top and finds the language and collation attributes at the database level.</span></span> <span data-ttu-id="8aa38-164">換言之，如果您沒有為物件指定語言和定序屬性，則根據預設，物件會繼承其最接近的父系的屬性。</span><span class="sxs-lookup"><span data-stu-id="8aa38-164">In other words, if you do not specify the language and collation attributes for an object, by default, the object inherits the attributes of its closest parent.</span></span>  
  
 <span data-ttu-id="8aa38-165">資料行會根據下列規則，在建立時繼承語言和定序屬性：</span><span class="sxs-lookup"><span data-stu-id="8aa38-165">For columns, the language and collation attributes are inherited at creation, according to the following rules:</span></span>  
  
1.  <span data-ttu-id="8aa38-166">搜尋父維度物件中是否有語言和定序屬性。</span><span class="sxs-lookup"><span data-stu-id="8aa38-166">The parent dimension object is searched for language and collation attributes.</span></span> <span data-ttu-id="8aa38-167">如果這兩個值存在，則將它們複製到資料行屬性中；如果只存在一個值，則從現有值推斷另一個值並且指派這兩個值；如果兩個值都不存在，則移至下一步。</span><span class="sxs-lookup"><span data-stu-id="8aa38-167">If both values exist, they are copied to the column attributes; if only one exists, the other is inferred from the existing one and both are assigned; if none exist, move to next step.</span></span>  
  
2.  <span data-ttu-id="8aa38-168">使用步驟 1 所述維度的相同程序搜尋資料庫物件；如果找不到任何屬性，則移至下一步。</span><span class="sxs-lookup"><span data-stu-id="8aa38-168">The database object is searched using the same process described in Step 1 for dimensions; if no attributes are found, move to the next step.</span></span>  
  
3.  <span data-ttu-id="8aa38-169">使用步驟 1 所述維度的相同程序搜尋伺服器物件；如果找不到任何屬性，則資料行使用 Windows 語言識別碼並且從該值推斷定序屬性。</span><span class="sxs-lookup"><span data-stu-id="8aa38-169">The server object is searched using the same process described in Step 1 for dimensions; if no attributes are found, the column uses the Windows language identifier and infers the collation attribute from that value.</span></span>  
  
 <span data-ttu-id="8aa38-170">請務必注意，來源資料庫中的語言識別碼和定序順序通常對表格式模型資料行中儲存值的方式影響很小，甚至沒有影響。</span><span class="sxs-lookup"><span data-stu-id="8aa38-170">It is important to note that typically the language identifier and collation order in the source database has little to no effect on how values are stored in the tabular model column.</span></span> <span data-ttu-id="8aa38-171">例外是當來源資料庫轉換或篩選要求的值時。</span><span class="sxs-lookup"><span data-stu-id="8aa38-171">The exception is if the source database transforms or filters the requested values.</span></span>  
  
  
