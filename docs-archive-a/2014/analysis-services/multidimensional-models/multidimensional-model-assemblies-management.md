---
title: 多維度模型元件管理 |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- permissions [Analysis Services], assemblies
- calling user-defined functions
- user impersonation [Analysis Services]
- impersonation [Analysis Services]
- Data Mining Extensions [Analysis Services], assemblies
- MDX [Analysis Services], assemblies
- user-defined functions [Analysis Services]
- Analysis Services objects, assemblies
- assemblies [Analysis Services]
- application domains [Analysis Services]
ms.assetid: b2645d10-6d17-444e-9289-f111ec48bbfb
author: minewiskan
ms.author: owend
ms.openlocfilehash: b95a3171b3b194e84f10809f71eb72fefb07172b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87687277"
---
# <a name="multidimensional-model-assemblies-management"></a><span data-ttu-id="a846c-102">多維度模型組件管理</span><span class="sxs-lookup"><span data-stu-id="a846c-102">Multidimensional Model Assemblies Management</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="a846c-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 提供許多內建函數，可搭配多維度運算式使用 (MDX) 和資料採礦延伸模組 (DMX) 語言，其設計目的是為了完成標準統計計算中的所有專案，以便在階層中的成員進行處理。</span><span class="sxs-lookup"><span data-stu-id="a846c-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] supplies lots of intrinsic functions for use with the Multidimensional Expressions (MDX) and Data Mining Extensions (DMX) languages, designed to accomplish everything from standard statistical calculations to traversing members in a hierarchy.</span></span> <span data-ttu-id="a846c-104">但是，就如同其他複雜且強固的產品一樣，總是有進一步擴充產品功能的需求。</span><span class="sxs-lookup"><span data-stu-id="a846c-104">But, as with any other complex and robust product, there is always the need to extend the functionality of such a product further.</span></span>  
  
 <span data-ttu-id="a846c-105">因此， [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 可讓您將組件加入 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 執行個體或資料庫中。</span><span class="sxs-lookup"><span data-stu-id="a846c-105">Therefore, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] lets you add assemblies to an [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] instance or database.</span></span> <span data-ttu-id="a846c-106">組件可讓您使用任何 Common Language Runtime (CLR) 語言 (例如 Microsoft Visual Basic .NET 或 Microsoft Visual C#) 來建立外部使用者自訂函數。</span><span class="sxs-lookup"><span data-stu-id="a846c-106">Assemblies let you create external, user-defined functions using any common language runtime (CLR) language, such as Microsoft Visual Basic .NET or Microsoft Visual C#.</span></span> <span data-ttu-id="a846c-107">您也可以使用元件物件模型 (COM) 自動化語言 (例如 Microsoft Visual Basic 或 Microsoft Visual C++)。</span><span class="sxs-lookup"><span data-stu-id="a846c-107">You can also use Component Object Model (COM) Automation languages such as Microsoft Visual Basic or Microsoft Visual C++.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="a846c-108">COM 組件可能會造成安全性風險。</span><span class="sxs-lookup"><span data-stu-id="a846c-108">COM assemblies might pose a security risk.</span></span> <span data-ttu-id="a846c-109">由於這項風險和其他考量，COM 組件在 [!INCLUDE[ssASversion10](../../includes/ssasversion10-md.md)]中已經被取代。</span><span class="sxs-lookup"><span data-stu-id="a846c-109">Due to this risk and other considerations, COM assemblies were deprecated in [!INCLUDE[ssASversion10](../../includes/ssasversion10-md.md)].</span></span> <span data-ttu-id="a846c-110">在未來的版本中，可能不再支援 COM 組件。</span><span class="sxs-lookup"><span data-stu-id="a846c-110">COM assemblies might not be supported in future releases.</span></span>  
  
 <span data-ttu-id="a846c-111">組件可以讓您延伸 MDX 和 DMX 的商務功能。</span><span class="sxs-lookup"><span data-stu-id="a846c-111">Assemblies let you extend the business functionality of MDX and DMX.</span></span> <span data-ttu-id="a846c-112">您可以將想要的功能建立成程式庫 (例如動態連結程式庫 (DLL))，然後將該程式庫當成組件加入 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 執行個體或 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 資料庫中。</span><span class="sxs-lookup"><span data-stu-id="a846c-112">You build the functionality that you want into a library, such as a dynamic link library (DLL) and add the library as an assembly to an instance of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] or to an [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] database.</span></span> <span data-ttu-id="a846c-113">程式庫中的公用方法便公開給 MDX 和 DMX 運算式、程序、計算、動作，以及用戶端應用程式，作為使用者自訂函數。</span><span class="sxs-lookup"><span data-stu-id="a846c-113">The public methods in the library are then exposed as user-defined functions to MDX and DMX expressions, procedures, calculations, actions, and client applications.</span></span>  
  
 <span data-ttu-id="a846c-114">具有新程序和函數的組件可加入到伺服器。</span><span class="sxs-lookup"><span data-stu-id="a846c-114">An assembly with new procedures and functions can be added to the server.</span></span> <span data-ttu-id="a846c-115">您可以使用組件來增強或加入伺服器未提供的自訂功能。</span><span class="sxs-lookup"><span data-stu-id="a846c-115">You can use assemblies to enhance or add custom functionality that is not provided by the server.</span></span> <span data-ttu-id="a846c-116">藉由使用組件，便可以將新的功能加入多維度運算式 (MDX)、資料採礦延伸模組 (DMX) 或預存程序。</span><span class="sxs-lookup"><span data-stu-id="a846c-116">By using assemblies, you can add new functions to Multidimensional Expressions (MDX), Data Mining Extensions (DMX), or stored procedures.</span></span> <span data-ttu-id="a846c-117">組件會從自訂應用程式執行所在的位置載入，而且會將組件二進位檔案的複本連同資料庫資料儲存在伺服器中。</span><span class="sxs-lookup"><span data-stu-id="a846c-117">Assemblies are loaded from the location where the custom application is run, and a copy of the assembly binary file is saved along with the database data in the server.</span></span> <span data-ttu-id="a846c-118">當移除組件時，複製的組件也會從伺服器中移除。</span><span class="sxs-lookup"><span data-stu-id="a846c-118">When an assembly is removed, the copied assembly is also removed from the server.</span></span>  
  
 <span data-ttu-id="a846c-119">組件可以有兩種不同類型：COM 和 CLR。</span><span class="sxs-lookup"><span data-stu-id="a846c-119">Assemblies can be of two different types: COM and CLR.</span></span> <span data-ttu-id="a846c-120">CLR 組件是使用 .NET Framework 程式設計語言 (如 C#、Visual Basic .NET、Managed C++) 開發的組件。</span><span class="sxs-lookup"><span data-stu-id="a846c-120">CLR assemblies are assemblies developed in .NET Framework programming languages such as C#, Visual Basic .NET, managed C++.</span></span> <span data-ttu-id="a846c-121">COM 組件是必須在伺服器上註冊的 COM 程式庫。</span><span class="sxs-lookup"><span data-stu-id="a846c-121">COM assemblies are COM libraries that must be registered in the server</span></span>  
  
 <span data-ttu-id="a846c-122">組件可加入 <xref:Microsoft.AnalysisServices.Server> 或 <xref:Microsoft.AnalysisServices.Database> 物件。</span><span class="sxs-lookup"><span data-stu-id="a846c-122">Assemblies can be added to <xref:Microsoft.AnalysisServices.Server> or <xref:Microsoft.AnalysisServices.Database> objects.</span></span> <span data-ttu-id="a846c-123">伺服器組件可由連接到伺服器或伺服器中任何物件的任何使用者所呼叫。</span><span class="sxs-lookup"><span data-stu-id="a846c-123">Server assemblies can be called by any user connected to the server or any object in the server.</span></span> <span data-ttu-id="a846c-124">資料庫組件只能由連接到資料庫的 <xref:Microsoft.AnalysisServices.Database> 物件或使用者所呼叫。</span><span class="sxs-lookup"><span data-stu-id="a846c-124">Database assemblies can be called only by <xref:Microsoft.AnalysisServices.Database> objects or users connected to the database.</span></span>  
  
 <span data-ttu-id="a846c-125">簡單 <xref:Microsoft.AnalysisServices.Assembly> 物件是由基本資訊 (名稱和識別碼)、檔案集合和安全性規格所組成。</span><span class="sxs-lookup"><span data-stu-id="a846c-125">A simple <xref:Microsoft.AnalysisServices.Assembly> object is composed of basic information (Name and Id), file collection, and security specifications.</span></span>  
  
 <span data-ttu-id="a846c-126">檔案集合指的是載入的組件檔案以及其對應的偵錯 (.pdb) 檔案 (如果這些偵錯檔案與組件檔案一起載入)。</span><span class="sxs-lookup"><span data-stu-id="a846c-126">The file collection refers to the loaded assembly files and their corresponding debugging (.pdb) files, if the debugging files were loaded with the assembly files.</span></span> <span data-ttu-id="a846c-127">組件檔案會從應用程式定義檔案的位置載入，而且會將複本連同資料儲存在伺服器中。</span><span class="sxs-lookup"><span data-stu-id="a846c-127">Assembly files are loaded from the location where the application defined the files to, and a copy is saved in the server along with the data.</span></span> <span data-ttu-id="a846c-128">組件檔案的複本是用在每次啟動服務時載入組件。</span><span class="sxs-lookup"><span data-stu-id="a846c-128">The copy of the assembly file is used to load the assembly every time the service is started.</span></span>  
  
 <span data-ttu-id="a846c-129">安全性指定包含用來執行組件的權限集合和模擬。</span><span class="sxs-lookup"><span data-stu-id="a846c-129">Security specifications include the permission set and the impersonation used to run the assembly.</span></span>  
  
## <a name="calling-user-defined-functions"></a><span data-ttu-id="a846c-130">呼叫使用者自訂函數</span><span class="sxs-lookup"><span data-stu-id="a846c-130">Calling User-Defined Functions</span></span>  
 <span data-ttu-id="a846c-131">在組件中呼叫使用者自訂函數的方式，與呼叫內建函數的方式相同，只不過您需要使用完整名稱。</span><span class="sxs-lookup"><span data-stu-id="a846c-131">Calling a user-defined function in an assembly is performed just like calling an intrinsic function, except that you must use a fully qualified name.</span></span> <span data-ttu-id="a846c-132">例如，傳回 MDX 所預期類型的使用者自訂函數，會包含在 MDX 查詢中，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="a846c-132">For example, a user-defined function that returns a type expected by MDX is included in an MDX query, as shown in the following example:</span></span>  
  
```  
Select MyAssembly.MyClass.MyStoredProcedure(a, b, c) on 0 from Sales  
```  
  
 <span data-ttu-id="a846c-133">使用者自訂函數亦可使用 CALL 關鍵字呼叫。</span><span class="sxs-lookup"><span data-stu-id="a846c-133">User-defined functions can also be called using the CALL keyword.</span></span> <span data-ttu-id="a846c-134">針對會傳回資料錄集或空值的使用者自訂函數，您必須使用 CALL 關鍵字；但如果使用者自訂函數是取決於 MDX 或 DMX 陳述式或指令碼內容中的物件 (例如目前的 Cube 或資料採礦模型)，則不可使用 CALL 關鍵字。</span><span class="sxs-lookup"><span data-stu-id="a846c-134">You must use the CALL keyword for user-defined functions which return recordsets or void values, and you cannot use the CALL keyword if the user-defined function depends on an object in the context of the MDX or DMX statement or script, such as the current cube or data mining model.</span></span> <span data-ttu-id="a846c-135">在 MDX 或 DMX 查詢之外呼叫函數的常見用途是使用 AMO 物件模型來執行管理功能。</span><span class="sxs-lookup"><span data-stu-id="a846c-135">A common use for a function called outside an MDX or DMX query is to use the AMO object model to perform administrative functions.</span></span> <span data-ttu-id="a846c-136">例如，如果您想要在 MDX 陳述式中使用 `MyVoidProcedure(a, b, c)` 函數，就應使用下列語法：</span><span class="sxs-lookup"><span data-stu-id="a846c-136">If, for example, you wanted to use the function `MyVoidProcedure(a, b, c)` in an MDX statement, the following syntax would be employed:</span></span>  
  
```  
Call MyAssembly.MyClass.MyVoidProcedure(a, b, c)  
```  
  
 <span data-ttu-id="a846c-137">組件的使用讓通用程式碼只需要開發一次，並儲存於單一位置，以簡化資料庫的開發。</span><span class="sxs-lookup"><span data-stu-id="a846c-137">Assemblies simplify database development by enabling common code to be developed once and stored in a single location.</span></span> <span data-ttu-id="a846c-138">用戶端軟體開發人員可針對 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 建立函數程式庫，然後將它們和應用程式一起散發。</span><span class="sxs-lookup"><span data-stu-id="a846c-138">Client software developers can create libraries of functions for [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] and distribute them with their applications.</span></span>  
  
 <span data-ttu-id="a846c-139">組件和使用者自訂函數可以重複 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 函數程式庫的函數名稱，或其他組件的函數名稱。</span><span class="sxs-lookup"><span data-stu-id="a846c-139">Assemblies and user-defined functions can duplicate the function names of the [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] function library or of other assemblies.</span></span> <span data-ttu-id="a846c-140">只要您使用完整名稱來呼叫使用者自訂函數， [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 就會使用正確的程序。</span><span class="sxs-lookup"><span data-stu-id="a846c-140">As long as you call the user-defined function by using its fully qualified name, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] will use the correct procedure.</span></span> <span data-ttu-id="a846c-141">基於安全性的理由，以及避免呼叫到不同類別庫中之重複名稱的可能性， [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 會要求您只使用預存程序的完整名稱。</span><span class="sxs-lookup"><span data-stu-id="a846c-141">For security purposes, and to eliminate the chance of calling a duplicate name in a different class library, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] requires that you use only fully qualified names for stored procedures.</span></span>  
  
 <span data-ttu-id="a846c-142">若要從特定 CLR 組件呼叫使用者自訂函數，該使用者自訂函數將置於組件名稱、完整類別名稱，以及程序名稱之後，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a846c-142">To call a user-defined function from a specific CLR assembly, the user-defined function is preceded by the assembly name, full class name, and procedure name, as demonstrated here:</span></span>  
  
 <span data-ttu-id="a846c-143">*AssemblyName*。*FullClassName*。*程式名稱* (*Argument1*， *Argument2*，... ) </span><span class="sxs-lookup"><span data-stu-id="a846c-143">*AssemblyName*.*FullClassName*.*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
 <span data-ttu-id="a846c-144">為了提供較早之 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]版本的回溯相容性，亦可接受下列語法：</span><span class="sxs-lookup"><span data-stu-id="a846c-144">For backward compatibility with earlier versions of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], the following syntax is also acceptable:</span></span>  
  
 <span data-ttu-id="a846c-145">*AssemblyName*!*FullClassName*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span><span class="sxs-lookup"><span data-stu-id="a846c-145">*AssemblyName*!*FullClassName*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
 <span data-ttu-id="a846c-146">如果 COM 程式庫支援多重介面，則介面識別碼也可以用來解析程序名稱，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a846c-146">If a COM library supports multiple interfaces, the interface ID can also be used to resolve the procedure name, as demonstrated here:</span></span>  
  
 <span data-ttu-id="a846c-147">*AssemblyName*!*InterfaceID*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span><span class="sxs-lookup"><span data-stu-id="a846c-147">*AssemblyName*!*InterfaceID*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
## <a name="security"></a><span data-ttu-id="a846c-148">安全性</span><span class="sxs-lookup"><span data-stu-id="a846c-148">Security</span></span>  
 <span data-ttu-id="a846c-149">組件的安全性是以 .NET Framework 安全性模型為基礎，它是一種程式碼存取安全性模型。</span><span class="sxs-lookup"><span data-stu-id="a846c-149">Security for assemblies is based on the .NET Framework security model, which is a code-access security model.</span></span> <span data-ttu-id="a846c-150">.NET Framework 支援程式碼存取安全性機制，而這個機制假設執行階段可以主控完全信任和部份信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="a846c-150">.NET Framework supports a code-access security mechanism that assumes that the runtime can host both fully trusted and partially trusted code.</span></span> <span data-ttu-id="a846c-151">受 .NET Framework 程式碼存取安全性保護的資源，一般都是以 Managed 程式碼包裝，而 Managed 程式碼在存取資源前會要求對應的權限。</span><span class="sxs-lookup"><span data-stu-id="a846c-151">The resources that are protected by .NET Framework code access security are typically wrapped by managed code which demands the corresponding permission before enabling access to the resource.</span></span> <span data-ttu-id="a846c-152">唯有在呼叫堆疊中所有的呼叫者 (在組件層級) 都具有對應的資源權限時，權限的要求才會被滿足。</span><span class="sxs-lookup"><span data-stu-id="a846c-152">The demand for the permission is satisfied only if all the callers (at the assembly level) in the call stack have the corresponding resource permission.</span></span>  
  
 <span data-ttu-id="a846c-153">針對組件，執行的權限會透過 `PermissionSet` 物件的 `Assembly` 屬性傳遞。</span><span class="sxs-lookup"><span data-stu-id="a846c-153">For assemblies, permission for execution is passed with the `PermissionSet` property on the `Assembly` object.</span></span> <span data-ttu-id="a846c-154">Managed 程式碼所接收的權限是由實行中的安全性原則決定。</span><span class="sxs-lookup"><span data-stu-id="a846c-154">The permissions that managed code receives are determined by the security policy in effect.</span></span> <span data-ttu-id="a846c-155">在非[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 主控環境中，已實行三個層級的原則：企業、電腦和使用者。</span><span class="sxs-lookup"><span data-stu-id="a846c-155">There are already three levels of policy in effect in a non-[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] hosted environment: enterprise, computer and user.</span></span> <span data-ttu-id="a846c-156">程式碼所接收的有效權限清單是由這三個層級所取得的權限交集決定。</span><span class="sxs-lookup"><span data-stu-id="a846c-156">The effective list of permissions that code receives is determined by the intersection of the permissions obtained by these three levels.</span></span>  
  
 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="a846c-157">在主控 CLR 時，會將主機層級的安全性原則層級提供給該 CLR；這項原則是位在永遠會實行之三個原則層級下的其他原則層級。</span><span class="sxs-lookup"><span data-stu-id="a846c-157">supplies a host-level security policy level to the CLR while hosting it; this policy is an additional policy level below the three policy levels that are always in effect.</span></span> <span data-ttu-id="a846c-158">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]建立的每一個應用程式網域都會設定此原則。</span><span class="sxs-lookup"><span data-stu-id="a846c-158">This policy is set for every application domain that is created by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="a846c-159">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 主機層級原則，是系統組件的 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 固定原則，以及使用者組件的使用者指定原則的組合。</span><span class="sxs-lookup"><span data-stu-id="a846c-159">The [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] host-level policy is a combination of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] fixed policy for system assemblies and user-specified policy for user assemblies.</span></span> <span data-ttu-id="a846c-160">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 主機原則之使用者自訂部份根據的是指定每個組件之下列其中一種權限值區 (共三種) 的組件擁有者：</span><span class="sxs-lookup"><span data-stu-id="a846c-160">The user-specified piece of the [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] host policy is based on the assembly owner specifying one of three permission buckets for each assembly:</span></span>  
  
|<span data-ttu-id="a846c-161">權限設定</span><span class="sxs-lookup"><span data-stu-id="a846c-161">Permission Setting</span></span>|<span data-ttu-id="a846c-162">描述</span><span class="sxs-lookup"><span data-stu-id="a846c-162">Description</span></span>|  
|------------------------|-----------------|  
|`Safe`|<span data-ttu-id="a846c-163">提供內部計算權限。</span><span class="sxs-lookup"><span data-stu-id="a846c-163">Provides internal computation permission.</span></span> <span data-ttu-id="a846c-164">這個權限值區不會指派權限，來存取 .NET Framework 中的所有受保護資源。</span><span class="sxs-lookup"><span data-stu-id="a846c-164">This permission bucket does not assign permissions to access any of the protected resources in the .NET Framework.</span></span> <span data-ttu-id="a846c-165">如果未使用 `PermissionSet` 屬性指定任何權限，這就會是組件的預設權限值區。</span><span class="sxs-lookup"><span data-stu-id="a846c-165">This is the default permission bucket for an assembly if none is specified with the `PermissionSet` property.</span></span>|  
|`ExternalAccess`|<span data-ttu-id="a846c-166">提供和 `Safe` 設定相同的存取權，並附帶存取外部系統資源的能力。</span><span class="sxs-lookup"><span data-stu-id="a846c-166">Provides the same access as the `Safe` setting, with the additional ability to access external system resources.</span></span> <span data-ttu-id="a846c-167">這個權限值區不提供安全性保證 (雖然是可以確保此情況的安全)，但是可以提供可靠性的保證。</span><span class="sxs-lookup"><span data-stu-id="a846c-167">This permission bucket does not offer security guarantees (although it is possible to secure this scenario), but it does give reliability guarantees.</span></span>|  
|`Unsafe`|<span data-ttu-id="a846c-168">不提供限制。</span><span class="sxs-lookup"><span data-stu-id="a846c-168">Provides no restrictions.</span></span> <span data-ttu-id="a846c-169">在此權限設定下執行的 Managed 程式碼，無法提供安全性或可靠性的保證。</span><span class="sxs-lookup"><span data-stu-id="a846c-169">No security or reliability guarantees can be made for managed code running under this permission set.</span></span> <span data-ttu-id="a846c-170">任何權限，即使是管理員納入的自訂權限，皆可被授與在本信任層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="a846c-170">Any permission, even a custom permission included by the administrator, is granted to code running at this level of trust.</span></span>|  
  
 <span data-ttu-id="a846c-171">當 CLR 是由 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]主控時，以堆疊查核行程為基礎的權限檢查，就會在原生 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 程式碼的界限處停止。</span><span class="sxs-lookup"><span data-stu-id="a846c-171">When CLR is hosted by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], the stack-walk based permission check stops at the boundary with native [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] code.</span></span> <span data-ttu-id="a846c-172">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 組件中的任何 Managed 程式碼都一定會落入前面所列之三種權限類別目錄的其中一種。</span><span class="sxs-lookup"><span data-stu-id="a846c-172">Any managed code in [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] assemblies always falls into one of the three permission categories listed earlier.</span></span>  
  
 <span data-ttu-id="a846c-173">COM (或 Unmanaged) 組件常式不支援 CLR 安全性模型。</span><span class="sxs-lookup"><span data-stu-id="a846c-173">COM (or unmanaged) assembly routines do not support the CLR security model.</span></span>  
  
### <a name="impersonation"></a><span data-ttu-id="a846c-174">模擬</span><span class="sxs-lookup"><span data-stu-id="a846c-174">Impersonation</span></span>  
 <span data-ttu-id="a846c-175">只要 Managed 程式碼存取任何在 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 外部的資源時，[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 就會遵循與組件之 `ImpersonationMode` 屬性設定相關的規則，以確定該存取會發生在適當的 Windows 安全性內容中。</span><span class="sxs-lookup"><span data-stu-id="a846c-175">Whenever managed code accesses any resource outside [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] follows the rules associated with the `ImpersonationMode` property setting of the assembly to make sure that the access occurs in an appropriate Windows security context.</span></span> <span data-ttu-id="a846c-176">因為使用 `Safe` 權限設定的組件無法存取 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 外部的資源，所以這些規則僅適用於使用 `ExternalAccess` 和 `Unsafe` 權限設定的組件。</span><span class="sxs-lookup"><span data-stu-id="a846c-176">Because assemblies using the `Safe` permission setting cannot access resources outside [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], these rules are applicable only for assemblies using the `ExternalAccess` and `Unsafe` permission settings.</span></span>  
  
-   <span data-ttu-id="a846c-177">如果目前的執行內容對應到 Windows 驗證的登入，且與原始呼叫者的內容相同 (即中間沒有 EXECUTE AS)，則 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 會在存取資源之前模擬 Windows 驗證的登入。</span><span class="sxs-lookup"><span data-stu-id="a846c-177">If the current execution context corresponds to Windows Authenticated login and is the same as the context of the original caller (that is, there is no EXECUTE AS in the middle), [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] will impersonate the Windows Authenticated login before accessing the resource.</span></span>  
  
-   <span data-ttu-id="a846c-178">如果有中繼 EXECUTE AS 變更了來自原始呼叫者的內容，對外部資源存取的嘗試就會失敗。</span><span class="sxs-lookup"><span data-stu-id="a846c-178">If there is an intermediate EXECUTE AS that changed the context from that of the original caller), the attempt to access external resource will fail.</span></span>  
  
 <span data-ttu-id="a846c-179">可將 `ImpersonationMode` 屬性設定為 `ImpersonateCurrentUser` 或 `ImpersonateAnonymous`。</span><span class="sxs-lookup"><span data-stu-id="a846c-179">The `ImpersonationMode` property can be set to `ImpersonateCurrentUser` or `ImpersonateAnonymous`.</span></span> <span data-ttu-id="a846c-180">預設值是 `ImpersonateCurrentUser`，會用來以目前使用者的網路登入帳戶執行組件。</span><span class="sxs-lookup"><span data-stu-id="a846c-180">The default setting, `ImpersonateCurrentUser`, runs an assembly under the current user's network login account.</span></span> <span data-ttu-id="a846c-181">如果 `ImpersonateAnonymous` 使用設定，則執行內容會對應至伺服器上 IUSER_*Servername*的 Windows 登入使用者帳戶。</span><span class="sxs-lookup"><span data-stu-id="a846c-181">If the `ImpersonateAnonymous` setting is used, the execution context is corresponds to the Windows login user account IUSER_*servername* on the server.</span></span> <span data-ttu-id="a846c-182">這是網際網路 Guest 帳戶，在伺服器上的權限有限。</span><span class="sxs-lookup"><span data-stu-id="a846c-182">This is the Internet guest account, which has limited privileges on the server.</span></span> <span data-ttu-id="a846c-183">在這個內容中執行的組件，在本機伺服器上只能存取有限的資源。</span><span class="sxs-lookup"><span data-stu-id="a846c-183">An assembly running in this context can only access limited resources on the local server.</span></span>  
  
### <a name="application-domains"></a><span data-ttu-id="a846c-184">應用程式定義域</span><span class="sxs-lookup"><span data-stu-id="a846c-184">Application Domains</span></span>  
 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="a846c-185">不會直接公開應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="a846c-185">does not expose application domains directly.</span></span> <span data-ttu-id="a846c-186">因為組件集是在相同的應用程式網域中執行，所以應用程式網域可以在執行時期使用 .NET Framework 中的 `System.Reflection` 命名空間或其他方式，來發現彼此，也可用延遲繫結方式呼叫它們。</span><span class="sxs-lookup"><span data-stu-id="a846c-186">Because of a set of assemblies running in the same application domain, application domains can discover each other at execution time by using the `System.Reflection` namespace in the .NET Framework or in some other way, and can call into them in late-bound manner.</span></span> <span data-ttu-id="a846c-187">這種呼叫會遭受以 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 授權為基礎的安全性機制，進行權限檢查。</span><span class="sxs-lookup"><span data-stu-id="a846c-187">Such calls will be subject to the permission checks used by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] authorization-based security.</span></span>  
  
 <span data-ttu-id="a846c-188">因為應用程式網域界限和每個網域中的組件都是由實作所定義，所以您不應該依賴在同一應用程式網域中尋找組件。</span><span class="sxs-lookup"><span data-stu-id="a846c-188">You should not rely on finding assemblies in the same application domain, because the application domain boundary and the assemblies that go into each domain are defined by the implementation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a846c-189">另請參閱</span><span class="sxs-lookup"><span data-stu-id="a846c-189">See Also</span></span>  
 <span data-ttu-id="a846c-190">[設定預存程式的安全性](../multidimensional-models-extending-olap-stored-procedures/setting-security-for-stored-procedures.md) </span><span class="sxs-lookup"><span data-stu-id="a846c-190">[Setting Security for Stored Procedures](../multidimensional-models-extending-olap-stored-procedures/setting-security-for-stored-procedures.md) </span></span>  
 [<span data-ttu-id="a846c-191">定義預存程式</span><span class="sxs-lookup"><span data-stu-id="a846c-191">Defining Stored Procedures</span></span>](../multidimensional-models-extending-olap-stored-procedures/defining-stored-procedures.md)  
  
  
