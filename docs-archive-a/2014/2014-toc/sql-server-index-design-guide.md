---
title: SQL Server 索引設計指南 | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87585696"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="717e0-102">SQL Server 索引設計指南</span><span class="sxs-lookup"><span data-stu-id="717e0-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="717e0-103">設計不良的索引與不足的索引是資料庫應用程式瓶頸的主要原因。</span><span class="sxs-lookup"><span data-stu-id="717e0-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="717e0-104">設計有效的索引是達到良好資料庫和應用程式效能最重要的一點。</span><span class="sxs-lookup"><span data-stu-id="717e0-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="717e0-105">本 SQL Server 索引設計指南包含的資訊和最佳作法，可以協助您設計符合應用程式需求的有效索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="717e0-106">**適用于**： [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] 至，除非另有 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 說明。</span><span class="sxs-lookup"><span data-stu-id="717e0-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="717e0-107">本指南假設讀者對 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中提供的索引類型有概略的認識。</span><span class="sxs-lookup"><span data-stu-id="717e0-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="717e0-108">如需索引類型的一般描述，請參閱 [Index Types](../relational-databases/indexes/indexes.md)(索引類型)。</span><span class="sxs-lookup"><span data-stu-id="717e0-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="717e0-109">本指南</span><span class="sxs-lookup"><span data-stu-id="717e0-109">In This Guide</span></span>  

 [<span data-ttu-id="717e0-110">索引設計基本概念</span><span class="sxs-lookup"><span data-stu-id="717e0-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="717e0-111">一般索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="717e0-112">叢集索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="717e0-113">非叢集索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="717e0-114">唯一索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="717e0-115">篩選索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="717e0-116">其他閱讀</span><span class="sxs-lookup"><span data-stu-id="717e0-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="717e0-117">索引設計基本概念</span><span class="sxs-lookup"><span data-stu-id="717e0-117">Index Design Basics</span></span>  

 <span data-ttu-id="717e0-118">索引是一種與資料表或檢視有關的磁碟內存結構，它會加快從該資料表或檢視中擷取資料列的速度。</span><span class="sxs-lookup"><span data-stu-id="717e0-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="717e0-119">索引中包含從資料表或檢視中一或多個資料行建出的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="717e0-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="717e0-120">這些索引鍵儲存在結構 (B 型樹狀結構) 中，讓 SQL Server 可以快速有效地尋找與索引鍵值相關的一個或多個資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="717e0-121">為資料庫選擇正確的索引及工作負載時，往往很難在查詢速度與更新成本之間取得平衡。</span><span class="sxs-lookup"><span data-stu-id="717e0-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="717e0-122">範圍較小的索引，或是索引的索引鍵中包含較少的資料行，所需的磁碟空間與維護負擔相對較小。</span><span class="sxs-lookup"><span data-stu-id="717e0-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="717e0-123">相反的，如果索引範圍較大，能涵蓋的查詢就更多。</span><span class="sxs-lookup"><span data-stu-id="717e0-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="717e0-124">在找到最有效率的索引之前，可能需要先試過數種不同的設計。</span><span class="sxs-lookup"><span data-stu-id="717e0-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="717e0-125">索引可以新增、修改和卸除，不會影響資料庫結構描述或應用程式的設計。</span><span class="sxs-lookup"><span data-stu-id="717e0-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="717e0-126">所以，不要吝於嘗試各種不同的索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="717e0-127">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 中的查詢最佳化工具可以確實地選擇在大多數情況中最有效率的索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="717e0-128">整體的索引設計策略應該為查詢最佳化工具提供多樣化的索引，然後信任它會做最恰當的決定。</span><span class="sxs-lookup"><span data-stu-id="717e0-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="717e0-129">這可降低分析時間，且會在各種不同狀況下得到相當好的效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="717e0-130">若要查看查詢最佳化工具用於特定查詢的索引，請在 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] 的 [查詢] 功能表中，選取 [包括實際執行計畫]。</span><span class="sxs-lookup"><span data-stu-id="717e0-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="717e0-131">使用索引不一定就會有良好的效能，良好的效能和有效率地使用索引也不能劃上等號。</span><span class="sxs-lookup"><span data-stu-id="717e0-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="717e0-132">如果使用索引對產生最佳效能一定有幫助，查詢最佳化工具的作業就很單純。</span><span class="sxs-lookup"><span data-stu-id="717e0-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="717e0-133">但事實上，選擇不正確的索引可能得不到最佳效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="717e0-134">因此，查詢最佳化工具的工作是只有在提升效能時才選擇索引或索引組合，如果會妨礙效能，就要避免索引式擷取。</span><span class="sxs-lookup"><span data-stu-id="717e0-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="717e0-135">索引設計工作</span><span class="sxs-lookup"><span data-stu-id="717e0-135">Index Design Tasks</span></span>  

 <span data-ttu-id="717e0-136">下列工作是針對設計索引所建議的策略：</span><span class="sxs-lookup"><span data-stu-id="717e0-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="717e0-137">了解資料庫本身的特性。</span><span class="sxs-lookup"><span data-stu-id="717e0-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="717e0-138">例如，這是經常修改資料的線上交易處理 (OLTP) 資料庫嗎？還是包含主要唯讀資料且必須快速處理非常龐大資料集的決策支援系統 (DSS) 或資料倉儲 (OLAP) 資料庫？</span><span class="sxs-lookup"><span data-stu-id="717e0-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="717e0-139">在 [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]中， *xVelocity 記憶體最佳化的資料行存放區索引* 特別適合一般資料倉儲資料集。</span><span class="sxs-lookup"><span data-stu-id="717e0-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="717e0-140">資料行存放區索引可以加快常用資料倉儲查詢 (如篩選、彙總、群組及星型聯結查詢等) 的速度，大幅改善使用者的資料倉儲經驗。</span><span class="sxs-lookup"><span data-stu-id="717e0-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="717e0-141">如需詳細資訊，請參閱描述的資料行存放區[索引](../relational-databases/indexes/columnstore-indexes-described.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="717e0-142">了解最常使用的查詢特性。</span><span class="sxs-lookup"><span data-stu-id="717e0-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="717e0-143">例如，知道最常使用的查詢會聯結兩個以上的資料表，將有助於判斷要使用的最佳類型索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="717e0-144">了解用於查詢的資料行特性。</span><span class="sxs-lookup"><span data-stu-id="717e0-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="717e0-145">例如，對於具有整數資料類型的資料行且也是唯一或非 Null 的資料行來說，索引是最理想的方式。</span><span class="sxs-lookup"><span data-stu-id="717e0-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="717e0-146">對於完善定義其資料子集的資料行，您可以在 [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 與更新版本中使用篩選索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="717e0-147">如需詳細資訊，請參閱本指南中的 [篩選索引設計指導方針](#Filtered) 。</span><span class="sxs-lookup"><span data-stu-id="717e0-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="717e0-148">建立或維護索引時，決定可能會提升效能的索引選項。</span><span class="sxs-lookup"><span data-stu-id="717e0-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="717e0-149">例如，ONLINE 索引選項對於在現有的大型資料表上建立叢集索引就有幫助。</span><span class="sxs-lookup"><span data-stu-id="717e0-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="717e0-150">ONLINE 選項會在建立或重建索引的同時，允許繼續進行基礎資料上的並行活動。</span><span class="sxs-lookup"><span data-stu-id="717e0-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="717e0-151">如需詳細資訊，請參閱 [設定索引選項](../relational-databases/indexes/set-index-options.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="717e0-152">決定最理想的索引儲存位置。</span><span class="sxs-lookup"><span data-stu-id="717e0-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="717e0-153">非叢集索引可以作為基礎資料表儲存在相同的檔案群組中，或儲存在不同的檔案群組中。</span><span class="sxs-lookup"><span data-stu-id="717e0-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="717e0-154">藉由增加磁碟 I/O 效能，索引的儲存位置可提升查詢效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="717e0-155">例如，將非叢集索引儲存在不同磁碟機上 (與資料表檔案群組不同的磁碟機) 的檔案群組中，可以同時讀取多部磁碟機，所以可提升效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="717e0-156">此外，叢集和非叢集索引可跨多個檔案群組使用資料分割結構描述。</span><span class="sxs-lookup"><span data-stu-id="717e0-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="717e0-157">資料分割使大型資料表或索引的管理更為容易，這是因為您可以快速有效地存取或管理資料的子集，同時維持整體集合的完整性。</span><span class="sxs-lookup"><span data-stu-id="717e0-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="717e0-158">如需詳細資訊，請參閱＜ [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md)＞。</span><span class="sxs-lookup"><span data-stu-id="717e0-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="717e0-159">當您考慮使用分割時，請決定是否應該校準索引，也就是說，使用分割資料表相同的方法進行分割，或獨立進行分割。</span><span class="sxs-lookup"><span data-stu-id="717e0-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="717e0-160">一般索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="717e0-161">經驗豐富的資料庫管理員可以設計出一組數量適中的索引，但即使是普通複雜的資料庫與工作量，這都是一件非常複雜、費時，且容易出錯的工作。</span><span class="sxs-lookup"><span data-stu-id="717e0-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="717e0-162">了解資料庫、查詢和資料行的特性可以協助您設計最佳化的索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="717e0-163">資料庫考量</span><span class="sxs-lookup"><span data-stu-id="717e0-163">Database Considerations</span></span>  

 <span data-ttu-id="717e0-164">當您設計索引時，請考慮下列資料庫指導方針：</span><span class="sxs-lookup"><span data-stu-id="717e0-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="717e0-165">資料表中的索引數量過多會影響到 INSERT、UPDATE、DELETE 和 MERGE 陳述式的效能，因為只要資料表中的資料一變更，所有的索引也都必須隨著調整。</span><span class="sxs-lookup"><span data-stu-id="717e0-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="717e0-166">例如，如果資料行會在數個索引中用到，而您執行了修改此資料行資料的 UPDATE 陳述式，則除了基礎基底資料表 (堆積或叢集的索引) 中的資料行之外，還必須更新每個含有該資料行的索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="717e0-167">請避免對時常更新的資料表過度索引，保持索引窄小，愈少資料行愈好。</span><span class="sxs-lookup"><span data-stu-id="717e0-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="717e0-168">對不常更新、但有大量資料的資料表使用多個索引可增進查詢效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="717e0-169">大量索引可以協助不修改資料之查詢的效能，例如 SELECT 陳述式，因為查詢最佳化工具有較多的索引可供選擇，以判斷最快的存取方法。</span><span class="sxs-lookup"><span data-stu-id="717e0-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="717e0-170">為小型資料表建立索引並不是最佳的方式，因為查詢最佳化工具透過查閱索引來搜尋資料，會比執行簡單的資料表掃描更費時。</span><span class="sxs-lookup"><span data-stu-id="717e0-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="717e0-171">因此，小型資料表上的索引不僅很少使用，而且還必須在資料表中的資料變更時進行維護。</span><span class="sxs-lookup"><span data-stu-id="717e0-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="717e0-172">當檢視包含彙總、資料表聯結或彙總與聯結的組合時，在檢視上建立索引可以提供重要的效能增進。</span><span class="sxs-lookup"><span data-stu-id="717e0-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="717e0-173">查詢中不必明確參考檢視，查詢最佳化工具會使用它。</span><span class="sxs-lookup"><span data-stu-id="717e0-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="717e0-174">使用 Database Engine Tuning Advisor 可分析資料庫，並提供索引建議。</span><span class="sxs-lookup"><span data-stu-id="717e0-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="717e0-175">如需詳細資訊，請參閱 [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="717e0-176">查詢注意事項</span><span class="sxs-lookup"><span data-stu-id="717e0-176">Query Considerations</span></span>  

 <span data-ttu-id="717e0-177">當您設計索引時，請考慮下列查詢指導方針：</span><span class="sxs-lookup"><span data-stu-id="717e0-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="717e0-178">在查詢之述詞及聯結條件經常使用的資料行上，建立非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="717e0-179">但應該避免加入不必要的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="717e0-180">加入太多索引資料行可能會對磁碟空間和索引維護效能產生不利的影響。</span><span class="sxs-lookup"><span data-stu-id="717e0-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="717e0-181">涵蓋索引可以增進查詢效能，因為查詢就存在於索引本身裡面，所有需要的資料都符合查詢的需求。</span><span class="sxs-lookup"><span data-stu-id="717e0-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="717e0-182">也就是說，擷取要求的資料時只需要索引頁，非資料表或叢集索引的資料頁；因此，可以減少整體的磁碟 I/O。</span><span class="sxs-lookup"><span data-stu-id="717e0-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="717e0-183">例如，某個資料表在 **a** 、 **b** 和 **c**資料行上已建立複合的索引，則 **a**和 **b** 資料行的查詢可以單獨從索引擷取指定的資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="717e0-184">撰寫的查詢應盡可能在一個陳述式中插入或修改最多資料列，而不是使用多個查詢來更新同樣的資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="717e0-185">只使用一個陳述式，才能利用到最佳化的索引維護方式。</span><span class="sxs-lookup"><span data-stu-id="717e0-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="717e0-186">評估查詢類型，以及查詢中如何使用資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="717e0-187">例如，在完全相符查詢類型中使用的資料行，就很適合當作非叢集或叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="717e0-188">資料行注意事項</span><span class="sxs-lookup"><span data-stu-id="717e0-188">Column Considerations</span></span>  

 <span data-ttu-id="717e0-189">當您設計索引時，請考慮下列資料行指導方針：</span><span class="sxs-lookup"><span data-stu-id="717e0-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="717e0-190">讓叢集索引保持短小的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="717e0-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="717e0-191">此外，對唯一或非 Null 資料行建立叢集索引，會有幫助。</span><span class="sxs-lookup"><span data-stu-id="717e0-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="717e0-192">`ntext`、`text`、`image`、`varchar(max)`、`nvarchar(max)` 和 `varbinary(max)` 資料類型的資料行不能指定為索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="717e0-193">但是，`varchar(max)`、`nvarchar(max)`、`varbinary(max)` 和 `xml` 資料類型則可參與非叢集索引，作為非索引鍵之索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="717e0-194">如需詳細資訊，請參閱本指南中的 [內含資料行的索引](#Included_Columns)一節。</span><span class="sxs-lookup"><span data-stu-id="717e0-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="717e0-195">`xml` 資料類型只可以是 XML 索引的索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="717e0-196">如需詳細資訊，請參閱 [XML 索引 &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="717e0-197">SQL Server 2012 SP1 導入了新的 XML 索引類型，稱為「選擇性 XML 索引」。</span><span class="sxs-lookup"><span data-stu-id="717e0-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="717e0-198">這個新索引可改善 SQL Server 中儲存為 XML 之資料的查詢效能，讓大型 XML 資料工作負載的索引編製更快速，並透過降低索引本身的儲存成本，改善延展性。</span><span class="sxs-lookup"><span data-stu-id="717e0-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="717e0-199">如需詳細資訊，請參閱[選擇性 XML 索引 &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="717e0-200">檢驗資料行唯一性。</span><span class="sxs-lookup"><span data-stu-id="717e0-200">Examine column uniqueness.</span></span> <span data-ttu-id="717e0-201">在相同組合的資料行上，唯一索引可提供額外的資訊給查詢最佳化工具，讓索引變得更有用。</span><span class="sxs-lookup"><span data-stu-id="717e0-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="717e0-202">如需詳細資訊，請參閱本指南中的 [唯一索引設計指導方針](#Unique) 。</span><span class="sxs-lookup"><span data-stu-id="717e0-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="717e0-203">檢驗資料行中的資料分散情形。</span><span class="sxs-lookup"><span data-stu-id="717e0-203">Examine data distribution in the column.</span></span> <span data-ttu-id="717e0-204">執行時間長的查詢往往是因為對唯一值少的資料行製作索引所造成，或對這樣的資料行執行聯結所造成。</span><span class="sxs-lookup"><span data-stu-id="717e0-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="717e0-205">這是資料與查詢本身的問題，若不找出問題，通常是無法解決的。</span><span class="sxs-lookup"><span data-stu-id="717e0-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="717e0-206">例如，如果城市裡每個人的名字都是 Smith 或 Jones，那麼依姓氏排序的實體電話簿就無法使尋找某人的速度加快。</span><span class="sxs-lookup"><span data-stu-id="717e0-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="717e0-207">如需有關資料分散的詳細資訊，請參閱 [統計資料](../relational-databases/statistics/statistics.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="717e0-208">請考慮在具有定義良好之子集的資料行 (如疏鬆資料行)、大部分的值都是 NULL 的資料行、具有值類別的資料行以及具有相異值範圍的資料行上使用篩選的索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="717e0-209">設計良好的已篩選索引可以提升查詢效能、降低索引維護成本，並減少儲存成本。</span><span class="sxs-lookup"><span data-stu-id="717e0-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="717e0-210">如果索引將包含多個資料行，可考慮資料行的順序。</span><span class="sxs-lookup"><span data-stu-id="717e0-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="717e0-211">用於 WHERE 子句等於 (=)、大於 (>)、小於 (<) 或 BETWEEN 搜尋條件中的資料行，或是參與聯結的資料行，應該要放在前面。</span><span class="sxs-lookup"><span data-stu-id="717e0-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="717e0-212">其他資料行應該按照它們的區分程度排序，亦即，從最能區分的排到最不能區分的。</span><span class="sxs-lookup"><span data-stu-id="717e0-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="717e0-213">例如，如果索引定義為 `LastName`、 `FirstName` ，當搜尋條件是 `WHERE LastName = 'Smith'` 或 `WHERE LastName = Smith AND FirstName LIKE 'J%'`時索引就會很有用。</span><span class="sxs-lookup"><span data-stu-id="717e0-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="717e0-214">但是，查詢最佳化工具不會為只搜尋 `FirstName (WHERE FirstName = 'Jane')`的查詢使用索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="717e0-215">考慮為計算的資料行建立索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-215">Consider indexing computed columns.</span></span> <span data-ttu-id="717e0-216">如需詳細資訊，請參閱 [計算資料行的索引](../relational-databases/indexes/indexes-on-computed-columns.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="717e0-217">索引特性</span><span class="sxs-lookup"><span data-stu-id="717e0-217">Index Characteristics</span></span>  

 <span data-ttu-id="717e0-218">當您決定好適合某一查詢的索引之後，便可選取最符合您需要的索引類型。</span><span class="sxs-lookup"><span data-stu-id="717e0-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="717e0-219">索引的特性包括下列項目：</span><span class="sxs-lookup"><span data-stu-id="717e0-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="717e0-220">叢集或非叢集</span><span class="sxs-lookup"><span data-stu-id="717e0-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="717e0-221">唯一或非唯一</span><span class="sxs-lookup"><span data-stu-id="717e0-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="717e0-222">單一資料行或多重資料行</span><span class="sxs-lookup"><span data-stu-id="717e0-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="717e0-223">索引中的資料行遞增或遞減順序</span><span class="sxs-lookup"><span data-stu-id="717e0-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="717e0-224">完整資料表與非叢集索引的篩選</span><span class="sxs-lookup"><span data-stu-id="717e0-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="717e0-225">您也可以自訂索引的初始儲存特性，設定如 FILLFACTOR 的選項來最佳化其效能或維護。</span><span class="sxs-lookup"><span data-stu-id="717e0-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="717e0-226">您也可以使用檔案群組或資料分割配置的方式決定索引儲存位置，以最佳化效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="717e0-227">檔案群組或資料分割配置上的索引位置</span><span class="sxs-lookup"><span data-stu-id="717e0-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="717e0-228">在您開發索引設計策略時，您應該考慮在資料庫關聯的檔案群組上之索引位置。</span><span class="sxs-lookup"><span data-stu-id="717e0-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="717e0-229">小心地選取檔案群組或資料分割配置將可改善查詢效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="717e0-230">依預設，索引會與建立索引的基底資料表儲存在同一個檔案群組中。</span><span class="sxs-lookup"><span data-stu-id="717e0-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="717e0-231">非資料分割的叢集索引與基底資料表永遠都在相同的檔案群組中。</span><span class="sxs-lookup"><span data-stu-id="717e0-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="717e0-232">然而，您仍可執行下列工作：</span><span class="sxs-lookup"><span data-stu-id="717e0-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="717e0-233">在基底資料表或叢集索引之檔案群組以外的檔案群組上，建立非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="717e0-234">將叢集與非叢集索引分割以跨越多個檔案群組。</span><span class="sxs-lookup"><span data-stu-id="717e0-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="717e0-235">在檔案群組之間移動資料表，方法為卸除叢集索引，並在 DROP INDEX 陳述式的 MOVE TO 子句中指定新檔案群組或資料分割配置，或使用 CREATE INDEX 陳述式加上 DROP_EXISTING 子句。</span><span class="sxs-lookup"><span data-stu-id="717e0-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="717e0-236">在別的檔案群組中建立非叢集索引後，如果檔案群組是使用不同的實體磁碟機，而且這些磁碟機各有它們自己的控制器，就可以獲得效能提升。</span><span class="sxs-lookup"><span data-stu-id="717e0-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="717e0-237">然後可以由多個磁碟讀寫頭平行讀取資料與索引資訊。</span><span class="sxs-lookup"><span data-stu-id="717e0-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="717e0-238">例如，如果 `Table_A` 在檔案群組 `f1` 上， `Index_A` 在檔案群組 `f2` 上，而這兩者都用於同一個查詢時，由於可以充分利用兩個檔案群組，不會出現競爭，因此可以改善效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="717e0-239">不過，如果查詢掃描 `Table_A` ，但不參考 `Index_A` ，就只會使用檔案群組 `f1` 。</span><span class="sxs-lookup"><span data-stu-id="717e0-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="717e0-240">這並不會創造效能的提升。</span><span class="sxs-lookup"><span data-stu-id="717e0-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="717e0-241">由於您無法預測何時會發生哪種存取方式，所以比較好的作法是將資料表與索引分散到所有的檔案群組。</span><span class="sxs-lookup"><span data-stu-id="717e0-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="717e0-242">這樣就可以保證會存取到所有的磁碟，因為不論資料的存取方式如何，所有的資料與索引都平均分散在所有的磁碟上。</span><span class="sxs-lookup"><span data-stu-id="717e0-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="717e0-243">這也是系統管理員較單純的作法。</span><span class="sxs-lookup"><span data-stu-id="717e0-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="717e0-244">多個檔案群組間的資料分割</span><span class="sxs-lookup"><span data-stu-id="717e0-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="717e0-245">您也可以考慮將叢集與非叢集索引分割於多個檔案群組之間。</span><span class="sxs-lookup"><span data-stu-id="717e0-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="717e0-246">資料分割索引是以水平方式分割，或根據資料分割函數依資料列來分割。</span><span class="sxs-lookup"><span data-stu-id="717e0-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="717e0-247">資料分割函數是用以定義每個資料列是否對應到一組資料分割，這些資料分割是根據一些稱為資料分割資料行之值。</span><span class="sxs-lookup"><span data-stu-id="717e0-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="717e0-248">資料分割配置指定資料分割與一組檔案群組的對應。</span><span class="sxs-lookup"><span data-stu-id="717e0-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="717e0-249">分割索引將可提供下列優點：</span><span class="sxs-lookup"><span data-stu-id="717e0-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="717e0-250">提供可擴充的系統，使大型索引更易於管理。</span><span class="sxs-lookup"><span data-stu-id="717e0-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="717e0-251">例如 OLTP 系統可實作資料分割感知的應用程式，以處理大型索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="717e0-252">使查詢執行更快和更具效率。</span><span class="sxs-lookup"><span data-stu-id="717e0-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="717e0-253">當查詢存取索引的一些資料分割時，查詢最佳化工具可以同時處理個別的資料分割並排除未受查詢影響的資料分割。</span><span class="sxs-lookup"><span data-stu-id="717e0-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="717e0-254">如需詳細資訊，請參閱＜ [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md)＞。</span><span class="sxs-lookup"><span data-stu-id="717e0-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="717e0-255">索引排序順序設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="717e0-256">定義索引時，您應該考慮要以遞增還是遞減的順序，來儲存索引鍵資料行的資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="717e0-257">遞增是預設值，且可繼續與舊版 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]相容。</span><span class="sxs-lookup"><span data-stu-id="717e0-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="717e0-258">CREATE INDEX、CREATE TABLE 與 ALTER TABLE 陳述式的語法，可在索引及條件約束的個別資料行上支援關鍵字 ASC (遞增) 與 DESC (遞減)。</span><span class="sxs-lookup"><span data-stu-id="717e0-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="717e0-259">指定在索引中將以何種順序儲存索引鍵值，在遇到下列情況時會很有用：參考資料表的查詢具有 ORDER BY 子句，且此子句指定的排序方向與該索引中索引鍵資料行的方向不同。</span><span class="sxs-lookup"><span data-stu-id="717e0-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="717e0-260">這種時候，查詢計畫就不需要對索引使用 SORT 運算子；因此可使得查詢更有效率。</span><span class="sxs-lookup"><span data-stu-id="717e0-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="717e0-261">例如， [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] 採購部門中的採購員必須評估他們向供應商購買的產品品質。</span><span class="sxs-lookup"><span data-stu-id="717e0-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="717e0-262">採購員想先找出這些供應商送來的產品中，哪些產品的退貨率較高。</span><span class="sxs-lookup"><span data-stu-id="717e0-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="717e0-263">如同下列查詢所示，要擷取符合這項條件的資料，需將 `RejectedQty` 資料表中的 `Purchasing.PurchaseOrderDetail` 資料行依遞減順序 (由大到小) 儲存，而 `ProductID` 資料行則依遞增順序 (由小到大) 儲存。</span><span class="sxs-lookup"><span data-stu-id="717e0-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="717e0-264">此查詢的下列執行計畫，顯示查詢最佳化工具使用了 SORT 運算子，按 ORDER BY 子句所指定的順序傳回結果集。</span><span class="sxs-lookup"><span data-stu-id="717e0-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="717e0-265">![執行計畫顯示使用 SORT 運算子。](media/indexsort1.gif "執行計畫顯示使用 SORT 運算子。")</span><span class="sxs-lookup"><span data-stu-id="717e0-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="717e0-266">如果利用符合查詢中 ORDER BY 子句的索引鍵資料行來建立索引，就不需要在查詢計畫中使用 SORT 運算子，因此查詢計畫可以更有效率。</span><span class="sxs-lookup"><span data-stu-id="717e0-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="717e0-267">再次執行查詢後，下列執行計畫會顯示已刪除 SORT 運算子，並使用了剛建立的非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="717e0-268">![執行計畫顯示未使用 SORT 運算子](media/insertsort2.gif "執行計畫顯示未使用 SORT 運算子")</span><span class="sxs-lookup"><span data-stu-id="717e0-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="717e0-269">[!INCLUDE[ssDE](../includes/ssde-md.md)] 往遞增或遞減方向移動的效率一樣高。</span><span class="sxs-lookup"><span data-stu-id="717e0-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="717e0-270">定義為 `(RejectedQty DESC, ProductID ASC)` 的索引，仍可用在 ORDER BY 子句中的資料行排序方向與其相反的查詢中。</span><span class="sxs-lookup"><span data-stu-id="717e0-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="717e0-271">例如，具有 ORDER BY 子句 `ORDER BY RejectedQty ASC, ProductID DESC` 的查詢就可以使用此索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="717e0-272">排序順序只能針對索引鍵資料行指定。</span><span class="sxs-lookup"><span data-stu-id="717e0-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="717e0-273">[sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) 目錄檢視及 INDEXKEY_PROPERTY 函數可回報索引資料行是按遞增還是遞減的順序排序。</span><span class="sxs-lookup"><span data-stu-id="717e0-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="717e0-274">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="717e0-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="717e0-275">叢集索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="717e0-276">叢集索引將資料表中的資料列依其索引鍵值排序與儲存。</span><span class="sxs-lookup"><span data-stu-id="717e0-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="717e0-277">因為資料列本身只能以一種順序排序，所以每個資料表只能有一個叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="717e0-278">除了一些例外之外，每個資料表都應該在資料行上定義叢集索引，以提供下列功能：</span><span class="sxs-lookup"><span data-stu-id="717e0-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="717e0-279">可用於經常使用的查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="717e0-280">提供高度的唯一性。</span><span class="sxs-lookup"><span data-stu-id="717e0-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="717e0-281">在建立 PRIMARY KEY 條件約束時，會在資料行上自動建立唯一索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="717e0-282">依預設，此索引已叢集化；不過，您可以在建立條件約束時指定非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="717e0-283">可用於範圍查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="717e0-284">如果叢集索引不是以 UNIQUE 屬性建立，則 [!INCLUDE[ssDE](../includes/ssde-md.md)] 會自動將4位元組的唯一碼資料行加入至資料表。</span><span class="sxs-lookup"><span data-stu-id="717e0-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="717e0-285">當需要時， [!INCLUDE[ssDE](../includes/ssde-md.md)] 會自動將唯一碼值加入資料列，使每個索引鍵都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="717e0-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="717e0-286">這個資料行及其值是供內部使用的，使用者看不到也無法存取它。</span><span class="sxs-lookup"><span data-stu-id="717e0-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="717e0-287">叢集索引架構</span><span class="sxs-lookup"><span data-stu-id="717e0-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="717e0-288">在 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中，索引的結構為 B 型樹狀目錄。</span><span class="sxs-lookup"><span data-stu-id="717e0-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="717e0-289">索引 B 型樹狀目錄中的每個分頁稱為索引節點。</span><span class="sxs-lookup"><span data-stu-id="717e0-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="717e0-290">B 型樹狀目錄的頂部節點稱為根節點。</span><span class="sxs-lookup"><span data-stu-id="717e0-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="717e0-291">索引中的最下層節點稱為分葉節點。</span><span class="sxs-lookup"><span data-stu-id="717e0-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="717e0-292">根與分葉節點之間的任何索引層級通稱為中繼層級。</span><span class="sxs-lookup"><span data-stu-id="717e0-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="717e0-293">在叢集索引中，分葉節點包含基礎資料表的資料頁。</span><span class="sxs-lookup"><span data-stu-id="717e0-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="717e0-294">根和中繼層級節點包含保存索引資料列的索引頁。</span><span class="sxs-lookup"><span data-stu-id="717e0-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="717e0-295">每個索引資料列都包含索引鍵值，以及指向 B 型樹狀目錄之中繼層級分頁或索引分葉層級之資料列的指標。</span><span class="sxs-lookup"><span data-stu-id="717e0-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="717e0-296">索引每個層級中的分頁都以雙向連結串列方式連結。</span><span class="sxs-lookup"><span data-stu-id="717e0-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="717e0-297">對於索引所使用的每個資料分割，叢集索引在 [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql)中都有一個 **index_id** = 1 的資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="717e0-298">根據預設，叢集索引只有一個資料分割。</span><span class="sxs-lookup"><span data-stu-id="717e0-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="717e0-299">當叢集索引有多個資料分割時，每個資料分割都有一個 B 型樹狀目錄結構來包含該特定資料分割的資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="717e0-300">例如，如果叢集索引有四個資料分割，則共有四個 B 型樹狀目錄結構，每個資料分割中各一個。</span><span class="sxs-lookup"><span data-stu-id="717e0-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="717e0-301">視叢集索引中的資料類型而定，每個叢集索引結構會有一個或多個配置單位來儲存並管理特定資料分割的資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="717e0-302">在每個叢集索引中，每個資料分割至少會有一個 IN_ROW_DATA 配置單位。</span><span class="sxs-lookup"><span data-stu-id="717e0-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="717e0-303">如果叢集索引包含大型物件 (LOB) 資料行，則在每個叢集索引中，每個資料分割也會一個 LOB_DATA 配置單位。</span><span class="sxs-lookup"><span data-stu-id="717e0-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="717e0-304">如果叢集索引包含可變長度資料行，而該資料行又超過 8,060 個位元組的資料列大小限制，則每個資料分割也會有一個 ROW_OVERFLOW_DATA 配置單位。</span><span class="sxs-lookup"><span data-stu-id="717e0-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="717e0-305">資料鏈結中的分頁，以及它們裡面的資料列將以叢集索引鍵的值來排列。</span><span class="sxs-lookup"><span data-stu-id="717e0-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="717e0-306">所有插入動作都會等到插入之資料列的索引鍵值符合它在現有資料列的排列順序時才發生。</span><span class="sxs-lookup"><span data-stu-id="717e0-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="717e0-307">下圖顯示單一資料分割中的叢集索引結構。</span><span class="sxs-lookup"><span data-stu-id="717e0-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="717e0-308">![叢集索引的層級](media/bokind2.gif "叢集索引的層級")</span><span class="sxs-lookup"><span data-stu-id="717e0-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="717e0-309">查詢注意事項</span><span class="sxs-lookup"><span data-stu-id="717e0-309">Query Considerations</span></span>  

 <span data-ttu-id="717e0-310">在建立叢集索引之前，必須先了解資料的存取方式。</span><span class="sxs-lookup"><span data-stu-id="717e0-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="717e0-311">執行下列情況的查詢請考慮使用叢集索引：</span><span class="sxs-lookup"><span data-stu-id="717e0-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="717e0-312">使用如 BETWEEN、>、>=、< 和 <= 等運算子來傳回值的範圍。</span><span class="sxs-lookup"><span data-stu-id="717e0-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="717e0-313">在使用叢集索引找到第一個值的資料列後，就可保證具有後續索引值的資料列是實體相鄰的。</span><span class="sxs-lookup"><span data-stu-id="717e0-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="717e0-314">例如，如果查詢會擷取介於某個銷售訂單編號範圍的記錄， `SalesOrderNumber` 資料行上的叢集索引就可以快速地找到包含起始銷售訂單編號的資料列，然後擷取資料表中所有連續資料列，直到達到最後一個銷售訂單編號為止。</span><span class="sxs-lookup"><span data-stu-id="717e0-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="717e0-315">傳回大型結果集。</span><span class="sxs-lookup"><span data-stu-id="717e0-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="717e0-316">使用 JOIN 子句；通常這些都是外部索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="717e0-317">使用 ORDER BY 或 GROUP BY 子句。</span><span class="sxs-lookup"><span data-stu-id="717e0-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="717e0-318">在 ORDER BY 或 GROUP BY 子句中指定的資料行之索引，可讓 [!INCLUDE[ssDE](../includes/ssde-md.md)] 不需排序資料，因為資料列已經排序過了。</span><span class="sxs-lookup"><span data-stu-id="717e0-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="717e0-319">這種方式可以提高查詢的執行效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="717e0-320">資料行注意事項</span><span class="sxs-lookup"><span data-stu-id="717e0-320">Column Considerations</span></span>  

 <span data-ttu-id="717e0-321">一般而言，您應該盡可能以較少的資料行來定義叢集索引鍵。</span><span class="sxs-lookup"><span data-stu-id="717e0-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="717e0-322">考慮具有下列一或多個屬性的資料行：</span><span class="sxs-lookup"><span data-stu-id="717e0-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="717e0-323">是唯一或包含許多不同的值</span><span class="sxs-lookup"><span data-stu-id="717e0-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="717e0-324">例如，員工識別碼可唯一識別員工。</span><span class="sxs-lookup"><span data-stu-id="717e0-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="717e0-325">在 `EmployeeID` 資料行上的叢集索引或 PRIMARY KEY 條件約束，將改善查詢的效能，可根據員工識別碼來搜尋員工資訊。</span><span class="sxs-lookup"><span data-stu-id="717e0-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="717e0-326">此外，也可以在 `LastName`、 `FirstName`、 `MiddleName` 上面建立叢集索引，因為員工記錄經常以此方式來群組和查詢，而這些資料行的組合仍可提供高度的差異性。</span><span class="sxs-lookup"><span data-stu-id="717e0-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="717e0-327">循序存取</span><span class="sxs-lookup"><span data-stu-id="717e0-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="717e0-328">例如，產品識別碼可唯一識別在 `Production.Product` 資料庫中的 [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] 資料表。</span><span class="sxs-lookup"><span data-stu-id="717e0-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="717e0-329">指定循序搜尋的查詢 (例如 `WHERE ProductID BETWEEN 980 and 999`) 將會從 `ProductID`上的叢集索引獲得好處。</span><span class="sxs-lookup"><span data-stu-id="717e0-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="717e0-330">這是因為資料列將根據該索引鍵資料行排序過。</span><span class="sxs-lookup"><span data-stu-id="717e0-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="717e0-331">定義為 IDENTITY。</span><span class="sxs-lookup"><span data-stu-id="717e0-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="717e0-332">經常使用以排序從資料表擷取的資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="717e0-333">最好能夠根據該資料行來叢集化 (即實際上的排序) 資料表，以省下每次在查詢資料行時都需進行排序的成本。</span><span class="sxs-lookup"><span data-stu-id="717e0-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="717e0-334">對下列屬性來說，叢集索引並不是理想的選擇：</span><span class="sxs-lookup"><span data-stu-id="717e0-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="717e0-335">變更頻繁的資料行</span><span class="sxs-lookup"><span data-stu-id="717e0-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="717e0-336">這會導致整個資料列移動，因為 [!INCLUDE[ssDE](../includes/ssde-md.md)] 必須以實體順序來保留資料列的資料值。</span><span class="sxs-lookup"><span data-stu-id="717e0-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="717e0-337">對於資料經常變動的龐大交易處理系統來說，這是一項很重要的考量。</span><span class="sxs-lookup"><span data-stu-id="717e0-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="717e0-338">寬索引鍵</span><span class="sxs-lookup"><span data-stu-id="717e0-338">Wide keys</span></span>  
  
     <span data-ttu-id="717e0-339">寬索引鍵是由數個資料行或是數個大型資料行所組成。</span><span class="sxs-lookup"><span data-stu-id="717e0-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="717e0-340">所有的非叢集索引都使用叢集索引的索引鍵值做為查閱索引鍵。</span><span class="sxs-lookup"><span data-stu-id="717e0-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="717e0-341">任何在相同資料表上所定義的非叢集索引將會非常大，因為非叢集索引項目包含叢集索引鍵，同時也包含在該非叢集索引上所定義的索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="717e0-342">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="717e0-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="717e0-343">非叢集索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="717e0-344">非叢集索引包含了索引鍵值和可指向資料表資料的儲存位置之資料列定位器。</span><span class="sxs-lookup"><span data-stu-id="717e0-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="717e0-345">您可以在資料表或索引檢視表上建立多個非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="717e0-346">一般而言，應該將非叢集索引設計成可增進常用查詢 (叢集索引未涵蓋的查詢) 的效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="717e0-347">如同您使用書中索引的方式一樣，查詢最佳化工具會先搜尋非叢集索引以找出資料值在資料表中的位置，然後再直接從該位置擷取資料，即可搜尋資料值。</span><span class="sxs-lookup"><span data-stu-id="717e0-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="717e0-348">這讓非叢集索引成為執行完全符合的查詢之最佳選擇，因為此種索引所包含的項目會描述查詢中所要搜尋的資料值在資料表中的確定位置。</span><span class="sxs-lookup"><span data-stu-id="717e0-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="717e0-349">例如，若要針對直屬特定經理的所有員工查詢 `HumanResources. Employee` 資料表，查詢最佳化工具可能使用非叢集索引 `IX_Employee_ManagerID`，而這個索引以 `ManagerID` 做為索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="717e0-350">查詢最佳化工具可以在索引中快速尋找符合指定之 `ManagerID`的所有項目。</span><span class="sxs-lookup"><span data-stu-id="717e0-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="717e0-351">每個索引項目會指向資料表中正確的頁面和資料列，或指向可以找到對應資料的叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="717e0-352">查詢最佳化工具在索引中找到所有項目之後，即可直接跳至正確的頁面和資料列以擷取資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="717e0-353">非叢集索引架構</span><span class="sxs-lookup"><span data-stu-id="717e0-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="717e0-354">非叢集索引擁有與叢集索引相同的 B 型樹狀目錄結構，不過有下列顯著的差異：</span><span class="sxs-lookup"><span data-stu-id="717e0-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="717e0-355">基礎資料表的資料列並未根據其非叢集索引鍵的順序，進行排序與儲存。</span><span class="sxs-lookup"><span data-stu-id="717e0-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="717e0-356">非叢集索引的分葉層是由索引頁 (而不是資料頁) 所組成。</span><span class="sxs-lookup"><span data-stu-id="717e0-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="717e0-357">非叢集索引資料列中的資料列定位器是資料列的指標，或資料列的叢集索引鍵，如下所述：</span><span class="sxs-lookup"><span data-stu-id="717e0-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="717e0-358">如果資料表為堆積 (表示沒有叢集索引)，則資料列定位器為資料列的指標。</span><span class="sxs-lookup"><span data-stu-id="717e0-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="717e0-359">該指標將以檔案識別碼 (識別碼)、頁碼與分頁中的資料列編號來建立。</span><span class="sxs-lookup"><span data-stu-id="717e0-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="717e0-360">整個指標也稱為資料列識別碼 (RID)。</span><span class="sxs-lookup"><span data-stu-id="717e0-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="717e0-361">如果資料表有叢集索引，或索引位於索引檢視中，則資料列定位器為資料列的叢集索引鍵。</span><span class="sxs-lookup"><span data-stu-id="717e0-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="717e0-362">對於索引所使用的每個資料分割，非叢集索引在 [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) 中都有一個 **index_id** >1 的資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="717e0-363">根據預設，非叢集索引只有一個資料分割。</span><span class="sxs-lookup"><span data-stu-id="717e0-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="717e0-364">當非叢集索引有多個資料分割時，每個資料分割都有一個 B 型樹狀目錄結構來包含該特定資料分割的索引資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="717e0-365">例如，如果非叢集索引有四個資料分割，則共有四個 B 型樹狀目錄結構，每個資料分割中各一個。</span><span class="sxs-lookup"><span data-stu-id="717e0-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="717e0-366">視非叢集索引中的資料類型而定，每個非叢集索引結構會有一個或多個配置單位來儲存並管理特定資料分割的資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="717e0-367">在每個非叢集索引中，每個資料分割至少會有一個 IN_ROW_DATA 配置單位來儲存索引 B 型樹狀目錄頁面。</span><span class="sxs-lookup"><span data-stu-id="717e0-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="717e0-368">如果非叢集索引包含大型物件 (LOB) 資料行，則在該非叢集索引中，每個資料分割也會有一個 LOB_DATA 配置單位。</span><span class="sxs-lookup"><span data-stu-id="717e0-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="717e0-369">此外，如果非叢集索引包含可變長度資料行，而該資料行又超過 8,060 個位元組的資料列大小限制，則每個資料分割也會有一個 ROW_OVERFLOW_DATA 配置單位。</span><span class="sxs-lookup"><span data-stu-id="717e0-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="717e0-370">下圖顯示單一資料分割中非叢集索引的結構。</span><span class="sxs-lookup"><span data-stu-id="717e0-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="717e0-371">![非叢集索引的層級](media/bokind1.gif "非叢集索引的層級")</span><span class="sxs-lookup"><span data-stu-id="717e0-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="717e0-372">資料庫考量</span><span class="sxs-lookup"><span data-stu-id="717e0-372">Database Considerations</span></span>  

 <span data-ttu-id="717e0-373">設計非叢集索引時，請考慮資料庫的特性。</span><span class="sxs-lookup"><span data-stu-id="717e0-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="717e0-374">更新需求較低但資料容量較大的資料庫或資料表，可以從許多非叢集索引中得到好處以增進查詢效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="717e0-375">請考慮針對定義完善的資料子集建立篩選的索引來提升查詢效能、降低索引儲存成本，並降低與完整資料表非叢集索引比較的索引維護成本。</span><span class="sxs-lookup"><span data-stu-id="717e0-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="717e0-376">包含主要唯讀資料的決策支援系統 (DSS) 應用程式和資料庫，可以從許多非叢集索引中得到好處。</span><span class="sxs-lookup"><span data-stu-id="717e0-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="717e0-377">查詢最佳化工具有較多可供選擇的索引，因此可判斷最快的存取方法，而資料庫的低更新特性則表示索引維護不會降低效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="717e0-378">包含大量已更新資料表的線上交易處理應用程式和資料庫應避免重複進行索引作業。</span><span class="sxs-lookup"><span data-stu-id="717e0-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="717e0-379">此外，應該縮小索引的範圍，這表示應盡可能包含較少的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="717e0-380">資料表中的索引數量過多會影響到 INSERT、UPDATE、DELETE 和 MERGE 陳述式的效能，因為只要資料表中的資料一變更，所有的索引也都必須隨著調整。</span><span class="sxs-lookup"><span data-stu-id="717e0-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="717e0-381">查詢注意事項</span><span class="sxs-lookup"><span data-stu-id="717e0-381">Query Considerations</span></span>  

 <span data-ttu-id="717e0-382">建立非叢集索引之前，應該先了解資料的存取方式。</span><span class="sxs-lookup"><span data-stu-id="717e0-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="717e0-383">請考慮針對具有下列屬性的查詢使用非叢集索引：</span><span class="sxs-lookup"><span data-stu-id="717e0-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="717e0-384">使用 JOIN 或 GROUP BY 子句。</span><span class="sxs-lookup"><span data-stu-id="717e0-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="717e0-385">依據聯結和群組操作中用到的資料行，建立多個非叢集索引，並依據外部索引鍵資料行建立一個叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="717e0-386">不會傳回大量結果集的查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="717e0-387">建立篩選的索引，以涵蓋從大型資料表傳回定義完善之資料列子集的查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="717e0-388">包含會傳回完全相符項目的查詢 (例如 WHERE 子句) 中，所設定的搜尋條件常會用到的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="717e0-389">資料行注意事項</span><span class="sxs-lookup"><span data-stu-id="717e0-389">Column Considerations</span></span>  

 <span data-ttu-id="717e0-390">考慮具有一或多個下列屬性的資料行：</span><span class="sxs-lookup"><span data-stu-id="717e0-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="717e0-391">涵蓋查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-391">Cover the query.</span></span>  
  
     <span data-ttu-id="717e0-392">當索引包含查詢中的所有資料行時，將可改善效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="717e0-393">查詢最佳化工具可以在索引中尋找所有資料行值；未被存取的資料表或叢集索引資料會導致磁碟 I/O 作業減少。</span><span class="sxs-lookup"><span data-stu-id="717e0-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="717e0-394">使用內含資料行索引來新增涵蓋的資料行，而非建立廣泛的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="717e0-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="717e0-395">如果資料表中具有叢集索引，則在叢集索引中定義的資料行會自動附加到資料表上每個非叢集索引的結尾。</span><span class="sxs-lookup"><span data-stu-id="717e0-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="717e0-396">這樣會產生涵蓋的查詢，而不需要在非叢集索引的定義中指定叢集索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="717e0-397">例如，如果資料表在資料行 `C`上具有叢集索引，而在資料行 `B` 和 `A` 上具有非叢集索引，則其索引鍵值資料行為 `B`、 `A`和 `C`。</span><span class="sxs-lookup"><span data-stu-id="717e0-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="717e0-398">許多不同值的資料行，例如姓氏與名字的組合 (如果其他資料行使用叢集索引的話)。</span><span class="sxs-lookup"><span data-stu-id="717e0-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="717e0-399">如果只有很少量的不同值 (例如只有 1 和 0)，則大多數的查詢都不會使用索引，因為資料表掃描通常會更有效率。</span><span class="sxs-lookup"><span data-stu-id="717e0-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="717e0-400">如果是這種資料類型，請考慮針對只發生於少量資料列的相異值建立篩選的索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="717e0-401">例如，如果大多數的值為 0，則查詢最佳化工具可能會將篩選的索引用於包含 1 的資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="717e0-402">使用內含資料行擴充非叢集索引</span><span class="sxs-lookup"><span data-stu-id="717e0-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="717e0-403">您可以加入非索引鍵資料行至非叢集索引的分葉層級，以擴充非叢集索引的功能。</span><span class="sxs-lookup"><span data-stu-id="717e0-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="717e0-404">藉由加入非索引鍵資料行，您可以建立涵蓋更多查詢的非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="717e0-405">這是因為非索引鍵之索引資料行有下列好處：</span><span class="sxs-lookup"><span data-stu-id="717e0-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="717e0-406">與索引鍵資料行一樣，它們可以是不允許的資料類型。</span><span class="sxs-lookup"><span data-stu-id="717e0-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="717e0-407">計算索引鍵資料行數或索引鍵大小時， [!INCLUDE[ssDE](../includes/ssde-md.md)] 不會考慮它們。</span><span class="sxs-lookup"><span data-stu-id="717e0-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="717e0-408">查詢中所有的資料行在索引中當做索引鍵或非索引鍵之索引資料行時，內含非索引鍵之索引資料行索引可以大幅改進查詢效能。</span><span class="sxs-lookup"><span data-stu-id="717e0-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="717e0-409">因為查詢最佳化工具可以在索引中找到所有資料行值，所以可以提高效能；不存取資料表或叢集索引資料，導致磁碟 I/O 作業變少。</span><span class="sxs-lookup"><span data-stu-id="717e0-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="717e0-410">索引包含查詢參考的所有資料行時，通常就是指涵蓋查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="717e0-411">索引鍵資料行儲存在索引的所有分葉層級上，而非索引鍵之索引資料行僅儲存在分葉層級上。</span><span class="sxs-lookup"><span data-stu-id="717e0-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="717e0-412">使用內含資料行避開大小限制</span><span class="sxs-lookup"><span data-stu-id="717e0-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="717e0-413">您可以在非叢集索引中包含非索引鍵之索引資料行，以避免超出目前索引大小限制 (最大 16 個索引鍵資料行，最大 900 個位元組索引鍵大小)</span><span class="sxs-lookup"><span data-stu-id="717e0-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="717e0-414">計算索引鍵資料行數或索引鍵大小時， [!INCLUDE[ssDE](../includes/ssde-md.md)] 不會考慮非索引鍵之索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="717e0-415">例如，假設您想要在 `Document` 資料表中建立下列資料行的索引：</span><span class="sxs-lookup"><span data-stu-id="717e0-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="717e0-416">由於 `nchar` 和 `nvarchar` 資料類型的每個字元都需要 2 個位元組，因此包含這三個資料行的索引可能會比 900 個位元組的大小限制多出 10 個位元組 (455 \* 2)。</span><span class="sxs-lookup"><span data-stu-id="717e0-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="717e0-417">使用 `INCLUDE` 陳述式的 `CREATE INDEX` 子句，索引鍵可定義為 (`Title, Revision`)，而 `FileName` 則定義為非索引鍵之索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="717e0-418">這樣，索引鍵大小會是 110 個位元組 (55 \* 2)，且索引仍能包含所有必須的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="717e0-419">下列陳述式會建立這類索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="717e0-420">內含資料行索引指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="717e0-421">設計具有內含資料行的非叢集索引時，請考慮下列指導方針：</span><span class="sxs-lookup"><span data-stu-id="717e0-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="717e0-422">非索引鍵之索引資料行是定義於 CREATE INDEX 陳述式的 INCLUDE 子句。</span><span class="sxs-lookup"><span data-stu-id="717e0-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="717e0-423">非索引鍵之索引資料行僅能定義於資料表或索引檢視的非叢集索引上。</span><span class="sxs-lookup"><span data-stu-id="717e0-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="717e0-424">允許所有資料類型，但不包括 `text`、`ntext` 和 `image`。</span><span class="sxs-lookup"><span data-stu-id="717e0-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="717e0-425">具決定性之精確或非精確的計算資料行都可以當做內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="717e0-426">如需詳細資訊，請參閱 [計算資料行的索引](../relational-databases/indexes/indexes-on-computed-columns.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="717e0-427">如同索引鍵資料行，只要計算資料行資料類型可以作為無索引鍵索引資料行，則從 `image`、`ntext` 與 `text` 衍生的計算資料行即可以是非索引鍵之索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="717e0-428">資料行名稱無法同時指定於 INCLUDE 清單與索引鍵資料行清單兩者中。</span><span class="sxs-lookup"><span data-stu-id="717e0-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="717e0-429">資料行名稱在 INCLUDE 清單中不得重複。</span><span class="sxs-lookup"><span data-stu-id="717e0-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="717e0-430">資料行大小指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="717e0-431">至少必須定義一個索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-431">At least one key column must be defined.</span></span> <span data-ttu-id="717e0-432">非索引鍵之索引資料行數目的上限為 1023 個資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="717e0-433">這是資料表資料行數目的上限減 1。</span><span class="sxs-lookup"><span data-stu-id="717e0-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="717e0-434">索引鍵資料行 (不包含非索引鍵之索引資料行) 必須遵守現有索引大小的限制 (上限為 16 個索引鍵資料行)，且索引鍵總大小為 900 個位元組。</span><span class="sxs-lookup"><span data-stu-id="717e0-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="717e0-435">所有非索引鍵之索引資料行大小總計僅由 INCLUDE 子句中指定的資料行大小限定；例如，`varchar(max)` 資料行是限定為 2 GB。</span><span class="sxs-lookup"><span data-stu-id="717e0-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="717e0-436">資料行修改指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="717e0-437">當您修改定義為內含資料行的資料表資料行時，則下列限制適用：</span><span class="sxs-lookup"><span data-stu-id="717e0-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="717e0-438">必須先卸除索引，才能從資料表卸除非索引鍵之索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="717e0-439">除非執行下列動作，否則無法變更非索引鍵之索引資料行：</span><span class="sxs-lookup"><span data-stu-id="717e0-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="717e0-440">將資料行的 Null 屬性從 NOT NULL 變更為 NULL。</span><span class="sxs-lookup"><span data-stu-id="717e0-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="717e0-441">增加 `varchar`、`nvarchar` 或 `varbinary` 資料行的長度。</span><span class="sxs-lookup"><span data-stu-id="717e0-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="717e0-442">這些資料行修改限制也適用索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="717e0-443">設計建議</span><span class="sxs-lookup"><span data-stu-id="717e0-443">Design Recommendations</span></span>  

 <span data-ttu-id="717e0-444">重新設計具有大型索引鍵大小的非叢集索引，如此僅有用於搜尋與查閱的資料行才會是索引鍵資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="717e0-445">讓涵蓋查詢的所有其他資料行都作為內含非索引鍵之索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="717e0-446">如此一來，您將擁有涵蓋查詢所需的所有資料行，但是索引鍵本身會變得很小而且很有效率。</span><span class="sxs-lookup"><span data-stu-id="717e0-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="717e0-447">例如，假設您要設計能夠涵蓋下列查詢的索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="717e0-448">若要涵蓋查詢，必須在索引中定義每個資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="717e0-449">雖然您可以將所有資料行定義為索引鍵資料行，但是索引鍵大小應是 334 個位元組。</span><span class="sxs-lookup"><span data-stu-id="717e0-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="717e0-450">由於只有實際作為搜尋條件的資料行才是 `PostalCode` 資料行，且長度為 30 個位元組，所以較佳的索引設計方式應該是將 `PostalCode` 定義為索引鍵資料行，並將所有其他的資料行作為非索引鍵之索引資料行包含在內。</span><span class="sxs-lookup"><span data-stu-id="717e0-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="717e0-451">下列陳述式會建立具有內含資料行的索引，可以涵蓋查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="717e0-452">效能考量</span><span class="sxs-lookup"><span data-stu-id="717e0-452">Performance Considerations</span></span>  

 <span data-ttu-id="717e0-453">避免加入不必要的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="717e0-454">加入過多的索引資料行、索引鍵或無索引鍵，可能會發生以下的效能問題：</span><span class="sxs-lookup"><span data-stu-id="717e0-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="717e0-455">頁面上可以放入的索引資料列變少。</span><span class="sxs-lookup"><span data-stu-id="717e0-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="717e0-456">這將使得 I/O 的作業增加而降低快取的效率。</span><span class="sxs-lookup"><span data-stu-id="717e0-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="717e0-457">必須有更多磁碟空間才能儲存索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="717e0-458">尤其是，加入 `varchar(max)`、`nvarchar(max)`、`varbinary(max)` 或 `xml` 資料類型作為非索引鍵之索引資料行，將大幅增加磁碟空間的需求。</span><span class="sxs-lookup"><span data-stu-id="717e0-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="717e0-459">這是因為資料行的值複製到索引的分葉層級。</span><span class="sxs-lookup"><span data-stu-id="717e0-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="717e0-460">因此，它們會同時存在於索引與基底資料表中。</span><span class="sxs-lookup"><span data-stu-id="717e0-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="717e0-461">維護索引時，會增加修改、插入、更新或刪除基礎資料表或索引檢視的時間。</span><span class="sxs-lookup"><span data-stu-id="717e0-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="717e0-462">您必須決定，提高查詢效能，與修改資料時對效能的影響和需要額外磁碟空間，兩者熟輕熟重。</span><span class="sxs-lookup"><span data-stu-id="717e0-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="717e0-463">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="717e0-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="717e0-464">唯一索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="717e0-465">唯一索引可保證索引鍵不包含重複值，因此資料表中的每一個資料列在某方面來說是唯一的。</span><span class="sxs-lookup"><span data-stu-id="717e0-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="717e0-466">只有當資料具有唯一的特性時，指定唯一索引才有意義。</span><span class="sxs-lookup"><span data-stu-id="717e0-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="717e0-467">例如，若要確定 `NationalIDNumber` 資料表中 `HumanResources.Employee` 資料行的值是唯一的，則當主索引鍵是 `EmployeeID`時，請在 `NationalIDNumber` 資料行上建立 UNIQUE 條件約束。</span><span class="sxs-lookup"><span data-stu-id="717e0-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="717e0-468">如果使用者試著在該資料行上為不止一位員工輸入相同值，便會顯示錯誤訊息，而且無法輸入重複值。</span><span class="sxs-lookup"><span data-stu-id="717e0-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="717e0-469">利用多重資料行唯一索引，此索引可保證索引鍵的每一個值組合都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="717e0-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="717e0-470">例如，若在 `LastName`、 `FirstName`和 `MiddleName` 資料行的組合上建立唯一索引，則該資料表中不得有兩個資料列具有這些資料行的相同值組合。</span><span class="sxs-lookup"><span data-stu-id="717e0-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="717e0-471">叢集與非叢集索引都可以是唯一的。</span><span class="sxs-lookup"><span data-stu-id="717e0-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="717e0-472">假設資料行中的資料是唯一的，您就可以在同一個資料表上建立一個唯一的叢集索引和多個唯一的非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="717e0-473">唯一索引的好處包括：</span><span class="sxs-lookup"><span data-stu-id="717e0-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="717e0-474">確保所定義之資料行的資料完整性。</span><span class="sxs-lookup"><span data-stu-id="717e0-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="717e0-475">提供對查詢最佳化工具有幫助的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="717e0-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="717e0-476">建立 PRIMARY KEY 或 UNIQUE 條件約束時，會自動在指定的資料行上建立唯一索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="717e0-477">建立 UNIQUE 條件約束和不使用條件約束而建立唯一索引，兩者之間並沒有顯著的差異。</span><span class="sxs-lookup"><span data-stu-id="717e0-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="717e0-478">資料驗證的方式相同，且查詢最佳化工具不會區分唯一索引是由條件約束所建立還是手動建立的。</span><span class="sxs-lookup"><span data-stu-id="717e0-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="717e0-479">不過，當您的目標是資料完整性時，就應該在資料行上建立 UNIQUE 或 PRIMARY KEY 條件約束。</span><span class="sxs-lookup"><span data-stu-id="717e0-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="717e0-480">如此一來，索引的目標就很明確。</span><span class="sxs-lookup"><span data-stu-id="717e0-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="717e0-481">考量</span><span class="sxs-lookup"><span data-stu-id="717e0-481">Considerations</span></span>  
  
-   <span data-ttu-id="717e0-482">如果資料中已存在重複的索引鍵值，則無法建立唯一索引、UNIQUE 條件約束或 PRIMARY KEY 條件約束。</span><span class="sxs-lookup"><span data-stu-id="717e0-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="717e0-483">如果資料是唯一的，而且您想要強制唯一性，則在相同資料行組合上建立唯一索引而不是非唯一索引，可提供其他資訊給查詢最佳化工具，來產生更有效率的執行計畫。</span><span class="sxs-lookup"><span data-stu-id="717e0-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="717e0-484">在這種情況下，建議您建立唯一索引 (而且最好先經由建立 UNIQUE 條件約束)。</span><span class="sxs-lookup"><span data-stu-id="717e0-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="717e0-485">唯一非叢集索引可有內含的非索引鍵之索引資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="717e0-486">如需詳細資訊，請參閱 [內含資料行的索引](#Included_Columns)。</span><span class="sxs-lookup"><span data-stu-id="717e0-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="717e0-487">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="717e0-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="717e0-488">篩選索引設計指導方針</span><span class="sxs-lookup"><span data-stu-id="717e0-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="717e0-489">篩選索引是最佳化的非叢集索引，特別適合用來處理會從定義完善之資料子集進行選取的查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="717e0-490">篩選索引會使用篩選述詞對資料表中的部分資料列進行索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="717e0-491">與完整資料表索引相較，設計良好的篩選索引可以提升查詢效能、降低索引維護成本，並降低索引儲存成本。</span><span class="sxs-lookup"><span data-stu-id="717e0-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="717e0-492">**適用於**： [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 至 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="717e0-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="717e0-493">篩選索引可以提供全資料表索引所不及的下列優勢：</span><span class="sxs-lookup"><span data-stu-id="717e0-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="717e0-494">**提升的查詢效能和計畫品質**</span><span class="sxs-lookup"><span data-stu-id="717e0-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="717e0-495">設計良好的篩選索引可以提升查詢效能和執行計畫品質，因為它比全資料表的非叢集索引來得小，且具有篩選統計資料。</span><span class="sxs-lookup"><span data-stu-id="717e0-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="717e0-496">篩選統計資料比全資料表統計資料更為正確，因為僅涵蓋篩選索引中的資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="717e0-497">**降低的索引維護成本**</span><span class="sxs-lookup"><span data-stu-id="717e0-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="717e0-498">只有在資料操作語言 (DML) 陳述式影響到索引中的資料時，才會對索引進行維護。</span><span class="sxs-lookup"><span data-stu-id="717e0-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="717e0-499">與全資料表的非叢集索引相較，篩選索引可以降低維護成本，因為後者較小且僅會在索引中的資料受到影響時才會進行維護。</span><span class="sxs-lookup"><span data-stu-id="717e0-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="717e0-500">篩選索引的數量可能很多，特別是當其包含不常受到影響的資料時。</span><span class="sxs-lookup"><span data-stu-id="717e0-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="717e0-501">同樣地，如果篩選索引僅包含經常受到影響的資料，則因為索引的大小較小，更新統計資料的成本就會下降。</span><span class="sxs-lookup"><span data-stu-id="717e0-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="717e0-502">**降低的索引儲存成本**</span><span class="sxs-lookup"><span data-stu-id="717e0-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="717e0-503">在不需要全資料表索引時，建立篩選索引可以縮減非叢集索引的磁碟儲存量。</span><span class="sxs-lookup"><span data-stu-id="717e0-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="717e0-504">您可以使用多個篩選索引來取代全資料表的非叢集索引，而不會大幅增加儲存需求。</span><span class="sxs-lookup"><span data-stu-id="717e0-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="717e0-505">當資料行包含定義良好的資料子集且查詢在 SELECT 陳述式中會參考這些資料時，篩選索引很有用。</span><span class="sxs-lookup"><span data-stu-id="717e0-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="717e0-506">範例包括：</span><span class="sxs-lookup"><span data-stu-id="717e0-506">Examples are:</span></span>  
  
-   <span data-ttu-id="717e0-507">僅包含一些非 NULL 值的疏鬆資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="717e0-508">包含資料類別的異質資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="717e0-509">包含金額、時間和日期等值範圍的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="717e0-510">由資料行值的簡單比較邏輯所定義的資料表資料分割。</span><span class="sxs-lookup"><span data-stu-id="717e0-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="717e0-511">當索引中的資料列數與全資料表索引相較比較小時，篩選索引降低的維護成本最明顯。</span><span class="sxs-lookup"><span data-stu-id="717e0-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="717e0-512">如果篩選索引包含資料表中大部分的資料列，則其維護成本可能要比全資料表索引高。</span><span class="sxs-lookup"><span data-stu-id="717e0-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="717e0-513">在此種情況下應該使用全資料表索引，而不是篩選索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="717e0-514">篩選索引定義於單一資料表，僅支援簡單比較運算子。</span><span class="sxs-lookup"><span data-stu-id="717e0-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="717e0-515">如果需要參考多個資料表或具有複雜邏輯的篩選運算式，則應該建立檢視。</span><span class="sxs-lookup"><span data-stu-id="717e0-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="717e0-516">設計考量</span><span class="sxs-lookup"><span data-stu-id="717e0-516">Design Considerations</span></span>  

 <span data-ttu-id="717e0-517">為了設計有效的篩選索引，必須了解應用程式所使用的查詢以及這些查詢與資料子集的關聯。</span><span class="sxs-lookup"><span data-stu-id="717e0-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="717e0-518">具有定義良好之子集的資料範例包括大部分的值都是 NULL 的資料行、具有異質值類別的資料行，以及具有相異值範圍的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="717e0-519">下列的設計考量提供多種案例，說明何時篩選索引的優點多於全資料表索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="717e0-520">資料子集的篩選索引</span><span class="sxs-lookup"><span data-stu-id="717e0-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="717e0-521">當資料行僅具有少數的查詢相關值時，可以在值的子集上建立篩選索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="717e0-522">例如，當資料行中的值大部分都是 NULL 且查詢只會從非 NULL 值進行選取時，您可以針對非 NULL 的資料列建立篩選索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="717e0-523">所產生的索引比在相同的索引鍵資料行上定義的全資料表非叢集索引還小，維護成本也比較低。</span><span class="sxs-lookup"><span data-stu-id="717e0-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="717e0-524">例如， `AdventureWorks2012` 資料庫具有 2679 個資料列的 `Production.BillOfMaterials` 資料表。</span><span class="sxs-lookup"><span data-stu-id="717e0-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="717e0-525">`EndDate` 資料行只有 199 個包含非 NULL 值的資料列，其他的 2480 個資料列都是包含 NULL。</span><span class="sxs-lookup"><span data-stu-id="717e0-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="717e0-526">下列篩選索引所包含的查詢會傳回在索引中定義的資料行，並僅會選取 `EndDate`使用非 NULL 值的資料列。</span><span class="sxs-lookup"><span data-stu-id="717e0-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="717e0-527">篩選索引 `FIBillOfMaterialsWithEndDate` 對下列查詢有效。</span><span class="sxs-lookup"><span data-stu-id="717e0-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="717e0-528">您可以顯示查詢執行計畫，以判斷查詢最佳化工具是否使用了篩選索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="717e0-529">如需有關如何建立篩選索引以及如何定義篩選索引述詞運算式的詳細資訊，請參閱 [建立篩選的索引](../relational-databases/indexes/create-filtered-indexes.md)。</span><span class="sxs-lookup"><span data-stu-id="717e0-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="717e0-530">異質資料的篩選索引</span><span class="sxs-lookup"><span data-stu-id="717e0-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="717e0-531">當資料表具有異質資料列時，您可以針對一或多個資料類別建立篩選索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="717e0-532">例如，列於 `Production.Product` 資料表中的每個產品都會被指派 `ProductSubcategoryID`，此 ID 又會與產品類別 Bikes、Components、Clothing 或 Accessories 等產生關聯。</span><span class="sxs-lookup"><span data-stu-id="717e0-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="717e0-533">這些類別都是異質性的，因為它們在 `Production.Product` 資料表中的資料行值並沒有緊密關聯。</span><span class="sxs-lookup"><span data-stu-id="717e0-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="717e0-534">例如，對個別產品類別來說， `Color`、 `ReorderPoint`、 `ListPrice`、 `Weight`、 `Class`和 `Style` 等資料行都有其唯一的特性。</span><span class="sxs-lookup"><span data-stu-id="717e0-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="717e0-535">假設經常對具有介於 27 到 36 (含) 之子類別的配件進行查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="717e0-536">您只要在配件子類別上建立篩選索引，就可以改善查詢該配件的效能，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="717e0-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="717e0-537">篩選索引 `FIProductAccessories` 適用於下列查詢，因為查詢</span><span class="sxs-lookup"><span data-stu-id="717e0-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="717e0-538">結果會包含在索引中，而且查詢計畫不包含基底資料表查閱。</span><span class="sxs-lookup"><span data-stu-id="717e0-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="717e0-539">例如，查詢述詞運算式 `ProductSubcategoryID = 33` 是篩選之索引述詞 `ProductSubcategoryID >= 27` 的子集，而且查詢述詞中的 `ProductSubcategoryID <= 36`、 `ProductSubcategoryID` 與 `ListPrice` 資料行都是索引中的索引鍵資料行，因此會將名稱當做包含的資料行，儲存在索引的分葉層級中。</span><span class="sxs-lookup"><span data-stu-id="717e0-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="717e0-540">索引鍵資料行</span><span class="sxs-lookup"><span data-stu-id="717e0-540">Key Columns</span></span>  

 <span data-ttu-id="717e0-541">最佳作法是在篩選索引定義中包含少數的索引鍵或內含資料行，並僅併入查詢最佳化工具在選擇查詢執行計畫的篩選索引時必要的資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="717e0-542">查詢最佳化工具可以選擇查詢的篩選索引，不論它是否涵蓋該查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="717e0-543">然而，查詢最佳化工具如果涵蓋該查詢，則更可能選擇篩選索引。</span><span class="sxs-lookup"><span data-stu-id="717e0-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="717e0-544">在某些情況下，篩選索引會涵蓋查詢，而不需將資料行以篩選索引定義中的索引鍵或內含資料行方式包含在篩選索引運算式中。</span><span class="sxs-lookup"><span data-stu-id="717e0-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="717e0-545">下列指導方針說明篩選索引運算式中的資料行何時應該是篩選索引定義中的索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="717e0-546">其中的範例會參考先前所建立的篩選索引 `FIBillOfMaterialsWithEndDate` 。</span><span class="sxs-lookup"><span data-stu-id="717e0-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="717e0-547">如果篩選索引運算式相等於查詢述詞，且查詢並未以篩選索引運算式中的資料行傳回查詢結果，則篩選索引運算式中的資料行不需要是篩選索引定義中的索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="717e0-548">例如， `FIBillOfMaterialsWithEndDate` 包含下列查詢，因為查詢述詞相當於篩選運算式，且查詢結果未傳回 `EndDate` 。</span><span class="sxs-lookup"><span data-stu-id="717e0-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="717e0-549">`FIBillOfMaterialsWithEndDate` 不需要在篩選的索引定義中以 `EndDate` 作為索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="717e0-550">如果查詢述詞在不等於篩選索引運算式的比較中使用篩選索引運算式中的資料行，則該資料行應該是篩選索引定義中的索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="717e0-551">例如， `FIBillOfMaterialsWithEndDate` 對下列查詢有效，因為它會從篩選索引選取資料列子集。</span><span class="sxs-lookup"><span data-stu-id="717e0-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="717e0-552">不過，它並不會涵蓋下列查詢，因為 `EndDate` 會用於比較 `EndDate > '20040101'`中，而後者並不相等於篩選索引運算式。</span><span class="sxs-lookup"><span data-stu-id="717e0-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="717e0-553">在未先查閱 `EndDate`的值之前，查詢處理器無法執行此查詢。</span><span class="sxs-lookup"><span data-stu-id="717e0-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="717e0-554">因此， `EndDate` 應該是篩選索引定義中的索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="717e0-555">如果篩選索引運算式中的資料行在查詢結果集中，則該資料行應該是篩選索引定義中的索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="717e0-556">例如， `FIBillOfMaterialsWithEndDate` 並不涵蓋下列查詢，因為它會在查詢結果中傳回 `EndDate` 資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="717e0-557">因此， `EndDate` 應該是篩選索引定義中的索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="717e0-558">資料表的叢集索引鍵並不需要是篩選索引定義中的索引鍵或內含資料行。</span><span class="sxs-lookup"><span data-stu-id="717e0-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="717e0-559">叢集索引鍵會自動包含在所有非叢集的索引中 (包含篩選索引在內)。</span><span class="sxs-lookup"><span data-stu-id="717e0-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="717e0-560">篩選述詞中的資料轉換運算子</span><span class="sxs-lookup"><span data-stu-id="717e0-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="717e0-561">如果在篩選索引的篩選索引運算式中指定的比較運算子產生隱含或明確的資料轉換，則如果該轉換是發生在比較運算子的左側，就會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="717e0-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="717e0-562">解決方案是以資料轉換運算子 (CAST 或 CONVERT) 在比較運算子的右側寫下篩選索引運算式。</span><span class="sxs-lookup"><span data-stu-id="717e0-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="717e0-563">下列範例會建立具有多種資料類型的資料表。</span><span class="sxs-lookup"><span data-stu-id="717e0-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="717e0-564">在下列篩選索引定義中，資料行 `b` 會隱含地轉換成整數資料類型，以與常數 1 進行比較。</span><span class="sxs-lookup"><span data-stu-id="717e0-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="717e0-565">這麼做會產生錯誤訊息 10611，因為轉換發生在篩選述詞中運算子的左側。</span><span class="sxs-lookup"><span data-stu-id="717e0-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="717e0-566">解決方案是將右側的常數轉譯為與資料行 `b`相同的類型，如下列範例中所示：</span><span class="sxs-lookup"><span data-stu-id="717e0-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="717e0-567">將資料轉換從比較運算子的左側移至右側可能會變更轉換的意義。</span><span class="sxs-lookup"><span data-stu-id="717e0-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="717e0-568">在上述範例中，當 CONVERT 運算子新增至右側時，比較作業會從整數比較變更為 `varbinary` 比較。</span><span class="sxs-lookup"><span data-stu-id="717e0-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="717e0-569">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="717e0-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="717e0-570">其他閱讀資料</span><span class="sxs-lookup"><span data-stu-id="717e0-570">Additional Reading</span></span>  

 <span data-ttu-id="717e0-571">[＜使用 SQL Server 2008 索引檢視提升效能＞](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="717e0-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="717e0-572">分割資料表與索引</span><span class="sxs-lookup"><span data-stu-id="717e0-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  
