---
title: SQL Server 交易鎖定與資料列版本設定指南 | Microsoft Docs
ms.custom: ''
ms.date: 01/24/2019
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: c7757153-9697-4f01-881c-800e254918c9
author: rothja
ms.author: jroth
ms.openlocfilehash: c79f9997249568c88409394441d28c71da453d63
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87592404"
---
# <a name="sql-server-transaction-locking-and-row-versioning-guide"></a><span data-ttu-id="6c498-102">SQL Server 交易鎖定與資料列版本設定指南</span><span class="sxs-lookup"><span data-stu-id="6c498-102">SQL Server Transaction Locking and Row Versioning Guide</span></span>

  <span data-ttu-id="6c498-103">任何資料庫若交易管理不當，時常會導致多使用者的系統發生競爭與效能問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-103">In any database, mismanagement of transactions often leads to contention and performance problems in systems that have many users.</span></span> <span data-ttu-id="6c498-104">隨著存取資料的使用者數量增加，能夠有效使用交易的應用程式更形重要。</span><span class="sxs-lookup"><span data-stu-id="6c498-104">As the number of users that access the data increases, it becomes important to have applications that use transactions efficiently.</span></span> <span data-ttu-id="6c498-105">本指南描述 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 用以確保每筆交易實體完整性的鎖定及資料列版本設定機制，並提供有關應用程式如何能夠有效控制交易的資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-105">This guide describes the locking and row versioning mechanisms the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses to ensure the physical integrity of each transaction and provides information on how applications can control transactions efficiently.</span></span>  
  
<span data-ttu-id="6c498-106">**適用于**： [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] 至，除非另有 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 說明。</span><span class="sxs-lookup"><span data-stu-id="6c498-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="6c498-107">本指南</span><span class="sxs-lookup"><span data-stu-id="6c498-107">In This Guide</span></span>  

 [<span data-ttu-id="6c498-108">交易基本概念</span><span class="sxs-lookup"><span data-stu-id="6c498-108">Transaction Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="6c498-109">鎖定和資料列版本設定基本概念</span><span class="sxs-lookup"><span data-stu-id="6c498-109">Locking and Row Versioning Basics</span></span>](#Lock_Basics)  
  
 [<span data-ttu-id="6c498-110">資料庫引擎中的鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-110">Locking in the Database Engine</span></span>](#Lock_Engine)  
  
 [<span data-ttu-id="6c498-111">Database Engine 中資料列版本設定式的隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-111">Row Versioning-based Isolation Levels in the Database Engine</span></span>](#Row_versioning)  
  
 [<span data-ttu-id="6c498-112">自訂索引的鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-112">Customizing Locking for an Index</span></span>](#Customize)  
  
 [<span data-ttu-id="6c498-113">先進的交易資訊</span><span class="sxs-lookup"><span data-stu-id="6c498-113">Advanced Transaction Information</span></span>](#Advanced)  
  
##  <a name="transaction-basics"></a><a name="Basics"></a> <span data-ttu-id="6c498-114">交易基本概念</span><span class="sxs-lookup"><span data-stu-id="6c498-114">Transaction Basics</span></span>  

 <span data-ttu-id="6c498-115">交易就是以單一工作邏輯單元執行的一連串作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-115">A transaction is a sequence of operations performed as a single logical unit of work.</span></span> <span data-ttu-id="6c498-116">工作邏輯單元必須呈現出四種屬性，即不可部份完成性 (Atomicity)、一致性 (Consistency)、隔離性 (Isolation) 與耐久性 (Durability) 屬性，稱為 ACID，才能有資格成為一筆交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-116">A logical unit of work must exhibit four properties, called the atomicity, consistency, isolation, and durability (ACID) properties, to qualify as a transaction.</span></span>  
  
 <span data-ttu-id="6c498-117">不可部份完成性</span><span class="sxs-lookup"><span data-stu-id="6c498-117">Atomicity</span></span>  
 <span data-ttu-id="6c498-118">交易必須是不可部分完成 (Atomic) 的工作單位；資料的修改若非全部執行，就是全部不執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-118">A transaction must be an atomic unit of work; either all of its data modifications are performed, or none of them are performed.</span></span>  
  
 <span data-ttu-id="6c498-119">一致性</span><span class="sxs-lookup"><span data-stu-id="6c498-119">Consistency</span></span>  
 <span data-ttu-id="6c498-120">交易完成時，所有資料必須維持一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-120">When completed, a transaction must leave all data in a consistent state.</span></span> <span data-ttu-id="6c498-121">在關聯式資料庫 (Relational Database) 中，必須將所有的規則 (Rule) 套用於交易的修改，以維護所有的資料整合性 (Integrity)。</span><span class="sxs-lookup"><span data-stu-id="6c498-121">In a relational database, all rules must be applied to the transaction's modifications to maintain all data integrity.</span></span> <span data-ttu-id="6c498-122">所有的內部資料結構，例如 B 型樹狀結構索引 (B-tree Index) 或是雙向連結串列 (Doubly-Linked List)，在交易終止時必須是正確的。</span><span class="sxs-lookup"><span data-stu-id="6c498-122">All internal data structures, such as B-tree indexes or doubly-linked lists, must be correct at the end of the transaction.</span></span>  
  
 <span data-ttu-id="6c498-123">隔離</span><span class="sxs-lookup"><span data-stu-id="6c498-123">Isolation</span></span>  
 <span data-ttu-id="6c498-124">並行交易所做的修改，必須與任何其他並行交易所做的修改隔離。</span><span class="sxs-lookup"><span data-stu-id="6c498-124">Modifications made by concurrent transactions must be isolated from the modifications made by any other concurrent transactions.</span></span> <span data-ttu-id="6c498-125">交易所辨識的資料不是處於另一筆並行的交易修改資料之前的狀態，就是處於第二筆交易完成後的狀態，但是卻無法辨識中繼狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-125">A transaction either recognizes data in the state it was in before another concurrent transaction modified it, or it recognizes the data after the second transaction has completed, but it does not recognize an intermediate state.</span></span> <span data-ttu-id="6c498-126">這稱為序列化能力 (Serializability)，因為這樣可以產生重新載入起始資料並重新執行一系列的交易，以便讓資料最終能夠與原始交易執行後的狀態相同的能力。</span><span class="sxs-lookup"><span data-stu-id="6c498-126">This is referred to as serializability because it results in the ability to reload the starting data and replay a series of transactions to end up with the data in the same state it was in after the original transactions were performed.</span></span>  
  
 <span data-ttu-id="6c498-127">持久性</span><span class="sxs-lookup"><span data-stu-id="6c498-127">Durability</span></span>  
 <span data-ttu-id="6c498-128">完全持久交易完成之後，其作用便永遠存在於系統之中。</span><span class="sxs-lookup"><span data-stu-id="6c498-128">After a fully durable transaction has completed, its effects are permanently in place in the system.</span></span> <span data-ttu-id="6c498-129">即使發生系統失敗仍會保存修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-129">The modifications persist even in the event of a system failure.</span></span> [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] <span data-ttu-id="6c498-130">和更新版本支援延遲的持久交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-130">and later enable delayed durable transactions.</span></span> <span data-ttu-id="6c498-131">延遲的持久交易會在交易記錄檔記錄永久保存到磁碟之前認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-131">Delayed durable transactions commit before the transaction log record is persisted to disk.</span></span> <span data-ttu-id="6c498-132">如需有關延遲交易持久性的詳細資訊，請參閱[交易持久性](../relational-databases/logs/control-transaction-durability.md)主題。</span><span class="sxs-lookup"><span data-stu-id="6c498-132">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
 <span data-ttu-id="6c498-133">SQL 程式設計者負責在強制資料邏輯一致性 (Consistency) 的點上啟動與結束交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-133">SQL programmers are responsible for starting and ending transactions at points that enforce the logical consistency of the data.</span></span> <span data-ttu-id="6c498-134">程式設計者必須定義資料修改順序，讓資料維持在與組織的商業規則有關的一致性狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-134">The programmer must define the sequence of data modifications that leave the data in a consistent state relative to the organization's business rules.</span></span> <span data-ttu-id="6c498-135">然後再由程式設計者將這些修改陳述式包含於單一的交易中，這樣 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 便得以強制交易的實體完整性。</span><span class="sxs-lookup"><span data-stu-id="6c498-135">The programmer includes these modification statements in a single transaction so that the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] can enforce the physical integrity of the transaction.</span></span>  
  
 <span data-ttu-id="6c498-136">提供可確保每一筆交易實體完整性的機制是企業資料庫系統 (例如 [!INCLUDE[ssDE](../includes/ssde-md.md)]的執行個體) 的責任。</span><span class="sxs-lookup"><span data-stu-id="6c498-136">It is the responsibility of an enterprise database system, such as an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], to provide mechanisms ensuring the physical integrity of each transaction.</span></span> <span data-ttu-id="6c498-137">[!INCLUDE[ssDE](../includes/ssde-md.md)] 提供：</span><span class="sxs-lookup"><span data-stu-id="6c498-137">The [!INCLUDE[ssDE](../includes/ssde-md.md)] provides:</span></span>  
  
-   <span data-ttu-id="6c498-138">保持交易隔離性 (Isolation) 的鎖定機能 (Locking Facility)。</span><span class="sxs-lookup"><span data-stu-id="6c498-138">Locking facilities that preserve transaction isolation.</span></span>  
  
-   <span data-ttu-id="6c498-139">記錄機能可確保交易持久性。</span><span class="sxs-lookup"><span data-stu-id="6c498-139">Logging facilities ensure transaction durability.</span></span> <span data-ttu-id="6c498-140">針對完全持久交易，記錄檔記錄會在交易認可之前強行寫入磁碟。</span><span class="sxs-lookup"><span data-stu-id="6c498-140">For fully durable transactions the log record is hardened to disk before the transactions commits.</span></span> <span data-ttu-id="6c498-141">因此，即使伺服器硬體、作業系統或[!INCLUDE[ssDE](../includes/ssde-md.md)]執行個體本身發生失敗，該執行個體仍會在重新啟動時，使用交易記錄檔，將所有未完成的交易自動復原到系統失敗點。</span><span class="sxs-lookup"><span data-stu-id="6c498-141">Thus, even if the server hardware, operating system, or the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] itself fails, the instance uses the transaction logs upon restart to automatically roll back any uncompleted transactions to the point of the system failure.</span></span> <span data-ttu-id="6c498-142">延遲的持久交易會在交易記錄檔記錄強行寫入磁碟之前認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-142">Delayed durable transactions commit before the transaction log record is hardened to disk.</span></span> <span data-ttu-id="6c498-143">如果在記錄檔記錄先強行寫入磁碟之前發生系統失敗，這類交易可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="6c498-143">Such transactions may be lost if there is a system failure before the log record is hardened to disk.</span></span> <span data-ttu-id="6c498-144">如需有關延遲交易持久性的詳細資訊，請參閱[交易持久性](../relational-databases/logs/control-transaction-durability.md)主題。</span><span class="sxs-lookup"><span data-stu-id="6c498-144">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
-   <span data-ttu-id="6c498-145">強制不可部份完成性 (Atomicity) 與一致性的交易管理功能。</span><span class="sxs-lookup"><span data-stu-id="6c498-145">Transaction management features that enforce transaction atomicity and consistency.</span></span> <span data-ttu-id="6c498-146">交易在啟動之後必須成功地完成 (認可)，否則 [!INCLUDE[ssDE](../includes/ssde-md.md)] 會將交易啟動後所做的所有資料修改動作復原。</span><span class="sxs-lookup"><span data-stu-id="6c498-146">After a transaction has started, it must be successfully completed (committed), or the [!INCLUDE[ssDE](../includes/ssde-md.md)] undoes all of the data modifications made since the transaction started.</span></span> <span data-ttu-id="6c498-147">這項作業稱為回復交易，因為資料將恢復為任何變更發生之前的狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-147">This operation is referred to as rolling back a transaction because it returns the data to the state it was prior to those changes.</span></span>  
  
### <a name="controlling-transactions"></a><span data-ttu-id="6c498-148">控制交易</span><span class="sxs-lookup"><span data-stu-id="6c498-148">Controlling Transactions</span></span>  

 <span data-ttu-id="6c498-149">應用程式主要是透過指定交易何時啟動及結束來控制交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-149">Applications control transactions mainly by specifying when a transaction starts and ends.</span></span> <span data-ttu-id="6c498-150">這可利用 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式或資料庫應用程式開發介面 (API) 函數來指定。</span><span class="sxs-lookup"><span data-stu-id="6c498-150">This can be specified by using either [!INCLUDE[tsql](../includes/tsql-md.md)] statements or database application programming interface (API) functions.</span></span> <span data-ttu-id="6c498-151">系統也必須能夠正確地處理交易完成之前便結束交易的錯誤。</span><span class="sxs-lookup"><span data-stu-id="6c498-151">The system must also be able to correctly handle errors that terminate a transaction before it completes.</span></span> <span data-ttu-id="6c498-152">如需詳細資訊，請參閱[transact-sql&#41;的交易語句 &#40;](/sql/t-sql/language-elements/transactions-transact-sql)、 [ODBC 中的交易](https://technet.microsoft.com/library/ms131281.aspx)和[SQL Server Native Client (OLEDB) 中的交易](https://msdn.microsoft.com/library/ms130918.aspx)。</span><span class="sxs-lookup"><span data-stu-id="6c498-152">For more information, see [Transaction Statements &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/transactions-transact-sql), [Transactions in ODBC](https://technet.microsoft.com/library/ms131281.aspx) and [Transactions in SQL Server Native Client (OLEDB)](https://msdn.microsoft.com/library/ms130918.aspx).</span></span>  
  
 <span data-ttu-id="6c498-153">依照預設，會在連接層級管理交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-153">By default, transactions are managed at the connection level.</span></span> <span data-ttu-id="6c498-154">在連接上啟動交易時，連接上執行的所有 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式在交易結束之前都是該交易的一部分。</span><span class="sxs-lookup"><span data-stu-id="6c498-154">When a transaction is started on a connection, all [!INCLUDE[tsql](../includes/tsql-md.md)] statements executed on that connection are part of the transaction until the transaction ends.</span></span> <span data-ttu-id="6c498-155">但是，在 Multiple Active Result Set (MARS) 工作階段下， [!INCLUDE[tsql](../includes/tsql-md.md)] 明確或不明確交易會成為在批次層級管理的批次範圍交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-155">However, under a multiple active result set (MARS) session, a [!INCLUDE[tsql](../includes/tsql-md.md)] explicit or implicit transaction becomes a batch-scoped transaction that is managed at the batch level.</span></span> <span data-ttu-id="6c498-156">當批次完成時，如果未認可或回復批次範圍的交易， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]會自動回復它。</span><span class="sxs-lookup"><span data-stu-id="6c498-156">When the batch completes, if the batch-scoped transaction is not committed or rolled back, it is automatically rolled back by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6c498-157">如需詳細資訊，請參閱 [SQL Server 中的 Multiple Active Result Sets (MARS)](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx)。</span><span class="sxs-lookup"><span data-stu-id="6c498-157">For more information, see [Multiple Active Result Sets (MARS) in SQL Server](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx).</span></span>  
  
#### <a name="starting-transactions"></a><span data-ttu-id="6c498-158">啟動交易</span><span class="sxs-lookup"><span data-stu-id="6c498-158">Starting Transactions</span></span>  

 <span data-ttu-id="6c498-159">使用 API 函數和 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式，您可以在 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 的執行個體中，以明確、自動認可或隱含來啟動交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-159">Using API functions and [!INCLUDE[tsql](../includes/tsql-md.md)] statements, you can start transactions in an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] as explicit, autocommit, or implicit transactions.</span></span>  
  
 <span data-ttu-id="6c498-160">**明確交易**</span><span class="sxs-lookup"><span data-stu-id="6c498-160">**Explicit Transactions**</span></span>  
 <span data-ttu-id="6c498-161">外顯交易是透過 API 函數或藉由發出 [!INCLUDE[tsql](../includes/tsql-md.md)] BEGIN TRANSACTION、COMMIT TRANSACTION、COMMIT WORK、ROLLBACK TRANSACTION 或 ROLLBACK WORK [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式，明確定義交易的啟動與結束的一種交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-161">An explicit transaction is one in which you explicitly define both the start and end of the transaction through an API function or by issuing the [!INCLUDE[tsql](../includes/tsql-md.md)] BEGIN TRANSACTION, COMMIT TRANSACTION, COMMIT WORK, ROLLBACK TRANSACTION, or ROLLBACK WORK [!INCLUDE[tsql](../includes/tsql-md.md)] statements.</span></span> <span data-ttu-id="6c498-162">當交易結束時，連線便會回到外顯交易啟動之前的交易模式，可能是隱含或自動認可模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-162">When the transaction ends, the connection returns to the transaction mode it was in before the explicit transaction was started, either implicit or autocommit mode.</span></span>  
  
 <span data-ttu-id="6c498-163">您可以在明確的交易中，使用下列陳述式以外的所有 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式：</span><span class="sxs-lookup"><span data-stu-id="6c498-163">You can use all [!INCLUDE[tsql](../includes/tsql-md.md)] statements in an explicit transaction, except for the following statements:</span></span>  
  
||||  
|-|-|-|  
|<span data-ttu-id="6c498-164">ALTER DATABASE</span><span class="sxs-lookup"><span data-stu-id="6c498-164">ALTER DATABASE</span></span>|<span data-ttu-id="6c498-165">CREATE DATABASE</span><span class="sxs-lookup"><span data-stu-id="6c498-165">CREATE DATABASE</span></span>|<span data-ttu-id="6c498-166">DROP FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="6c498-166">DROP FULLTEXT INDEX</span></span>|  
|<span data-ttu-id="6c498-167">ALTER FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="6c498-167">ALTER FULLTEXT CATALOG</span></span>|<span data-ttu-id="6c498-168">CREATE FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="6c498-168">CREATE FULLTEXT CATALOG</span></span>|<span data-ttu-id="6c498-169">RECONFIGURE</span><span class="sxs-lookup"><span data-stu-id="6c498-169">RECONFIGURE</span></span>|  
|<span data-ttu-id="6c498-170">ALTER FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="6c498-170">ALTER FULLTEXT INDEX</span></span>|<span data-ttu-id="6c498-171">CREATE FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="6c498-171">CREATE FULLTEXT INDEX</span></span>|<span data-ttu-id="6c498-172">RESTORE</span><span class="sxs-lookup"><span data-stu-id="6c498-172">RESTORE</span></span>|  
|<span data-ttu-id="6c498-173">備份</span><span class="sxs-lookup"><span data-stu-id="6c498-173">BACKUP</span></span>|<span data-ttu-id="6c498-174">DROP DATABASE</span><span class="sxs-lookup"><span data-stu-id="6c498-174">DROP DATABASE</span></span>|<span data-ttu-id="6c498-175">全文檢索系統預存程序</span><span class="sxs-lookup"><span data-stu-id="6c498-175">Full-text system stored procedures</span></span>|  
|<span data-ttu-id="6c498-176">CREATE DATABASE</span><span class="sxs-lookup"><span data-stu-id="6c498-176">CREATE DATABASE</span></span>|<span data-ttu-id="6c498-177">DROP FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="6c498-177">DROP FULLTEXT CATALOG</span></span>|<span data-ttu-id="6c498-178">由 sp_dboption 設定資料庫選項，或於外顯或隱含交易中修改 master 資料庫的任何系統程序。</span><span class="sxs-lookup"><span data-stu-id="6c498-178">sp_dboption to set database options or any system procedure that modifies the master database inside explicit or implicit transactions.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-179">UPDATE STATISTICS 可於外顯交易內使用。</span><span class="sxs-lookup"><span data-stu-id="6c498-179">UPDATE STATISTICS can be used inside an explicit transaction.</span></span> <span data-ttu-id="6c498-180">但是，UPDATE STATISTICS 認可與含括交易無關，而且無法回復。</span><span class="sxs-lookup"><span data-stu-id="6c498-180">However, UPDATE STATISTICS commits independently of the enclosing transaction and cannot be rolled back.</span></span>  
  
 <span data-ttu-id="6c498-181">**自動認可交易**</span><span class="sxs-lookup"><span data-stu-id="6c498-181">**Autocommit Transactions**</span></span>  
 <span data-ttu-id="6c498-182">自動認可模式是 SQL Server Database Engine 的預設交易管理模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-182">Autocommit mode is the default transaction management mode of the SQL Server Database Engine.</span></span> <span data-ttu-id="6c498-183">每一個 Transact-SQL 陳述式都會在完成時認可或回復。</span><span class="sxs-lookup"><span data-stu-id="6c498-183">Every Transact-SQL statement is committed or rolled back when it completes.</span></span> <span data-ttu-id="6c498-184">陳述式如果成功地完成便被認可；若是遇到任何錯誤則被復原。</span><span class="sxs-lookup"><span data-stu-id="6c498-184">If a statement completes successfully, it is committed; if it encounters any error, it is rolled back.</span></span> <span data-ttu-id="6c498-185">只要這個預設模式沒有被外顯交易或隱含交易覆寫，Database Engine 執行個體的連接都會在自動認可模式下操作。</span><span class="sxs-lookup"><span data-stu-id="6c498-185">A connection to an instance of the Database Engine operates in autocommit mode whenever this default mode has not been overridden by either explicit or implicit transactions.</span></span> <span data-ttu-id="6c498-186">自動認可模式也是 ADO、OLE DB、ODBC 與資料程式庫的預設模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-186">Autocommit mode is also the default mode for ADO, OLE DB, ODBC, and DB-Library.</span></span>  
  
 <span data-ttu-id="6c498-187">**隱含交易**</span><span class="sxs-lookup"><span data-stu-id="6c498-187">**Implicit Transactions**</span></span>  
 <span data-ttu-id="6c498-188">在隱含交易模式下操作連接時，Database Engine 的執行個體會在目前交易完成認可或回復後，自動啟動新的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-188">When a connection is operating in implicit transaction mode, the instance of the Database Engine automatically starts a new transaction after the current transaction is committed or rolled back.</span></span> <span data-ttu-id="6c498-189">您不需描述交易的啟動；只要認可或復原每一筆交易即可。</span><span class="sxs-lookup"><span data-stu-id="6c498-189">You do nothing to delineate the start of a transaction; you only commit or roll back each transaction.</span></span> <span data-ttu-id="6c498-190">隱含交易模式產生連續的交易鍊。</span><span class="sxs-lookup"><span data-stu-id="6c498-190">Implicit transaction mode generates a continuous chain of transactions.</span></span> <span data-ttu-id="6c498-191">透過 API 函數或 [!INCLUDE[tsql](../includes/tsql-md.md)] SET IMPLICIT_TRANSACTIONS ON 陳述式，可將隱含交易模式設為開啟。</span><span class="sxs-lookup"><span data-stu-id="6c498-191">Set implicit transaction mode on through either an API function or the [!INCLUDE[tsql](../includes/tsql-md.md)] SET IMPLICIT_TRANSACTIONS ON statement.</span></span>  
  
 <span data-ttu-id="6c498-192">當連接的隱含交易模式設定為開啟之後， [!INCLUDE[ssDE](../includes/ssde-md.md)] 的執行個體便會在第一次執行下列任一個陳述式時，自動啟動一筆交易：</span><span class="sxs-lookup"><span data-stu-id="6c498-192">After implicit transaction mode has been set on for a connection, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically starts a transaction when it first executes any of these statements:</span></span>  
  
||||  
|-|-|-|  
|<span data-ttu-id="6c498-193">ALTER TABLE</span><span class="sxs-lookup"><span data-stu-id="6c498-193">ALTER TABLE</span></span>|<span data-ttu-id="6c498-194">FETCH</span><span class="sxs-lookup"><span data-stu-id="6c498-194">FETCH</span></span>|<span data-ttu-id="6c498-195">REVOKE</span><span class="sxs-lookup"><span data-stu-id="6c498-195">REVOKE</span></span>|  
|<span data-ttu-id="6c498-196">CREATE</span><span class="sxs-lookup"><span data-stu-id="6c498-196">CREATE</span></span>|<span data-ttu-id="6c498-197">GRANT</span><span class="sxs-lookup"><span data-stu-id="6c498-197">GRANT</span></span>|<span data-ttu-id="6c498-198">SELECT</span><span class="sxs-lookup"><span data-stu-id="6c498-198">SELECT</span></span>|  
|<span data-ttu-id="6c498-199">刪除</span><span class="sxs-lookup"><span data-stu-id="6c498-199">DELETE</span></span>|<span data-ttu-id="6c498-200">Insert</span><span class="sxs-lookup"><span data-stu-id="6c498-200">INSERT</span></span>|<span data-ttu-id="6c498-201">TRUNCATE TABLE</span><span class="sxs-lookup"><span data-stu-id="6c498-201">TRUNCATE TABLE</span></span>|  
|<span data-ttu-id="6c498-202">DROP</span><span class="sxs-lookup"><span data-stu-id="6c498-202">DROP</span></span>|<span data-ttu-id="6c498-203">OPEN</span><span class="sxs-lookup"><span data-stu-id="6c498-203">OPEN</span></span>|<span data-ttu-id="6c498-204">UPDATE</span><span class="sxs-lookup"><span data-stu-id="6c498-204">UPDATE</span></span>|  
  
 <span data-ttu-id="6c498-205">**批次範圍交易**</span><span class="sxs-lookup"><span data-stu-id="6c498-205">**Batch-scoped Transactions**</span></span>  
 <span data-ttu-id="6c498-206">僅適用於 Multiple Active Result Sets (MARS)，在 MARS 工作階段下啟動的 [!INCLUDE[tsql](../includes/tsql-md.md)] 外顯或隱含交易會變成批次範圍的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-206">Applicable only to multiple active result sets (MARS), a [!INCLUDE[tsql](../includes/tsql-md.md)] explicit or implicit transaction that starts under a MARS session becomes a batch-scoped transaction.</span></span> <span data-ttu-id="6c498-207">當批次完成時， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]會自動回復未認可或回復之批次範圍的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-207">A batch-scoped transaction that is not committed or rolled back when a batch completes is automatically rolled back by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="6c498-208">**分散式交易**</span><span class="sxs-lookup"><span data-stu-id="6c498-208">**Distributed Transactions**</span></span>  
 <span data-ttu-id="6c498-209">分散式交易跨越二或多個稱為資源管理員的伺服器。</span><span class="sxs-lookup"><span data-stu-id="6c498-209">Distributed transactions span two or more servers known as resource managers.</span></span> <span data-ttu-id="6c498-210">交易的管理必須由一種稱為交易管理員的伺服器元件在資源管理員之間協調。</span><span class="sxs-lookup"><span data-stu-id="6c498-210">The management of the transaction must be coordinated between the resource managers by a server component called a transaction manager.</span></span> <span data-ttu-id="6c498-211">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 的每個執行個體在分散式交易中可作為資源管理員來運作，而由交易管理員 (例如 [!INCLUDE[msCoName](../includes/msconame-md.md)] 分散式交易協調器 (MS DTC)) 或其他支援分散式交易處理的 Open Group XA 規格之交易管理員來協調分散式交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-211">Each instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] can operate as a resource manager in distributed transactions coordinated by transaction managers, such as [!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator (MS DTC), or other transaction managers that support the Open Group XA specification for distributed transaction processing.</span></span> <span data-ttu-id="6c498-212">如需詳細資訊，請參閱 MS DTC 文件集。</span><span class="sxs-lookup"><span data-stu-id="6c498-212">For more information, see the MS DTC documentation.</span></span>  
  
 <span data-ttu-id="6c498-213">在單一 [!INCLUDE[ssDE](../includes/ssde-md.md)] 執行個體內部，跨越二或多個資料庫的交易，實際上就是分散式交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-213">A transaction within a single instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] that spans two or more databases is actually a distributed transaction.</span></span> <span data-ttu-id="6c498-214">執行個體是由內部來管理分散式交易；而對於使用者而言則是以本機交易來運作。</span><span class="sxs-lookup"><span data-stu-id="6c498-214">The instance manages the distributed transaction internally; to the user, it operates as a local transaction.</span></span>  
  
 <span data-ttu-id="6c498-215">在應用程式中，分散式交易的管理與本機交易大致相同。</span><span class="sxs-lookup"><span data-stu-id="6c498-215">At the application, a distributed transaction is managed much the same as a local transaction.</span></span> <span data-ttu-id="6c498-216">交易結束時，應用程式便要求認可或回復交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-216">At the end of the transaction, the application requests the transaction to be either committed or rolled back.</span></span> <span data-ttu-id="6c498-217">分散式認可必須另由交易管理員來管理，以便將網路失敗可能會造成某些資源管理員成功認可而其他資源管理員卻將交易回復的風險降至最低。</span><span class="sxs-lookup"><span data-stu-id="6c498-217">A distributed commit must be managed differently by the transaction manager to minimize the risk that a network failure may result in some resource managers successfully committing while others roll back the transaction.</span></span> <span data-ttu-id="6c498-218">這可藉由在兩個階段 (準備階段與認可階段) 中管理認可過程來達到，稱為兩階段認可交易 (Two-Phase Commit，2PC)。</span><span class="sxs-lookup"><span data-stu-id="6c498-218">This is achieved by managing the commit process in two phases (the prepare phase and the commit phase), which is known as a two-phase commit (2PC).</span></span>  
  
 <span data-ttu-id="6c498-219">準備階段</span><span class="sxs-lookup"><span data-stu-id="6c498-219">Prepare phase</span></span>  
 <span data-ttu-id="6c498-220">當交易管理員接收到認可的要求時，便傳送準備命令給所有參與交易的資源管理員。</span><span class="sxs-lookup"><span data-stu-id="6c498-220">When the transaction manager receives a commit request, it sends a prepare command to all of the resource managers involved in the transaction.</span></span> <span data-ttu-id="6c498-221">然後再由每個資源管理員進行可讓交易持續，並把放置交易記錄檔影像的所有緩衝區排清到磁碟上所需的一切動作。</span><span class="sxs-lookup"><span data-stu-id="6c498-221">Each resource manager then does everything required to make the transaction durable, and all buffers holding log images for the transaction are flushed to disk.</span></span> <span data-ttu-id="6c498-222">當每個資源管理員完成準備階段時，便將準備的成功或失敗結果傳回交易管理員。</span><span class="sxs-lookup"><span data-stu-id="6c498-222">As each resource manager completes the prepare phase, it returns success or failure of the prepare to the transaction manager.</span></span> [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] <span data-ttu-id="6c498-223">導入了延遲的交易持久性。</span><span class="sxs-lookup"><span data-stu-id="6c498-223">introduced delayed transaction durability.</span></span> <span data-ttu-id="6c498-224">認可延遲的持久交易會在交易的記錄檔映像排清至磁碟之前認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-224">Delayed durable transactions commit before log images for the transaction are flushed to disk.</span></span> <span data-ttu-id="6c498-225">如需有關延遲交易持久性的詳細資訊，請參閱[交易持久性](../relational-databases/logs/control-transaction-durability.md)主題。</span><span class="sxs-lookup"><span data-stu-id="6c498-225">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
 <span data-ttu-id="6c498-226">認可階段</span><span class="sxs-lookup"><span data-stu-id="6c498-226">Commit phase</span></span>  
 <span data-ttu-id="6c498-227">如果交易管理員從所有的資源管理員接收到準備成功，便傳送認可命令給每個資源管理員。</span><span class="sxs-lookup"><span data-stu-id="6c498-227">If the transaction manager receives successful prepares from all of the resource managers, it sends commit commands to each resource manager.</span></span> <span data-ttu-id="6c498-228">然後資源管理員即可完成認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-228">The resource managers can then complete the commit.</span></span> <span data-ttu-id="6c498-229">如果全部的資源管理員都報告認可成功，交易管理員便傳送成功的通知給應用程式。</span><span class="sxs-lookup"><span data-stu-id="6c498-229">If all of the resource managers report a successful commit, the transaction manager then sends a success notification to the application.</span></span> <span data-ttu-id="6c498-230">若有任何資源管理員報告準備失敗，交易管理員便傳送回復命令給每個資源管理員並告知應用程式認可失敗。</span><span class="sxs-lookup"><span data-stu-id="6c498-230">If any resource manager reported a failure to prepare, the transaction manager sends a rollback command to each resource manager and indicates the failure of the commit to the application.</span></span>  
  
 [!INCLUDE[ssDE](../includes/ssde-md.md)] <span data-ttu-id="6c498-231">應用程式可以透過 [!INCLUDE[tsql](../includes/tsql-md.md)] 或資料庫 API 來管理分散式交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-231">applications can manage distributed transactions either through [!INCLUDE[tsql](../includes/tsql-md.md)] or the database API.</span></span> <span data-ttu-id="6c498-232">如需詳細資訊，請參閱 [BEGIN DISTRIBUTED TRANSACTION &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-232">For more information, see [BEGIN DISTRIBUTED TRANSACTION &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql).</span></span>  
  
#### <a name="ending-transactions"></a><span data-ttu-id="6c498-233">結束交易</span><span class="sxs-lookup"><span data-stu-id="6c498-233">Ending Transactions</span></span>  

 <span data-ttu-id="6c498-234">您可以使用 COMMIT 或 ROLLBACK 陳述式，或透過對應的 API 函數來結束交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-234">You can end transactions with either a COMMIT or ROLLBACK statement, or through a corresponding API function.</span></span>  
  
 <span data-ttu-id="6c498-235">COMMIT</span><span class="sxs-lookup"><span data-stu-id="6c498-235">COMMIT</span></span>  
 <span data-ttu-id="6c498-236">交易如果成功便會認可交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-236">If a transaction is successful, commit it.</span></span> <span data-ttu-id="6c498-237">COMMIT 陳述式可以保證交易所做的全部修改，都會變成資料庫永久的一部分。</span><span class="sxs-lookup"><span data-stu-id="6c498-237">A COMMIT statement guarantees all of the transaction's modifications are made a permanent part of the database.</span></span> <span data-ttu-id="6c498-238">COMMIT 同時也會釋放資源，例如交易所使用的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-238">A COMMIT also frees resources, such as locks, used by the transaction.</span></span>  
  
 <span data-ttu-id="6c498-239">ROLLBACK</span><span class="sxs-lookup"><span data-stu-id="6c498-239">ROLLBACK</span></span>  
 <span data-ttu-id="6c498-240">如果交易中發生錯誤，或是使用者決定取消交易，便會將交易回復。</span><span class="sxs-lookup"><span data-stu-id="6c498-240">If an error occurs in a transaction, or if the user decides to cancel the transaction, then roll the transaction back.</span></span> <span data-ttu-id="6c498-241">ROLLBACK 陳述式藉由將資料帶回到交易啟動時的狀態，來取消交易中進行的所有修改動作。</span><span class="sxs-lookup"><span data-stu-id="6c498-241">A ROLLBACK statement backs out all modifications made in the transaction by returning the data to the state it was in at the start of the transaction.</span></span> <span data-ttu-id="6c498-242">ROLLBACK 也會釋放交易所佔用的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-242">A ROLLBACK also frees resources held by the transaction.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-243">在啟用支援 Multiple Active Result Set (MARS) 的連線下，當執行有擱置的要求時，無法認可透過 API 函數啟動的明確交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-243">Under connections enabled to support multiple active result sets (MARS), an explicit transaction started through an API function cannot be committed while there are pending requests for execution.</span></span> <span data-ttu-id="6c498-244">仍有未處理作業在執行時，任何嘗試認可此類型的要求將會導致錯誤。</span><span class="sxs-lookup"><span data-stu-id="6c498-244">Any attempt to commit this type of  transaction while there are outstanding operations running will result in an error.</span></span>  
  
#### <a name="errors-during-transaction-processing"></a><span data-ttu-id="6c498-245">交易處理期間的錯誤</span><span class="sxs-lookup"><span data-stu-id="6c498-245">Errors During Transaction Processing</span></span>  

 <span data-ttu-id="6c498-246">如果因為錯誤而讓交易無法順利完成， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 會自動回復交易，並釋放交易所佔用的一切資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-246">If an error prevents the successful completion of a transaction, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] automatically rolls back the transaction and frees all resources held by the transaction.</span></span> <span data-ttu-id="6c498-247">如果用戶端與 [!INCLUDE[ssDE](../includes/ssde-md.md)] 執行個體之間的網路連接已中斷，該連接尚未處理完畢的交易會在網路通知該執行個體發生中斷時全部回復。</span><span class="sxs-lookup"><span data-stu-id="6c498-247">If the client's network connection to an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] is broken, any outstanding transactions for the connection are rolled back when the network notifies the instance of the break.</span></span> <span data-ttu-id="6c498-248">如果用戶端應用程式失敗或是用戶端電腦當機或重新啟動，也會中斷連接， [!INCLUDE[ssDE](../includes/ssde-md.md)] 執行個體會在網路通知已發生中斷時，回復所有尚未處理完畢的連接。</span><span class="sxs-lookup"><span data-stu-id="6c498-248">If the client application fails or if the client computer goes down or is restarted, this also breaks the connection, and the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] rolls back any outstanding connections when the network notifies it of the break.</span></span> <span data-ttu-id="6c498-249">如果用戶端從應用程式登出，便會復原任何尚未處理完畢的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-249">If the client logs off the application, any outstanding transactions are rolled back.</span></span>  
  
 <span data-ttu-id="6c498-250">如果批次中發生執行階段陳述式錯誤 (例如條件約束違規)， [!INCLUDE[ssDE](../includes/ssde-md.md)] 的預設行為是只回復產生錯誤的陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-250">If a run-time statement error (such as a constraint violation) occurs in a batch, the default behavior in the [!INCLUDE[ssDE](../includes/ssde-md.md)] is to roll back only the statement that generated the error.</span></span> <span data-ttu-id="6c498-251">您可以使用 SET XACT_ABORT 陳述式來變更這個行為。</span><span class="sxs-lookup"><span data-stu-id="6c498-251">You can change this behavior using the SET XACT_ABORT statement.</span></span> <span data-ttu-id="6c498-252">在 SET XACT_ABORT ON 執行之後，任何執行時期陳述式錯誤都會讓目前的交易自動回復。</span><span class="sxs-lookup"><span data-stu-id="6c498-252">After SET XACT_ABORT ON is executed, any run-time statement error causes an automatic rollback of the current transaction.</span></span> <span data-ttu-id="6c498-253">SET XACT_ABORT 不會影響到如語法錯誤之類的編譯錯誤。</span><span class="sxs-lookup"><span data-stu-id="6c498-253">Compile errors, such as syntax errors, are not affected by SET XACT_ABORT.</span></span> <span data-ttu-id="6c498-254">如需詳細資訊，請參閱 [SET XACT_ABORT &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-xact-abort-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-254">For more information, see [SET XACT_ABORT &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-xact-abort-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-255">發生錯誤時，更正動作 (COMMIT 或 ROLLBACK) 應該包括在應用程式碼中。</span><span class="sxs-lookup"><span data-stu-id="6c498-255">When errors occur, corrective action (COMMIT or ROLLBACK) should be included in application code.</span></span> <span data-ttu-id="6c498-256">處理錯誤的一個有效工具（包括交易中的錯誤）是 [ [!INCLUDE[tsql](../includes/tsql-md.md)] TRY ...]CATCH 結構。</span><span class="sxs-lookup"><span data-stu-id="6c498-256">One effective tool for handling errors, including those in transactions, is the [!INCLUDE[tsql](../includes/tsql-md.md)] TRY...CATCH construct.</span></span> <span data-ttu-id="6c498-257">如需有關包括交易之範例的詳細資訊，請參閱 [TRY...CATCH &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/try-catch-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-257">For more information with examples that include transactions, see [TRY...CATCH &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/try-catch-transact-sql).</span></span> <span data-ttu-id="6c498-258">從開始 [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] ，您可以使用 THROW 語句來引發例外狀況，並將執行轉移至 TRY 的 CATCH 區塊 .。。CATCH 結構。</span><span class="sxs-lookup"><span data-stu-id="6c498-258">Beginning with [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], you can use the THROW statement to raise an exception and transfers execution to a CATCH block of a TRY...CATCH construct.</span></span> <span data-ttu-id="6c498-259">如需詳細資訊，請參閱 [THROW &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/throw-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-259">For more information, see [THROW &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/throw-transact-sql).</span></span>  
  
##### <a name="compile-and-run-time-errors-in-autocommit-mode"></a><span data-ttu-id="6c498-260">自動認可模式下的編譯與執行階段錯誤</span><span class="sxs-lookup"><span data-stu-id="6c498-260">Compile and Run-time Errors in Autocommit mode</span></span>  

 <span data-ttu-id="6c498-261">在自動認可模式中，有時 [!INCLUDE[ssDE](../includes/ssde-md.md)] 執行個體會好像已將整個批次回復，而非只有一個 SQL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-261">In autocommit mode, it sometimes appears as if an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] has rolled back an entire batch instead of just one SQL statement.</span></span> <span data-ttu-id="6c498-262">這種情形只有遇到編譯錯誤時才會發生，執行階段錯誤則不會。</span><span class="sxs-lookup"><span data-stu-id="6c498-262">This happens if the error encountered is a compile error, not a run-time error.</span></span> <span data-ttu-id="6c498-263">編譯錯誤會讓 [!INCLUDE[ssDE](../includes/ssde-md.md)] 無法建立執行計畫，因此批次中的任何陳述式都不會執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-263">A compile error prevents the [!INCLUDE[ssDE](../includes/ssde-md.md)] from building an execution plan, so nothing in the batch is executed.</span></span> <span data-ttu-id="6c498-264">雖然產生錯誤的陳述式之前的所有陳述式都會回復，但錯誤會讓批次中的一切都不會執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-264">Although it appears that all of the statements before the one generating the error were rolled back, the error prevented anything in the batch from being executed.</span></span> <span data-ttu-id="6c498-265">在下列範例中，位於第三個批次的 `INSERT` 陳述式由於編譯錯誤而全部不執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-265">In the following example, none of the `INSERT` statements in the third batch are executed because of a compile error.</span></span> <span data-ttu-id="6c498-266">前兩個 `INSERT` 陳述式由於並未執行而復原。</span><span class="sxs-lookup"><span data-stu-id="6c498-266">It appears that the first two `INSERT` statements are rolled back when they are never executed.</span></span>  
  
```sql
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBatch VALUSE (3, 'ccc');  -- Syntax error.  
GO  
SELECT * FROM TestBatch;  -- Returns no rows.  
GO  
```  
  
 <span data-ttu-id="6c498-267">在下列範例中，第三個 `INSERT` 陳述式會產生執行階段重複的主索引鍵錯誤。</span><span class="sxs-lookup"><span data-stu-id="6c498-267">In the following example, the third `INSERT` statement generates a run-time duplicate primary key error.</span></span> <span data-ttu-id="6c498-268">前兩個 `INSERT` 陳述式會成功並且受到認可，因此它們在執行階段錯誤之後仍會保留。</span><span class="sxs-lookup"><span data-stu-id="6c498-268">The first two `INSERT` statements are successful and committed, so they remain after the run-time error.</span></span>  
  
```sql  
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBatch VALUES (1, 'ccc');  -- Duplicate key error.  
GO  
SELECT * FROM TestBatch;  -- Returns rows 1 and 2.  
GO  
```  
  
 <span data-ttu-id="6c498-269">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會使用延遲的名稱解析，直到執行時間才會解析物件名稱。</span><span class="sxs-lookup"><span data-stu-id="6c498-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses deferred name resolution, in which object names are not resolved until execution time.</span></span> <span data-ttu-id="6c498-270">在下列範例中，前兩個 `INSERT` 陳述式會執行並認可，且這兩個資料列會在參考到不存在的資料表而產生執行階段錯誤的第三個 `TestBatch` 陳述式之後，仍然留在 `INSERT` 資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-270">In the following example, the first two `INSERT` statements are executed and committed, and those two rows remain in the `TestBatch` table after the third `INSERT` statement generates a run-time error by referring to a table that does not exist.</span></span>  
  
```sql
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBch VALUES (3, 'ccc');  -- Table name error.  
GO  
SELECT * FROM TestBatch;  -- Returns rows 1 and 2.  
GO  
```  
  
 <span data-ttu-id="6c498-271">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="6c498-271">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="locking-and-row-versioning-basics"></a><a name="Lock_Basics"></a> <span data-ttu-id="6c498-272">鎖定與資料列版本設定基本概念</span><span class="sxs-lookup"><span data-stu-id="6c498-272">Locking and Row Versioning Basics</span></span>  

 <span data-ttu-id="6c498-273">當多個使用者同時存取資料時， [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 會使用下列機制來確保交易完整性，並維護資料庫一致性：</span><span class="sxs-lookup"><span data-stu-id="6c498-273">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses the following mechanisms to ensure the integrity of transactions and maintain the consistency of databases when multiple users are accessing data at the same time:</span></span>  
  
-   <span data-ttu-id="6c498-274">鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-274">Locking</span></span>  
  
     <span data-ttu-id="6c498-275">每一個交易會要求資源上不同類型的鎖定，例如交易相依的資料列、頁面或資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-275">Each transaction requests locks of different types on the resources, such as rows, pages, or tables, on which the transaction is dependent.</span></span> <span data-ttu-id="6c498-276">鎖定會阻擋其他交易修改資源，以免造成要求鎖定的交易發生問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-276">The locks block other transactions from modifying the resources in a way that would cause problems for the transaction requesting the lock.</span></span> <span data-ttu-id="6c498-277">每一個交易對於鎖定的資源不再具有相依性時，就會釋放它的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-277">Each transaction frees its locks when it no longer has a dependency on the locked resources.</span></span>  
  
-   <span data-ttu-id="6c498-278">資料列版本設定</span><span class="sxs-lookup"><span data-stu-id="6c498-278">Row versioning</span></span>  
  
     <span data-ttu-id="6c498-279">啟用以資料列版本設定為基礎的隔離等級之後，「 [!INCLUDE[ssDE](../includes/ssde-md.md)] 」會維護每一個修改過的資料列的版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-279">When a row versioning-based isolation level is enabled, the [!INCLUDE[ssDE](../includes/ssde-md.md)] maintains versions of each row that is modified.</span></span> <span data-ttu-id="6c498-280">應用程式可指定交易使用資料列版本，來檢視交易或查詢開始時已存在的資料，而不是以鎖定來保護所有讀取。</span><span class="sxs-lookup"><span data-stu-id="6c498-280">Applications can specify that a transaction use the row versions to view data as it existed at the start of the transaction or query instead of protecting all reads with locks.</span></span> <span data-ttu-id="6c498-281">透過使用資料列版本設定，讀取作業封鎖其他交易的機會可大幅降低。</span><span class="sxs-lookup"><span data-stu-id="6c498-281">By using row versioning, the chance that a read operation will block other transactions is greatly reduced.</span></span>  
  
 <span data-ttu-id="6c498-282">鎖定和資料列版本設定可防止使用者讀取尚未認可的資料，以及防止多個使用者同時變更同一筆資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-282">Locking and row versioning prevent users from reading uncommitted data and prevent multiple users from attempting to change the same data at the same time.</span></span> <span data-ttu-id="6c498-283">若未使用鎖定或資料列版本設定，則對資料執行查詢時，可能會傳回尚未在資料庫中認可的資料，因而產生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="6c498-283">Without locking or row versioning, queries executed against that data could produce unexpected results by returning data that has not yet been committed in the database.</span></span>  
  
 <span data-ttu-id="6c498-284">應用程式可以選擇交易隔離等級，用於定義交易的保護層級，以免被其他交易修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-284">Applications can choose transaction isolation levels, which define the level of protection for the transaction from modifications made by other transactions.</span></span> <span data-ttu-id="6c498-285">另可對個別 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式指定資料表層級提示，進一步修改行為，以符合應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="6c498-285">Table-level hints can be specified for individual [!INCLUDE[tsql](../includes/tsql-md.md)] statements to further tailor behavior to fit the requirements of the application.</span></span>  
  
### <a name="managing-concurrent-data-access"></a><span data-ttu-id="6c498-286">管理並行資料存取</span><span class="sxs-lookup"><span data-stu-id="6c498-286">Managing Concurrent Data Access</span></span>  

 <span data-ttu-id="6c498-287">多個使用者同時存取同一個資源可稱為並行存取資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-287">Users who access a resource at the same time are said to be accessing the resource concurrently.</span></span> <span data-ttu-id="6c498-288">並行資料存取需要一些機制，以防止多個使用者同時嘗試修改其他使用者目前正在使用的資源所造成的不利影響。</span><span class="sxs-lookup"><span data-stu-id="6c498-288">Concurrent data access requires mechanisms to prevent adverse effects when multiple users try to modify resources that other users are actively using.</span></span>  
  
#### <a name="concurrency-effects"></a><span data-ttu-id="6c498-289">並行效果</span><span class="sxs-lookup"><span data-stu-id="6c498-289">Concurrency Effects</span></span>  

 <span data-ttu-id="6c498-290">使用者修改資料會影響到同時正在讀取或修改相同資料的其他使用者。</span><span class="sxs-lookup"><span data-stu-id="6c498-290">Users modifying data can affect other users who are reading or modifying the same data at the same time.</span></span> <span data-ttu-id="6c498-291">而我們就稱這些使用者正在並行地存取資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-291">These users are said to be accessing the data concurrently.</span></span> <span data-ttu-id="6c498-292">若資料儲存系統沒有並行控制功能，使用者會看到下列副作用：</span><span class="sxs-lookup"><span data-stu-id="6c498-292">If a data storage system has no concurrency control, users could see the following side effects:</span></span>  
  
-   <span data-ttu-id="6c498-293">更新遺失</span><span class="sxs-lookup"><span data-stu-id="6c498-293">Lost updates</span></span>  
  
     <span data-ttu-id="6c498-294">如果二或多個交易選取相同資料列，接著又根據原先選取的值來更新資料列時，就會發生更新遺失的情形。</span><span class="sxs-lookup"><span data-stu-id="6c498-294">Lost updates occur when two or more transactions select the same row and then update the row based on the value originally selected.</span></span> <span data-ttu-id="6c498-295">每個交易並不知道有其他的交易存在。</span><span class="sxs-lookup"><span data-stu-id="6c498-295">Each transaction is unaware of the other transactions.</span></span> <span data-ttu-id="6c498-296">因此最後的更新會覆寫其他交易所做的更新，而造成資料遺失。</span><span class="sxs-lookup"><span data-stu-id="6c498-296">The last update overwrites updates made by the other transactions, which results in lost data.</span></span>  
  
     <span data-ttu-id="6c498-297">例如，兩位編輯人員對同一份文件製作了電子副本。</span><span class="sxs-lookup"><span data-stu-id="6c498-297">For example, two editors make an electronic copy of the same document.</span></span> <span data-ttu-id="6c498-298">這兩位編輯人員各自進行修改並儲存變更後的副本，覆寫了原始文件。</span><span class="sxs-lookup"><span data-stu-id="6c498-298">Each editor changes the copy independently and then saves the changed copy thereby overwriting the original document.</span></span> <span data-ttu-id="6c498-299">最後儲存已變更副本的編輯人員會覆寫前一位編輯人員所做的變更。</span><span class="sxs-lookup"><span data-stu-id="6c498-299">The editor who saves the changed copy last overwrites the changes made by the other editor.</span></span> <span data-ttu-id="6c498-300">若第一位編輯人員完成和認可交易後才讓第二位編輯人員存取檔案的話，就能避免這個問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-300">This problem could be avoided if one editor could not access the file until the other editor had finished and committed the transaction.</span></span>  
  
-   <span data-ttu-id="6c498-301">未認可依存性 (中途讀取)</span><span class="sxs-lookup"><span data-stu-id="6c498-301">Uncommitted dependency (dirty read)</span></span>  
  
     <span data-ttu-id="6c498-302">第二筆交易選擇的資料列已經被其他交易更新時，會發生未認可依存性 (Uncommitted Dependency)。</span><span class="sxs-lookup"><span data-stu-id="6c498-302">Uncommitted dependency occurs when a second transaction selects a row that is being updated by another transaction.</span></span> <span data-ttu-id="6c498-303">此時，第二筆交易讀取的是尚未認可且可能被更新資料列的交易變更之資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-303">The second transaction is reading data that has not been committed yet and may be changed by the transaction updating the row.</span></span>  
  
     <span data-ttu-id="6c498-304">例如，有一位編輯人員正在修改一份電子文件。</span><span class="sxs-lookup"><span data-stu-id="6c498-304">For example, an editor is making changes to an electronic document.</span></span> <span data-ttu-id="6c498-305">進行變更時，第二位編輯人員複製了包含目前所有變更的文件，並將文件散發給預期的讀者。</span><span class="sxs-lookup"><span data-stu-id="6c498-305">During the changes, a second editor takes a copy of the document that includes all the changes made so far, and distributes the document to the intended audience.</span></span> <span data-ttu-id="6c498-306">此時，第一位編輯人員認為截至目前的變更均有誤，所以移除了原先的變更後儲存文件。</span><span class="sxs-lookup"><span data-stu-id="6c498-306">The first editor then decides the changes made so far are wrong and removes the edits and saves the document.</span></span> <span data-ttu-id="6c498-307">散發的文件包含了一些現在已不存在的修改內容，而且這些修改應該視為從未發生過。</span><span class="sxs-lookup"><span data-stu-id="6c498-307">The distributed document contains edits that no longer exist and should be treated as if they never existed.</span></span> <span data-ttu-id="6c498-308">如果能在第一位編輯人員儲存最後修改並認可交易後才允許其他人讀取修改過的文件，即可避免這個問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-308">This problem could be avoided if no one could read the changed document until the first editor does the final save of modifications and commits the transaction.</span></span>  
  
-   <span data-ttu-id="6c498-309">分析不一致 (不可重複讀取)</span><span class="sxs-lookup"><span data-stu-id="6c498-309">Inconsistent analysis (nonrepeatable read)</span></span>  
  
     <span data-ttu-id="6c498-310">第二筆交易存取同一資料列數次，且每次讀取的資料內容都有變動時，就會產生不一致分析 (Inconsistent Analysis)。</span><span class="sxs-lookup"><span data-stu-id="6c498-310">Inconsistent analysis occurs when a second transaction accesses the same row several times and reads different data each time.</span></span> <span data-ttu-id="6c498-311">不一致分析的情況是第一筆交易在變更資料時，第二筆交易卻在讀取這些資料，其發生原理與未認可依存性類似。</span><span class="sxs-lookup"><span data-stu-id="6c498-311">Inconsistent analysis is similar to uncommitted dependency in that another transaction is changing the data that a second transaction is reading.</span></span> <span data-ttu-id="6c498-312">但是在不一致分析中，第二筆交易讀取的資料是由進行變更的交易認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-312">However, in inconsistent analysis, the data read by the second transaction was committed by the transaction that made the change.</span></span> <span data-ttu-id="6c498-313">此外，不一致分析包括同一資料列的多次讀取 (兩次或以上)，且每次資訊均被其他交易變更，因此稱為不可重複讀取 (Nonrepeatable Read)。</span><span class="sxs-lookup"><span data-stu-id="6c498-313">Also, inconsistent analysis involves multiple reads (two or more) of the same row, and each time the information is changed by another transaction; thus, the term nonrepeatable read.</span></span>  
  
     <span data-ttu-id="6c498-314">例如，一位編輯人員兩次都讀取了相同的文件，但是在兩次讀取期間寫作人員重寫了文件。</span><span class="sxs-lookup"><span data-stu-id="6c498-314">For example, an editor reads the same document twice, but between each reading the writer rewrites the document.</span></span> <span data-ttu-id="6c498-315">因此在編輯者第二次讀取文件時，文件已經變更。</span><span class="sxs-lookup"><span data-stu-id="6c498-315">When the editor reads the document for the second time, it has changed.</span></span> <span data-ttu-id="6c498-316">而原始讀取是不可重複的。</span><span class="sxs-lookup"><span data-stu-id="6c498-316">The original read was not repeatable.</span></span> <span data-ttu-id="6c498-317">若能在編輯人員讀完文件後才讓寫作人員變更，就能避免這個問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-317">This problem could be avoided if the writer could not change the document until the editor has finished reading it for the last time.</span></span>  
  
-   <span data-ttu-id="6c498-318">虛設項目讀取</span><span class="sxs-lookup"><span data-stu-id="6c498-318">Phantom reads</span></span>  
  
     <span data-ttu-id="6c498-319">虛設項目讀取是指當您執行兩個完全相同的查詢，但第二個查詢所傳回的資料列集合不同時所發生的情況。</span><span class="sxs-lookup"><span data-stu-id="6c498-319">A phantom read is a situation that occurs when two identical queries are executed and the collection of rows returned by the second query is different.</span></span> <span data-ttu-id="6c498-320">下列範例會顯示可能發生這種情況的作業方式。</span><span class="sxs-lookup"><span data-stu-id="6c498-320">The example below shows how this may occur.</span></span> <span data-ttu-id="6c498-321">假設下列兩筆交易都同時執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-321">Assume the two transactions below are executing at the same time.</span></span> <span data-ttu-id="6c498-322">第一筆交易中的兩個 SELECT 陳述式可能會傳回不同的結果，因為第二筆交易中的 INSERT 陳述式變更了這兩筆交易所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-322">The two SELECT statements in the first transaction may return different results because the INSERT statement in the second transaction changes the data used by both.</span></span>  
  
    ```sql  
    --Transaction 1  
    BEGIN TRAN;  
    SELECT ID FROM dbo.employee  
    WHERE ID > 5 and ID < 10;  
    --The INSERT statement from the second transaction occurs here.  
    SELECT ID FROM dbo.employee  
    WHERE ID > 5 and ID < 10;  
    COMMIT;  
    ```  
  
    ```sql  
    --Transaction 2  
    BEGIN TRAN;  
    INSERT INTO dbo.employee  
       SET name = 'New' WHERE ID = 5;  
    COMMIT;   
    ```  
  
-   <span data-ttu-id="6c498-323">資料列更新造成遺漏讀取和重複讀取</span><span class="sxs-lookup"><span data-stu-id="6c498-323">Missing and double reads caused by row updates</span></span>  
  
    -   <span data-ttu-id="6c498-324">遺漏更新的資料列或多次看到更新的資料列</span><span class="sxs-lookup"><span data-stu-id="6c498-324">Missing a updated row or seeing an updated row multiple times</span></span>  
  
         <span data-ttu-id="6c498-325">執行 READ UNCOMMITTED 等級的交易不會發出共用鎖定來防止其他交易修改目前交易所讀取的資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-325">Transactions that are running at the READ UNCOMMITTED level do not issue shared locks to prevent other transactions from modifying data read by the current transaction.</span></span> <span data-ttu-id="6c498-326">執行 READ COMMITTED 等級的交易則會發出共用鎖定，但是在讀取資料列後，就會解除資料列或頁面的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-326">Transactions that are running at the READ COMMITTED level do issue shared locks, but the row or page locks are released after the row is read.</span></span> <span data-ttu-id="6c498-327">在以上任一種情況下，當您掃描索引時，如果其他使用者變更了您讀取期間之資料列的索引鍵資料行，在索引鍵變更將資料列移到掃描前的任何位置後，該資料列可能會再次出現。</span><span class="sxs-lookup"><span data-stu-id="6c498-327">In either case, when you are scanning an index, if another user changes the index key column of the row during your read, the row might appear again if the key change moved the row to a position ahead of your scan.</span></span> <span data-ttu-id="6c498-328">同樣地，如果索引鍵變更將資料列移到您已經讀取之索引中的位置，該資料列可能就不會出現。</span><span class="sxs-lookup"><span data-stu-id="6c498-328">Similarly, the row might not appear if the key change moved the row to a position in the index that you had already read.</span></span> <span data-ttu-id="6c498-329">若要避免這個情況發生，請使用 SERIALIZABLE 或 HOLDLOCK 提示，或資料列版本設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-329">To avoid this, use the SERIALIZABLE or HOLDLOCK hint, or row versioning.</span></span> <span data-ttu-id="6c498-330">如需詳細資訊，請參閱[資料表提示 &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)。</span><span class="sxs-lookup"><span data-stu-id="6c498-330">For more information, see [Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table).</span></span>  
  
    -   <span data-ttu-id="6c498-331">遺失一或多個非更新目標的資料列</span><span class="sxs-lookup"><span data-stu-id="6c498-331">Missing one or more rows that were not the target of update</span></span>  
  
         <span data-ttu-id="6c498-332">當您正在使用 READ UNCOMMITTED 時，如果您的查詢使用配置順序掃描 (使用 IAM 頁面) 讀取資料列，您可能會因為其他交易造成頁面分割而遺失資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-332">When you are using READ UNCOMMITTED, if your query reads rows using an allocation order scan (using IAM pages), you might miss rows if another transaction is causing a page split.</span></span> <span data-ttu-id="6c498-333">當您使用認可的讀取時，不會發生這個狀況，因為頁面分割期間會將資料表保持在鎖定狀態下，而且，如果資料表沒有叢集索引，也不會發生這個狀況，因為更新不會造成頁面分割。</span><span class="sxs-lookup"><span data-stu-id="6c498-333">This cannot occur when you are using read committed because a table lock is held during a page split and does not happen if the table does not have a clustered index, because updates do not cause page splits.</span></span>  
  
#### <a name="types-of-concurrency"></a><span data-ttu-id="6c498-334">並行的類型</span><span class="sxs-lookup"><span data-stu-id="6c498-334">Types of Concurrency</span></span>  

 <span data-ttu-id="6c498-335">當有許多人會同時嘗試修改資料庫中的資料時，必須實作一個控制系統，這樣某一個人所做的修改才不會嚴重影響到另一個人所做的修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-335">When many people attempt to modify data in a database at the same time, a system of controls must be implemented so that modifications made by one person do not adversely affect those of another person.</span></span> <span data-ttu-id="6c498-336">這就叫做並行控制。</span><span class="sxs-lookup"><span data-stu-id="6c498-336">This is called concurrency control.</span></span>  
  
 <span data-ttu-id="6c498-337">並行控制理論將制定並行控制的方法分為二類：</span><span class="sxs-lookup"><span data-stu-id="6c498-337">Concurrency control theory has two classifications for the methods of instituting concurrency control:</span></span>  
  
-   <span data-ttu-id="6c498-338">悲觀並行控制</span><span class="sxs-lookup"><span data-stu-id="6c498-338">Pessimistic concurrency control</span></span>  
  
     <span data-ttu-id="6c498-339">鎖定系統可防止使用者以會影響其他使用者的方法來修改資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-339">A system of locks prevents users from modifying data in a way that affects other users.</span></span> <span data-ttu-id="6c498-340">使用者在執行某個動作而造成套用鎖定之後，其他使用者就不能執行會與該鎖定衝突的動作，直到擁有者解除鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-340">After a user performs an action that causes a lock to be applied, other users cannot perform actions that would conflict with the lock until the owner releases it.</span></span> <span data-ttu-id="6c498-341">這就叫做封閉式並行控制，因為這種方法主要是用在高度競爭資料的環境中，以鎖定方式來保護資料的成本，會低於發生並行衝突時回復交易的成本。</span><span class="sxs-lookup"><span data-stu-id="6c498-341">This is called pessimistic control because it is mainly used in environments where there is high contention for data, where the cost of protecting data with locks is less than the cost of rolling back transactions if concurrency conflicts occur.</span></span>  
  
-   <span data-ttu-id="6c498-342">樂觀並行控制</span><span class="sxs-lookup"><span data-stu-id="6c498-342">Optimistic concurrency control</span></span>  
  
     <span data-ttu-id="6c498-343">在開放式並行控制中，使用者在讀取資料時，不會將資料鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-343">In optimistic concurrency control, users do not lock data when they read it.</span></span> <span data-ttu-id="6c498-344">當使用者更新資料時，系統會查看在讀取資料之後，是否有其他使用者變更了該資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-344">When a user updates data, the system checks to see if another user changed the data after it was read.</span></span> <span data-ttu-id="6c498-345">若有其他使用者更新了該資料，就會產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="6c498-345">If another user updated the data, an error is raised.</span></span> <span data-ttu-id="6c498-346">一般而言，收到錯誤的使用者會回復交易，並重新開始。</span><span class="sxs-lookup"><span data-stu-id="6c498-346">Typically, the user receiving the error rolls back the transaction and starts over.</span></span> <span data-ttu-id="6c498-347">這就叫做開放式並行控制，因為這種方法主要是用在低度競爭資料的環境中，偶爾回復交易的成本會低於讀取時鎖定資料的成本。</span><span class="sxs-lookup"><span data-stu-id="6c498-347">This is called optimistic because it is mainly used in environments where there is low contention for data, and where the cost of occasionally rolling back a transaction is lower than the cost of locking data when read.</span></span>  
  
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="6c498-348">支援並行控制的範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-348">supports a range of concurrency control.</span></span> <span data-ttu-id="6c498-349">使用者可針對連接來選取交易隔離等級，或是在資料指標上選取並行選項，以指定並行控制的類型。</span><span class="sxs-lookup"><span data-stu-id="6c498-349">Users specify the type of concurrency control by selecting transaction isolation levels for connections or concurrency options on cursors.</span></span> <span data-ttu-id="6c498-350">這些屬性可用 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式來定義，或是透過資料庫應用程式開發介面 (API) (例如 ADO、ADO.NET、OLE DB 及 ODBC) 的內容及屬性來定義。</span><span class="sxs-lookup"><span data-stu-id="6c498-350">These attributes can be defined using [!INCLUDE[tsql](../includes/tsql-md.md)] statements, or through the properties and attributes of database application programming interfaces (APIs) such as ADO, ADO.NET, OLE DB, and ODBC.</span></span>  
  
#### <a name="isolation-levels-in-the-database-engine"></a><span data-ttu-id="6c498-351">Database Engine 中的隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-351">Isolation Levels in the Database Engine</span></span>  

 <span data-ttu-id="6c498-352">交易可指定隔離等級，以定義某個交易必須與其他交易所修改之資源或資料隔離的程度。</span><span class="sxs-lookup"><span data-stu-id="6c498-352">Transactions specify an isolation level that defines the degree to which one transaction must be isolated from resource or data modifications made by other transactions.</span></span> <span data-ttu-id="6c498-353">隔離等級是以並行副作用來表示，例如，允許中途讀取 (dirty read) 或虛設項目讀取 (phantom read)。</span><span class="sxs-lookup"><span data-stu-id="6c498-353">Isolation levels are described in terms of which concurrency side-effects, such as dirty reads or phantom reads, are allowed.</span></span>  
  
 <span data-ttu-id="6c498-354">交易隔離等級控制：</span><span class="sxs-lookup"><span data-stu-id="6c498-354">Transaction isolation levels control:</span></span>  
  
-   <span data-ttu-id="6c498-355">在讀取資料時是否採用鎖定，以及要求哪一類型的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-355">Whether locks are taken when data is read, and what type of locks are requested.</span></span>  
  
-   <span data-ttu-id="6c498-356">保留讀取鎖定的時間長度。</span><span class="sxs-lookup"><span data-stu-id="6c498-356">How long the read locks are held.</span></span>  
  
-   <span data-ttu-id="6c498-357">讀取作業是否參考另一個交易修改的資料列：</span><span class="sxs-lookup"><span data-stu-id="6c498-357">Whether a read operation referencing rows modified by another transaction:</span></span>  
  
    -   <span data-ttu-id="6c498-358">封鎖資料列上的獨佔鎖定直到釋放它為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-358">Blocks until the exclusive lock on the row is freed.</span></span>  
  
    -   <span data-ttu-id="6c498-359">擷取在啟動陳述式或交易時即存在的資料列認可版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-359">Retrieves the committed version of the row that existed at the time the statement or transaction started.</span></span>  
  
    -   <span data-ttu-id="6c498-360">讀取未認可的資料修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-360">Reads the uncommitted data modification.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="6c498-361">選擇交易隔離等級並不會影響為保護資料修改所取得的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-361">Choosing a transaction isolation level does not affect the locks acquired to protect data modifications.</span></span> <span data-ttu-id="6c498-362">交易永遠都會取得它所修改之資料的獨佔鎖定，並保留該鎖定直到交易完成為止，不論為該交易所設定的隔離等級為何皆同。</span><span class="sxs-lookup"><span data-stu-id="6c498-362">A transaction always gets an exclusive lock on any data it modifies, and holds that lock until the transaction completes, regardless of the isolation level set for that transaction.</span></span> <span data-ttu-id="6c498-363">對於讀取作業，交易隔離等級主要是定義對於其他交易所做修改之影響的保謢等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-363">For read operations, transaction isolation levels primarily define the level of protection from the effects of modifications made by other transactions.</span></span>  
  
 <span data-ttu-id="6c498-364">較低的隔離等級將可讓更多的使用者同時存取資料，但也會增加使用者可能遇到並行作用 (例如，中途讀取或遺失的更新) 的數目。</span><span class="sxs-lookup"><span data-stu-id="6c498-364">A lower isolation level increases the ability of many users to access data at the same time, but increases the number of concurrency effects (such as dirty reads or lost updates) users might encounter.</span></span> <span data-ttu-id="6c498-365">相反的，較高的隔離等級將可減少使用者遇到並行作用的類型，但是將需要更多的系統資源並且會增加一個交易封鎖另一個交易的可能性。</span><span class="sxs-lookup"><span data-stu-id="6c498-365">Conversely, a higher isolation level reduces the types of concurrency effects that users may encounter, but requires more system resources and increases the chances that one transaction will block another.</span></span> <span data-ttu-id="6c498-366">選擇適當的隔離等級需視應用程式的資料完整性需求與每個隔離等級的額外負荷平衡而定。</span><span class="sxs-lookup"><span data-stu-id="6c498-366">Choosing the appropriate isolation level depends on balancing the data integrity requirements of the application against the overhead of each isolation level.</span></span> <span data-ttu-id="6c498-367">最高的隔離等級為可序列化，可確保每次交易重複讀取作業時都能擷取相同的資料，但它是透過執行鎖定層級來達成此目的，因此在多使用者系統中有可能會影響其他使用者。</span><span class="sxs-lookup"><span data-stu-id="6c498-367">The highest isolation level, serializable, guarantees that a transaction will retrieve exactly the same data every time it repeats a read operation, but it does this by performing a level of locking that is likely to impact other users in multi-user systems.</span></span> <span data-ttu-id="6c498-368">最低隔離等級為讀取未認可，可能會擷取到其他交易已修改但尚未認可的資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-368">The lowest isolation level, read uncommitted, may retrieve data that has been modified but not committed by other transactions.</span></span> <span data-ttu-id="6c498-369">在讀取未認可中可能會發生所有的並行副作用，但由於沒有讀取鎖定或版本控制，因此可將額外負荷降到最低。</span><span class="sxs-lookup"><span data-stu-id="6c498-369">All of the concurrency side effects can happen in read uncommitted, but there is no read locking or versioning, so overhead is minimized.</span></span>  
  
##### <a name="database-engine-isolation-levels"></a><span data-ttu-id="6c498-370">Database Engine 隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-370">Database Engine Isolation Levels</span></span>  

 <span data-ttu-id="6c498-371">ISO 標準會定義以下隔離等級， [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]支援所有的這些隔離等級：</span><span class="sxs-lookup"><span data-stu-id="6c498-371">The ISO standard defines the following isolation levels, all of which are supported by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]:</span></span>  
  
|<span data-ttu-id="6c498-372">隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-372">Isolation Level</span></span>|<span data-ttu-id="6c498-373">定義</span><span class="sxs-lookup"><span data-stu-id="6c498-373">Definition</span></span>|  
|---------------------|----------------|  
|<span data-ttu-id="6c498-374">讀取未認可</span><span class="sxs-lookup"><span data-stu-id="6c498-374">Read uncommitted</span></span>|<span data-ttu-id="6c498-375">最低隔離等級，隔離交易僅能確保不會讀取已實體損毀的資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-375">The lowest isolation level where transactions are isolated only enough to ensure that physically corrupt data is not read.</span></span> <span data-ttu-id="6c498-376">這種等級下允許中途讀取，所以任何交易可能看得到其他交易所做的尚未認可變更。</span><span class="sxs-lookup"><span data-stu-id="6c498-376">In this level, dirty reads are allowed, so one transaction may see not-yet-committed changes made by other transactions.</span></span>|  
|<span data-ttu-id="6c498-377">讀取認可</span><span class="sxs-lookup"><span data-stu-id="6c498-377">Read committed</span></span>|<span data-ttu-id="6c498-378">允許交易對另一筆交易先前讀取 (未修改) 的資料進行讀取，而不必等待前一筆交易完成。</span><span class="sxs-lookup"><span data-stu-id="6c498-378">Allows a transaction to read data previously read (not modified) by another transaction without waiting for the first transaction to complete.</span></span> <span data-ttu-id="6c498-379">[!INCLUDE[ssDE](../includes/ssde-md.md)] 將維持寫入鎖定 (取自於選取的資料) 直到交易結束，但讀取鎖定會在 SELECT 作業一經執行時即釋放。</span><span class="sxs-lookup"><span data-stu-id="6c498-379">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps write locks (acquired on selected data) until the end of the transaction, but read locks are released as soon as the SELECT operation is performed.</span></span> <span data-ttu-id="6c498-380">這是 [!INCLUDE[ssDE](../includes/ssde-md.md)] 預設等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-380">This is the [!INCLUDE[ssDE](../includes/ssde-md.md)] default level.</span></span>|  
|<span data-ttu-id="6c498-381">可重複讀取</span><span class="sxs-lookup"><span data-stu-id="6c498-381">Repeatable read</span></span>|<span data-ttu-id="6c498-382">[!INCLUDE[ssDE](../includes/ssde-md.md)] 將維持讀取及寫入鎖定 (取自於選取的資料) 直到交易結束。</span><span class="sxs-lookup"><span data-stu-id="6c498-382">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps read and write locks that are acquired on selected data until the end of the transaction.</span></span> <span data-ttu-id="6c498-383">不過由於範圍鎖定未受管理，便有可能發生虛設項目讀取。</span><span class="sxs-lookup"><span data-stu-id="6c498-383">However, because range-locks are not managed, phantom reads can occur.</span></span>|  
|<span data-ttu-id="6c498-384">可序列化</span><span class="sxs-lookup"><span data-stu-id="6c498-384">Serializable</span></span>|<span data-ttu-id="6c498-385">最高的等級，使交易完全與其他交易隔離。</span><span class="sxs-lookup"><span data-stu-id="6c498-385">The highest level where transactions are completely isolated from one another.</span></span> <span data-ttu-id="6c498-386">[!INCLUDE[ssDE](../includes/ssde-md.md)] 將維持讀取及寫入鎖定 (取自於選取的資料) 至交易結束予以釋放為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-386">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps read and write locks acquired on selected data to be released at the end of the transaction.</span></span> <span data-ttu-id="6c498-387">當 SELECT 作業使用界定範圍的 WHERE 子句時，就會取得範圍鎖定以特意避免虛設項目讀取。</span><span class="sxs-lookup"><span data-stu-id="6c498-387">Range-locks are acquired when a SELECT operation uses a ranged WHERE clause, especially to avoid phantom reads.</span></span><br /><br /> <span data-ttu-id="6c498-388">**注意：** 當您要求可序列化隔離等級時，複寫資料表上的 DDL 作業和交易可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="6c498-388">**Note:** DDL operations and transactions on replicated tables may fail when serializable isolation level is requested.</span></span> <span data-ttu-id="6c498-389">這是因為複寫查詢所使用的提示可能與可序列化隔離等級不相容。</span><span class="sxs-lookup"><span data-stu-id="6c498-389">This is because replication queries use hints that may be incompatible with serializable isolation level.</span></span>|  
  
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="6c498-390">也支援另外兩種使用資料列版本設定的交易隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-390">also supports two additional transaction isolation levels that use row versioning.</span></span> <span data-ttu-id="6c498-391">其一是讀取認可隔離的實作，而另一種交易隔離等級則是快照。</span><span class="sxs-lookup"><span data-stu-id="6c498-391">One is an implementation of read committed isolation, and one is a transaction isolation level, snapshot.</span></span>  
  
|<span data-ttu-id="6c498-392">資料列版本設定隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-392">Row Versioning Isolation Level</span></span>|<span data-ttu-id="6c498-393">定義</span><span class="sxs-lookup"><span data-stu-id="6c498-393">Definition</span></span>|  
|------------------------------------|----------------|  
|<span data-ttu-id="6c498-394">讀取認可快照</span><span class="sxs-lookup"><span data-stu-id="6c498-394">Read Committed Snapshot</span></span>|<span data-ttu-id="6c498-395">當 READ_COMMITTED_SNAPSHOT 資料庫選項設為 ON 時，讀取認可隔離會使用資料列版本設定以提供陳述式層級的讀取一致性。</span><span class="sxs-lookup"><span data-stu-id="6c498-395">When the READ_COMMITTED_SNAPSHOT database option is set ON, read committed isolation uses row versioning to provide statement-level read consistency.</span></span> <span data-ttu-id="6c498-396">讀取作業只需要 SCH-S 資料表層級的鎖定，並不需要頁面或資料列的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-396">Read operations require only SCH-S table level locks and no page or row locks.</span></span> <span data-ttu-id="6c498-397">也就是說，Database Engine 會利用資料列版本設定，依照資料在陳述式開始時存在的狀態，為每個陳述式提供該資料具有交易一致性的快照。</span><span class="sxs-lookup"><span data-stu-id="6c498-397">That is, the Database Engine uses row versioning to present each statement with a transactionally consistent snapshot of the data as it existed at the start of the statement.</span></span> <span data-ttu-id="6c498-398">鎖定的使用目的不是為了防止其他交易更新資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-398">Locks are not used to protect the data from updates by other transactions.</span></span> <span data-ttu-id="6c498-399">使用者定義的函數可傳回在包含 UDF 的陳述式開始之後所認可的資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-399">A user-defined function can return data that was committed after the time the statement containing the UDF began.</span></span><br /><br /> <span data-ttu-id="6c498-400">當 READ_COMMITTED_SNAPSHOT 資料庫選項設為 OFF (預設值) 時，讀取認可隔離會在目前交易正執行讀取作業期間，利用共用鎖定來防止其他交易修改資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-400">When the READ_COMMITTED_SNAPSHOT database option is set OFF, which is the default setting, read committed isolation uses shared locks to prevent other transactions from modifying rows while the current transaction is running a read operation.</span></span> <span data-ttu-id="6c498-401">共用鎖定也會封鎖陳述式，使它們在其他交易完成之前，無法讀取其他交易所修改的資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-401">The shared locks also block the statement from reading rows modified by other transactions until the other transaction is completed.</span></span> <span data-ttu-id="6c498-402">這兩種實作都符合讀取認可隔離的 ISO 定義。</span><span class="sxs-lookup"><span data-stu-id="6c498-402">Both implementations meet the ISO definition of read committed isolation.</span></span>|  
|<span data-ttu-id="6c498-403">快照式</span><span class="sxs-lookup"><span data-stu-id="6c498-403">Snapshot</span></span>|<span data-ttu-id="6c498-404">快照隔離等級使用資料列版本設定來提供交易層級的讀取一致性。</span><span class="sxs-lookup"><span data-stu-id="6c498-404">The snapshot isolation level uses row versioning to provide transaction-level read consistency.</span></span> <span data-ttu-id="6c498-405">讀取作業並不需要頁面或資料列的鎖定，只需要 SCH-S 資料表鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-405">Read operations acquire no page or row locks; only SCH-S table locks are acquired.</span></span> <span data-ttu-id="6c498-406">當讀取其他交易所修改的資料列時，它們會擷取在啟動交易時就已經存在的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-406">When reading rows modified by another transaction, they retrieve the version of the row that existed when the transaction started.</span></span> <span data-ttu-id="6c498-407">只有當 ALLOW_SNAPSHOT_ISOLATION 資料庫選項設定為 ON 時，您才能針對資料庫使用快照集隔離。</span><span class="sxs-lookup"><span data-stu-id="6c498-407">You can only use Snapshot isolation against a database when the ALLOW_SNAPSHOT_ISOLATION database option is set ON.</span></span> <span data-ttu-id="6c498-408">根據預設，使用者資料庫的此選項為 OFF。</span><span class="sxs-lookup"><span data-stu-id="6c498-408">By default, this option is set OFF for user databases.</span></span><br /><br /> <span data-ttu-id="6c498-409">**注意：** [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 不支援中繼資料版本設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-409">**Note:**  [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not support versioning of metadata.</span></span> <span data-ttu-id="6c498-410">因此，哪些 DDL 作業可以在快照隔離之下執行的明確交易中執行會有一些限制。</span><span class="sxs-lookup"><span data-stu-id="6c498-410">For this reason, there are restrictions on what DDL operations can be performed in an explicit transaction that is running under snapshot isolation.</span></span> <span data-ttu-id="6c498-411">在 BEGIN TRANSACTION 陳述式之後，不允許在快照隔離下執行下列 DDL 陳述式：ALTER TABLE、CREATE INDEX、CREATE XML INDEX、ALTER INDEX、DROP INDEX、DBCC REINDEX、ALTER PARTITION FUNCTION、ALTER PARTITION SCHEME 或是任何通用語言執行平台 (CLR) DDL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-411">The following DDL statements are not permitted under snapshot isolation after a BEGIN TRANSACTION statement: ALTER TABLE, CREATE INDEX, CREATE XML INDEX, ALTER INDEX, DROP INDEX, DBCC REINDEX, ALTER PARTITION FUNCTION, ALTER PARTITION SCHEME, or any common language runtime (CLR) DDL statement.</span></span> <span data-ttu-id="6c498-412">在隱含交易內使用快照集隔離時，這些陳述式會受到允許。</span><span class="sxs-lookup"><span data-stu-id="6c498-412">These statements are permitted when you are using snapshot isolation within implicit transactions.</span></span> <span data-ttu-id="6c498-413">就定義而言，隱含交易是一種單一陳述式，可強制使用快照隔離的語意 (即使是 DDL 陳述式)。</span><span class="sxs-lookup"><span data-stu-id="6c498-413">An implicit transaction, by definition, is a single statement that makes it possible to enforce the semantics of snapshot isolation, even with DDL statements.</span></span> <span data-ttu-id="6c498-414">違反這個原則可能會造成錯誤 3961：「資料庫 '%.\*ls' 中的快照集隔離交易失敗，因為這個交易啟動之後，另一個並行交易的 DDL 陳述式修改了此陳述式存取的物件。</span><span class="sxs-lookup"><span data-stu-id="6c498-414">Violations of this principle can cause error 3961: "Snapshot isolation transaction failed in database '%.\*ls' because the object accessed by the statement has been modified by a DDL statement in another concurrent transaction since the start of this transaction.</span></span> <span data-ttu-id="6c498-415">這是不允許的，因為中繼資料並未建立版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-415">It is not allowed because the metadata is not versioned.</span></span> <span data-ttu-id="6c498-416">如果在快照集隔離下並行更新中繼資料，將會造成不一致的問題。」</span><span class="sxs-lookup"><span data-stu-id="6c498-416">A concurrent update to metadata could lead to inconsistency if mixed with snapshot isolation."</span></span>|  
  
 <span data-ttu-id="6c498-417">下表顯示不同隔離等級所啟用的並行副作用。</span><span class="sxs-lookup"><span data-stu-id="6c498-417">The following table shows the concurrency side effects enabled by the different isolation levels.</span></span>  
  
|<span data-ttu-id="6c498-418">隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-418">Isolation level</span></span>|<span data-ttu-id="6c498-419">中途讀取 (Dirty read)</span><span class="sxs-lookup"><span data-stu-id="6c498-419">Dirty read</span></span>|<span data-ttu-id="6c498-420">非可重複讀取</span><span class="sxs-lookup"><span data-stu-id="6c498-420">Nonrepeatable read</span></span>|<span data-ttu-id="6c498-421">虛設項目 (Phantom)</span><span class="sxs-lookup"><span data-stu-id="6c498-421">Phantom</span></span>|  
|---------------------|----------------|------------------------|-------------|  
|<span data-ttu-id="6c498-422">**讀取未認可**</span><span class="sxs-lookup"><span data-stu-id="6c498-422">**Read uncommitted**</span></span>|<span data-ttu-id="6c498-423">是</span><span class="sxs-lookup"><span data-stu-id="6c498-423">Yes</span></span>|<span data-ttu-id="6c498-424">是</span><span class="sxs-lookup"><span data-stu-id="6c498-424">Yes</span></span>|<span data-ttu-id="6c498-425">是</span><span class="sxs-lookup"><span data-stu-id="6c498-425">Yes</span></span>|  
|<span data-ttu-id="6c498-426">**讀取認可**</span><span class="sxs-lookup"><span data-stu-id="6c498-426">**Read committed**</span></span>|<span data-ttu-id="6c498-427">否</span><span class="sxs-lookup"><span data-stu-id="6c498-427">No</span></span>|<span data-ttu-id="6c498-428">是</span><span class="sxs-lookup"><span data-stu-id="6c498-428">Yes</span></span>|<span data-ttu-id="6c498-429">是</span><span class="sxs-lookup"><span data-stu-id="6c498-429">Yes</span></span>|  
|<span data-ttu-id="6c498-430">**可重複讀取**</span><span class="sxs-lookup"><span data-stu-id="6c498-430">**Repeatable read**</span></span>|<span data-ttu-id="6c498-431">否</span><span class="sxs-lookup"><span data-stu-id="6c498-431">No</span></span>|<span data-ttu-id="6c498-432">否</span><span class="sxs-lookup"><span data-stu-id="6c498-432">No</span></span>|<span data-ttu-id="6c498-433">是</span><span class="sxs-lookup"><span data-stu-id="6c498-433">Yes</span></span>|  
|<span data-ttu-id="6c498-434">**快照式**</span><span class="sxs-lookup"><span data-stu-id="6c498-434">**Snapshot**</span></span>|<span data-ttu-id="6c498-435">否</span><span class="sxs-lookup"><span data-stu-id="6c498-435">No</span></span>|<span data-ttu-id="6c498-436">否</span><span class="sxs-lookup"><span data-stu-id="6c498-436">No</span></span>|<span data-ttu-id="6c498-437">否</span><span class="sxs-lookup"><span data-stu-id="6c498-437">No</span></span>|  
|<span data-ttu-id="6c498-438">**可序列化**</span><span class="sxs-lookup"><span data-stu-id="6c498-438">**Serializable**</span></span>|<span data-ttu-id="6c498-439">否</span><span class="sxs-lookup"><span data-stu-id="6c498-439">No</span></span>|<span data-ttu-id="6c498-440">否</span><span class="sxs-lookup"><span data-stu-id="6c498-440">No</span></span>|<span data-ttu-id="6c498-441">否</span><span class="sxs-lookup"><span data-stu-id="6c498-441">No</span></span>|  
  
 <span data-ttu-id="6c498-442">如需詳細了解每個交易隔離等級所控制之特定類型的鎖定或資料列版本設定，請參閱 [SET TRANSACTION ISOLATION LEVEL &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-442">For more information about the specific types of locking or row versioning controlled by each transaction isolation level, see [SET TRANSACTION ISOLATION LEVEL &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-443">交易隔離等級可使用 [!INCLUDE[tsql](../includes/tsql-md.md)] 或透過資料庫 API 來設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-443">Transaction isolation levels can be set using [!INCLUDE[tsql](../includes/tsql-md.md)] or through a database API.</span></span>  
  
 [!INCLUDE[tsql](../includes/tsql-md.md)]  
 [!INCLUDE[tsql](../includes/tsql-md.md)] <span data-ttu-id="6c498-444">指令碼使用 SET TRANSACTION ISOLATION LEVEL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-444">scripts use the SET TRANSACTION ISOLATION LEVEL statement.</span></span>  
  
 <span data-ttu-id="6c498-445">ADO</span><span class="sxs-lookup"><span data-stu-id="6c498-445">ADO</span></span>  
 <span data-ttu-id="6c498-446">ADO 應用程式會將 **Connection** 物件的 `IsolationLevel` 屬性設定為 adXactReadUncommitted、adXactReadCommitted、adXactRepeatableRead 或 adXactReadSerializable。</span><span class="sxs-lookup"><span data-stu-id="6c498-446">ADO applications set the `IsolationLevel` property of the **Connection** object to adXactReadUncommitted, adXactReadCommitted, adXactRepeatableRead, or adXactReadSerializable.</span></span>  
  
 <span data-ttu-id="6c498-447">ADO.NET</span><span class="sxs-lookup"><span data-stu-id="6c498-447">ADO.NET</span></span>  
 <span data-ttu-id="6c498-448">使用 `System.Data.SqlClient` 受控命名空間的 ADO.NET 應用程式可以呼叫 `SqlConnection.BeginTransaction` 方法，並將 *IsolationLevel* 選項設定為 Unspecified、Chaos、ReadUncommitted、ReadCommitted、RepeatableRead、Serializable 及 Snapshot。</span><span class="sxs-lookup"><span data-stu-id="6c498-448">ADO.NET applications using the `System.Data.SqlClient` managed namespace can call the `SqlConnection.BeginTransaction` method and set the *IsolationLevel* option to Unspecified, Chaos, ReadUncommitted, ReadCommitted, RepeatableRead, Serializable, and Snapshot.</span></span>  
  
 <span data-ttu-id="6c498-449">OLE DB</span><span class="sxs-lookup"><span data-stu-id="6c498-449">OLE DB</span></span>  
 <span data-ttu-id="6c498-450">開始交易時，使用 OLE DB 的應用程式會將 *isoLevel* 會設定為 ISOLATIONLEVEL_READUNCOMMITTED、ISOLATIONLEVEL_READCOMMITTED、ISOLATIONLEVEL_REPEATABLEREAD、ISOLATIONLEVEL_SNAPSHOT 或 ISOLATIONLEVEL_SERIALIZABLE，來呼叫 `ITransactionLocal::StartTransaction`。</span><span class="sxs-lookup"><span data-stu-id="6c498-450">When starting a transaction, applications using OLE DB call `ITransactionLocal::StartTransaction` with *isoLevel* set to ISOLATIONLEVEL_READUNCOMMITTED, ISOLATIONLEVEL_READCOMMITTED, ISOLATIONLEVEL_REPEATABLEREAD, ISOLATIONLEVEL_SNAPSHOT, or ISOLATIONLEVEL_SERIALIZABLE.</span></span>  
  
 <span data-ttu-id="6c498-451">當以自動認可模式指定交易隔離層級時，OLE DB 應用程式可以將 DBPROPSET_SESSION 屬性的 DBPROP_SESS_AUTOCOMMITISOLEVELS 設定成 DBPROPVAL_TI_CHAOS、DBPROPVAL_TI_READUNCOMMITTED、DBPROPVAL_TI_BROWSE、DBPROPVAL_TI_CURSORSTABILITY、DBPROPVAL_TI_READCOMMITTED、DBPROPVAL_TI_REPEATABLEREAD、DBPROPVAL_TI_SERIALIZABLE、DBPROPVAL_TI_ISOLATED 或 DBPROPVAL_TI_SNAPSHOT。</span><span class="sxs-lookup"><span data-stu-id="6c498-451">When specifying the transaction isolation level in autocommit mode, OLE DB applications can set the DBPROPSET_SESSION property DBPROP_SESS_AUTOCOMMITISOLEVELS to DBPROPVAL_TI_CHAOS, DBPROPVAL_TI_READUNCOMMITTED, DBPROPVAL_TI_BROWSE, DBPROPVAL_TI_CURSORSTABILITY, DBPROPVAL_TI_READCOMMITTED, DBPROPVAL_TI_REPEATABLEREAD, DBPROPVAL_TI_SERIALIZABLE, DBPROPVAL_TI_ISOLATED, or DBPROPVAL_TI_SNAPSHOT.</span></span>  
  
 <span data-ttu-id="6c498-452">ODBC</span><span class="sxs-lookup"><span data-stu-id="6c498-452">ODBC</span></span>  
 <span data-ttu-id="6c498-453">ODBC 應用程式會將 *Attribute* 設定為 SQL_ATTR_TXN_ISOLATION 並將 *ValuePtr* 設定為 SQL_TXN_READ_UNCOMMITTED、SQL_TXN_READ_COMMITTED、SQL_TXN_REPEATABLE_READ 或 SQL_TXN_SERIALIZABLE，來呼叫 `SQLSetConnectAttr`。</span><span class="sxs-lookup"><span data-stu-id="6c498-453">ODBC applications call `SQLSetConnectAttr` with *Attribute* set to SQL_ATTR_TXN_ISOLATION and *ValuePtr* set to SQL_TXN_READ_UNCOMMITTED, SQL_TXN_READ_COMMITTED, SQL_TXN_REPEATABLE_READ, or SQL_TXN_SERIALIZABLE.</span></span>  
  
 <span data-ttu-id="6c498-454">針對快照集交易，應用程式會將 Attribute 設定為 SQL_COPT_SS_TXN_ISOLATION 並將 ValuePtr 設定為 SQL_TXN_SS_SNAPSHOT，來呼叫 `SQLSetConnectAttr`。</span><span class="sxs-lookup"><span data-stu-id="6c498-454">For snapshot transactions, applications call `SQLSetConnectAttr` with Attribute set to SQL_COPT_SS_TXN_ISOLATION and ValuePtr set to SQL_TXN_SS_SNAPSHOT.</span></span> <span data-ttu-id="6c498-455">快照集交易可以使用 SQL_COPT_SS_TXN_ISOLATION 或 SQL_ATTR_TXN_ISOLATION 來擷取。</span><span class="sxs-lookup"><span data-stu-id="6c498-455">A snapshot transaction can be retrieved using either SQL_COPT_SS_TXN_ISOLATION or SQL_ATTR_TXN_ISOLATION.</span></span>  
  
 <span data-ttu-id="6c498-456">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="6c498-456">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="locking-in-the-database-engine"></a><a name="Lock_Engine"></a> <span data-ttu-id="6c498-457">資料庫引擎中的鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-457">Locking in the Database Engine</span></span>  

 <span data-ttu-id="6c498-458">鎖定是 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 的一種機制，用以同步處理多個使用者在同一時間對相同資料的存取。</span><span class="sxs-lookup"><span data-stu-id="6c498-458">Locking is a mechanism used by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] to synchronize access by multiple users to the same piece of data at the same time.</span></span>  
  
 <span data-ttu-id="6c498-459">在交易取得資料目前狀態的相依性前 (例如讀取或修改資料)，它必須保護自己使其免於受到另一個交易修改相同資料的影響。</span><span class="sxs-lookup"><span data-stu-id="6c498-459">Before a transaction acquires a dependency on the current state of a piece of data, such as by reading or modifying the data, it must protect itself from the effects of another transaction modifying the same data.</span></span> <span data-ttu-id="6c498-460">交易可以要求資料的鎖定以達到此目的。</span><span class="sxs-lookup"><span data-stu-id="6c498-460">The transaction does this by requesting a lock on the piece of data.</span></span> <span data-ttu-id="6c498-461">鎖定有不同的模式，例如共用或獨佔。</span><span class="sxs-lookup"><span data-stu-id="6c498-461">Locks have different modes, such as shared or exclusive.</span></span> <span data-ttu-id="6c498-462">鎖定模式可定義交易在資料上的相依性層級。</span><span class="sxs-lookup"><span data-stu-id="6c498-462">The lock mode defines the level of dependency the transaction has on the data.</span></span> <span data-ttu-id="6c498-463">若已授與該資料的鎖定模式給某個交易，就不會再授與鎖定給另一個交易，以免造成衝突。</span><span class="sxs-lookup"><span data-stu-id="6c498-463">No transaction can be granted a lock that would conflict with the mode of a lock already granted on that data to another transaction.</span></span> <span data-ttu-id="6c498-464">如果交易所要求的鎖定模式，將和已授與相同資料的鎖定造成衝突， [!INCLUDE[ssDE](../includes/ssde-md.md)] 將停止要求交易，直到釋放第一個鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-464">If a transaction requests a lock mode that conflicts with a lock that has already been granted on the same data, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] will pause the requesting transaction until the first lock is released.</span></span>  
  
 <span data-ttu-id="6c498-465">當交易修改資料時，它會持有防止修改的鎖定，直到交易結束為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-465">When a transaction modifies a piece of data, it holds the lock protecting the modification until the end of the transaction.</span></span> <span data-ttu-id="6c498-466">交易持有保護讀取作業的鎖定時間長度，需視交易隔離等級設定而定。</span><span class="sxs-lookup"><span data-stu-id="6c498-466">How long a transaction holds the locks acquired to protect read operations depends on the transaction isolation level setting.</span></span> <span data-ttu-id="6c498-467">交易完成 (認可或復原) 時，會釋放交易所持有的所有鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-467">All locks held by a transaction are released when the transaction completes (either commits or rolls back).</span></span>  
  
 <span data-ttu-id="6c498-468">應用程式通常不會直接要求鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-468">Applications do not typically request locks directly.</span></span> <span data-ttu-id="6c498-469">[!INCLUDE[ssDE](../includes/ssde-md.md)] 中的鎖定管理員會在內部管理鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-469">Locks are managed internally by a part of the [!INCLUDE[ssDE](../includes/ssde-md.md)] called the lock manager.</span></span> <span data-ttu-id="6c498-470">當 [!INCLUDE[ssDE](../includes/ssde-md.md)] 執行個體處理 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式時， [!INCLUDE[ssDE](../includes/ssde-md.md)] 查詢處理器可以決定要存取哪些資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-470">When an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] processes a [!INCLUDE[tsql](../includes/tsql-md.md)] statement, the [!INCLUDE[ssDE](../includes/ssde-md.md)] query processor determines which resources are to be accessed.</span></span> <span data-ttu-id="6c498-471">查詢處理器根據存取類型以及交易隔離等級設定，決定需要哪些類型的鎖定以保護每個資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-471">The query processor determines what types of locks are required to protect each resource based on the type of access and the transaction isolation level setting.</span></span> <span data-ttu-id="6c498-472">查詢處理器接著會對鎖定管理員要求適當的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-472">The query processor then requests the appropriate locks from the lock manager.</span></span> <span data-ttu-id="6c498-473">如果沒有其他交易持有衝突的鎖定，鎖定管理員就會授與鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-473">The lock manager grants the locks if there are no conflicting locks held by other transactions.</span></span>  
  
### <a name="lock-granularity-and-hierarchies"></a><span data-ttu-id="6c498-474">鎖定資料粒度和階層</span><span class="sxs-lookup"><span data-stu-id="6c498-474">Lock Granularity and Hierarchies</span></span>  

 <span data-ttu-id="6c498-475">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 具有多資料粒度鎖定 (Multigranular Lock)，允許交易鎖定不同類型的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-475">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] has multigranular locking that allows different types of resources to be locked by a transaction.</span></span> <span data-ttu-id="6c498-476">為了把鎖定的成本降至最低， [!INCLUDE[ssDE](../includes/ssde-md.md)] 自動依照工作的適當層級來鎖定資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-476">To minimize the cost of locking, the [!INCLUDE[ssDE](../includes/ssde-md.md)] locks resources automatically at a level appropriate to the task.</span></span> <span data-ttu-id="6c498-477">鎖定於較小的資料粒度 (Granularity) 如資料列可以提高並行，但如果鎖定許多的資料列則由於必須持有更多的鎖定而造成更高的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="6c498-477">Locking at a smaller granularity, such as rows, increases concurrency but has a higher overhead because more locks must be held if many rows are locked.</span></span> <span data-ttu-id="6c498-478">鎖定於較大的資料粒度如資料表，從並行的角度來看則由於鎖定整個資料表會限制其他交易對於資料表其他部份的存取因而更費時。</span><span class="sxs-lookup"><span data-stu-id="6c498-478">Locking at a larger granularity, such as tables, are expensive in terms of concurrency because locking an entire table restricts access to any part of the table by other transactions.</span></span> <span data-ttu-id="6c498-479">但由於必須維持的鎖定較少因此額外負荷較低。</span><span class="sxs-lookup"><span data-stu-id="6c498-479">However, it has a lower overhead because fewer locks are being maintained.</span></span>  
  
 <span data-ttu-id="6c498-480">[!INCLUDE[ssDE](../includes/ssde-md.md)] 通常必須在資料粒度的多個層級取得鎖定，以完全保護資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-480">The [!INCLUDE[ssDE](../includes/ssde-md.md)] often has to acquire locks at multiple levels of granularity to fully protect a resource.</span></span> <span data-ttu-id="6c498-481">在資料粒度的多個層級之鎖定群組稱為鎖定階層。</span><span class="sxs-lookup"><span data-stu-id="6c498-481">This group of locks at multiple levels of granularity is called a lock hierarchy.</span></span> <span data-ttu-id="6c498-482">例如，若要充份地保護索引的讀取， [!INCLUDE[ssDE](../includes/ssde-md.md)] 可能需要取得資料列的共用鎖定以及頁面和資料表的意圖共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-482">For example, to fully protect a read of an index, an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] may have to acquire share locks on rows and intent share locks on the pages and table.</span></span>  
  
 <span data-ttu-id="6c498-483">下表顯示 [!INCLUDE[ssDE](../includes/ssde-md.md)] 可以鎖定的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-483">The following table shows the resources that the [!INCLUDE[ssDE](../includes/ssde-md.md)] can lock.</span></span>  
  
|<span data-ttu-id="6c498-484">資源</span><span class="sxs-lookup"><span data-stu-id="6c498-484">Resource</span></span>|<span data-ttu-id="6c498-485">描述</span><span class="sxs-lookup"><span data-stu-id="6c498-485">Description</span></span>|  
|--------------|-----------------|  
|<span data-ttu-id="6c498-486">RID</span><span class="sxs-lookup"><span data-stu-id="6c498-486">RID</span></span>|<span data-ttu-id="6c498-487">資料列識別碼，用來鎖定堆積內單一資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-487">A row identifier used to lock a single row within a heap.</span></span>|  
|<span data-ttu-id="6c498-488">KEY</span><span class="sxs-lookup"><span data-stu-id="6c498-488">KEY</span></span>|<span data-ttu-id="6c498-489">索引中的資料列鎖定，用來保護可序列化交易中的索引鍵範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-489">A row lock within an index used to protect key ranges in serializable transactions.</span></span>|  
|<span data-ttu-id="6c498-490">PAGE</span><span class="sxs-lookup"><span data-stu-id="6c498-490">PAGE</span></span>|<span data-ttu-id="6c498-491">資料庫中的 8 KB 頁面，例如資料或索引頁面。</span><span class="sxs-lookup"><span data-stu-id="6c498-491">An 8-kilobyte (KB) page in a database, such as data or index pages.</span></span>|  
|<span data-ttu-id="6c498-492">EXTENT</span><span class="sxs-lookup"><span data-stu-id="6c498-492">EXTENT</span></span>|<span data-ttu-id="6c498-493">連續八個頁面的群組，例如資料頁或索引頁面。</span><span class="sxs-lookup"><span data-stu-id="6c498-493">A contiguous group of eight pages, such as data or index pages.</span></span>|  
|<span data-ttu-id="6c498-494">HoBT</span><span class="sxs-lookup"><span data-stu-id="6c498-494">HoBT</span></span>|<span data-ttu-id="6c498-495">堆積或 B 樹狀目錄。</span><span class="sxs-lookup"><span data-stu-id="6c498-495">A heap or B-tree.</span></span> <span data-ttu-id="6c498-496">針對資料表中沒有叢集索引的 B 型樹狀結構 (索引) 或堆積資料頁面進行保護鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-496">A lock protecting a B-tree (index) or the heap data pages in a table that does not have a clustered index.</span></span>|  
|<span data-ttu-id="6c498-497">TABLE</span><span class="sxs-lookup"><span data-stu-id="6c498-497">TABLE</span></span>|<span data-ttu-id="6c498-498">一整個資料表，包含所有資料和索引。</span><span class="sxs-lookup"><span data-stu-id="6c498-498">The entire table, including all data and indexes.</span></span>|  
|<span data-ttu-id="6c498-499">FILE</span><span class="sxs-lookup"><span data-stu-id="6c498-499">FILE</span></span>|<span data-ttu-id="6c498-500">資料庫檔案</span><span class="sxs-lookup"><span data-stu-id="6c498-500">A database file.</span></span>|  
|<span data-ttu-id="6c498-501">APPLICATION</span><span class="sxs-lookup"><span data-stu-id="6c498-501">APPLICATION</span></span>|<span data-ttu-id="6c498-502">應用程式指定資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-502">An application-specified resource.</span></span>|  
|<span data-ttu-id="6c498-503">METADATA</span><span class="sxs-lookup"><span data-stu-id="6c498-503">METADATA</span></span>|<span data-ttu-id="6c498-504">中繼資料鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-504">Metadata locks.</span></span>|  
|<span data-ttu-id="6c498-505">ALLOCATION_UNIT</span><span class="sxs-lookup"><span data-stu-id="6c498-505">ALLOCATION_UNIT</span></span>|<span data-ttu-id="6c498-506">配置單位。</span><span class="sxs-lookup"><span data-stu-id="6c498-506">An allocation unit.</span></span>|  
|<span data-ttu-id="6c498-507">DATABASE</span><span class="sxs-lookup"><span data-stu-id="6c498-507">DATABASE</span></span>|<span data-ttu-id="6c498-508">一整個資料庫。</span><span class="sxs-lookup"><span data-stu-id="6c498-508">The entire database.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-509">[ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql) 的 LOCK_ESCALATION 選項可影響 HoBT 和 TABLE 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-509">HoBT and TABLE locks can be affected by the LOCK_ESCALATION option of [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
### <a name="lock-modes"></a><span data-ttu-id="6c498-510">鎖定模式</span><span class="sxs-lookup"><span data-stu-id="6c498-510">Lock Modes</span></span>  

 <span data-ttu-id="6c498-511">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 使用可決定並行交易如何存取資源的各種鎖定模式來鎖定資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-511">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] locks resources using different lock modes that determine how the resources can be accessed by concurrent transactions.</span></span>  
  
 <span data-ttu-id="6c498-512">下表顯示 [!INCLUDE[ssDE](../includes/ssde-md.md)] 使用的資源鎖定模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-512">The following table shows the resource lock modes that the [!INCLUDE[ssDE](../includes/ssde-md.md)] uses.</span></span>  
  
|<span data-ttu-id="6c498-513">鎖定模式</span><span class="sxs-lookup"><span data-stu-id="6c498-513">Lock mode</span></span>|<span data-ttu-id="6c498-514">描述</span><span class="sxs-lookup"><span data-stu-id="6c498-514">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="6c498-515">共用 (S)</span><span class="sxs-lookup"><span data-stu-id="6c498-515">Shared (S)</span></span>|<span data-ttu-id="6c498-516">用於不變更或更新資料的讀取作業，例如 SELECT 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-516">Used for read operations that do not change or update data, such as a SELECT statement.</span></span>|  
|<span data-ttu-id="6c498-517">更新 (U)</span><span class="sxs-lookup"><span data-stu-id="6c498-517">Update (U)</span></span>|<span data-ttu-id="6c498-518">用於可更新的資源上。</span><span class="sxs-lookup"><span data-stu-id="6c498-518">Used on resources that can be updated.</span></span> <span data-ttu-id="6c498-519">防止當多個工作階段正在讀取、鎖定及後來可能更新資源時發生常見的死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-519">Prevents a common form of deadlock that occurs when multiple sessions are reading, locking, and potentially updating resources later.</span></span>|  
|<span data-ttu-id="6c498-520">獨占 (X)</span><span class="sxs-lookup"><span data-stu-id="6c498-520">Exclusive (X)</span></span>|<span data-ttu-id="6c498-521">用於資料修改動作，例如 INSERT、UPDATE 或 DELETE。</span><span class="sxs-lookup"><span data-stu-id="6c498-521">Used for data-modification operations, such as INSERT, UPDATE, or DELETE.</span></span> <span data-ttu-id="6c498-522">確保不能對相同資源同時進行多重更新。</span><span class="sxs-lookup"><span data-stu-id="6c498-522">Ensures that multiple updates cannot be made to the same resource at the same time.</span></span>|  
|<span data-ttu-id="6c498-523">Intent</span><span class="sxs-lookup"><span data-stu-id="6c498-523">Intent</span></span>|<span data-ttu-id="6c498-524">用來建立鎖定階層。</span><span class="sxs-lookup"><span data-stu-id="6c498-524">Used to establish a lock hierarchy.</span></span> <span data-ttu-id="6c498-525">意圖鎖定的類型為：意圖共用 (IS)、意圖獨佔 (IX) 與共用意圖獨佔 (SIX)。</span><span class="sxs-lookup"><span data-stu-id="6c498-525">The types of intent locks are: intent shared (IS), intent exclusive (IX), and shared with intent exclusive (SIX).</span></span>|  
|<span data-ttu-id="6c498-526">結構描述</span><span class="sxs-lookup"><span data-stu-id="6c498-526">Schema</span></span>|<span data-ttu-id="6c498-527">執行相依於資料表結構描述的作業時使用。</span><span class="sxs-lookup"><span data-stu-id="6c498-527">Used when an operation dependent on the schema of a table is executing.</span></span> <span data-ttu-id="6c498-528">結構描述鎖定的類型為：結構描述修改 (Sch-M) 與結構描述穩定性 (Sch-S)。</span><span class="sxs-lookup"><span data-stu-id="6c498-528">The types of schema locks are: schema modification (Sch-M) and schema stability (Sch-S).</span></span>|  
|<span data-ttu-id="6c498-529">大量更新 (BU)</span><span class="sxs-lookup"><span data-stu-id="6c498-529">Bulk Update (BU)</span></span>|<span data-ttu-id="6c498-530">用於大量複製資料到資料表，且已指定 **TABLOCK** 提示時。</span><span class="sxs-lookup"><span data-stu-id="6c498-530">Used when bulk copying data into a table and the **TABLOCK** hint is specified.</span></span>|  
|<span data-ttu-id="6c498-531">索引鍵範圍</span><span class="sxs-lookup"><span data-stu-id="6c498-531">Key-range</span></span>|<span data-ttu-id="6c498-532">當使用可序列化交易隔離等級時，保護查詢讀取的資料列範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-532">Protects the range of rows read by a query when using the serializable transaction isolation level.</span></span> <span data-ttu-id="6c498-533">確定其他交易無法插入資料列，這些資料列在查詢重新執行時可限定可序列化交易的查詢。</span><span class="sxs-lookup"><span data-stu-id="6c498-533">Ensures that other transactions cannot insert rows that would qualify for the queries of the serializable transaction if the queries were run again.</span></span>|  
  
#### <a name="shared-locks"></a><span data-ttu-id="6c498-534">共用鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-534">Shared Locks</span></span>  

 <span data-ttu-id="6c498-535">共用 (S) 鎖定允許並行交易在封閉式 (Pessimistic) 並行控制之下讀取 (SELECT) 資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-535">Shared (S) locks allow concurrent transactions to read (SELECT) a resource under pessimistic concurrency control.</span></span> <span data-ttu-id="6c498-536">當資源存在共用 (S) 鎖定時，任何交易都無法修改資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-536">No other transactions can modify the data while shared (S) locks exist on the resource.</span></span> <span data-ttu-id="6c498-537">除非交易隔離等級是設為可重複讀取或更高等級，或是使用鎖定提示來保持交易期間的共用 (S) 鎖定，否則讀取作業一完成就會釋放資源的共用 (S) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-537">Shared (S) locks on a resource are released as soon as the read operation completes, unless the transaction isolation level is set to repeatable read or higher, or a locking hint is used to retain the shared (S) locks for the duration of the transaction.</span></span>  
  
#### <a name="update-locks"></a><span data-ttu-id="6c498-538">更新鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-538">Update Locks</span></span>  

 <span data-ttu-id="6c498-539">更新 (U) 鎖定可防止常見的死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-539">Update (U) locks prevent a common form of deadlock.</span></span> <span data-ttu-id="6c498-540">在可重複讀取或可序列化交易中，交易在讀取資料時取得資源 (頁面或資料列) 的共用 (S) 鎖定，然後修改資料，此過程需要將鎖定轉換為獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-540">In a repeatable read or serializable transaction, the transaction reads data, acquiring a shared (S) lock on the resource (page or row), and then modifies the data, which requires lock conversion to an exclusive (X) lock.</span></span> <span data-ttu-id="6c498-541">如果兩筆交易取得某個資源的共用模式鎖定，然後嘗試同時更新資料，則其中一筆交易便會嘗試將鎖定轉換為獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-541">If two transactions acquire shared-mode locks on a resource and then attempt to update data concurrently, one transaction attempts the lock conversion to an exclusive (X) lock.</span></span> <span data-ttu-id="6c498-542">這種「從共用模式到獨佔」的鎖定轉換必須等待，因為某一筆交易的獨佔鎖定與另一筆交易的共用模式鎖定並不相容，所以會發生鎖定等候。</span><span class="sxs-lookup"><span data-stu-id="6c498-542">The shared-mode-to-exclusive lock conversion must wait because the exclusive lock for one transaction is not compatible with the shared-mode lock of the other transaction; a lock wait occurs.</span></span> <span data-ttu-id="6c498-543">第二筆交易便嘗試取得更新時的獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-543">The second transaction attempts to acquire an exclusive (X) lock for its update.</span></span> <span data-ttu-id="6c498-544">由於兩筆交易都轉換成獨佔 (X) 鎖定，且兩者皆等候另一筆交易釋放其共用模式的鎖定，因此便發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-544">Because both transactions are converting to exclusive (X) locks, and they are each waiting for the other transaction to release its shared-mode lock, a deadlock occurs.</span></span>  
  
 <span data-ttu-id="6c498-545">為了避免這種潛在的死結問題，則使用更新 (U) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-545">To avoid this potential deadlock problem, update (U) locks are used.</span></span> <span data-ttu-id="6c498-546">一次只有一筆交易可以取得資源的更新 (U) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-546">Only one transaction can obtain an update (U) lock to a resource at a time.</span></span> <span data-ttu-id="6c498-547">交易如果修改資源，更新 (U) 鎖定便轉換為獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-547">If a transaction modifies a resource, the update (U) lock is converted to an exclusive (X) lock.</span></span>  
  
#### <a name="exclusive-locks"></a><span data-ttu-id="6c498-548">獨佔鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-548">Exclusive Locks</span></span>  

 <span data-ttu-id="6c498-549">獨佔 (X) 鎖定防止並行交易存取某個資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-549">Exclusive (X) locks prevent access to a resource by concurrent transactions.</span></span> <span data-ttu-id="6c498-550">運用獨佔 (X) 鎖定，沒有其他交易可修改資料；只有使用 NOLOCK 提示或讀取未認可隔離等級，才能進行讀取作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-550">With an exclusive (X) lock, no other transactions can modify data; read operations can take place only with the use of the NOLOCK hint or read uncommitted isolation level.</span></span>  
  
 <span data-ttu-id="6c498-551">資料修改陳述式 (例如 INSERT、UPDATE 和 DELETE) 結合了修改和讀取作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-551">Data modification statements, such as INSERT, UPDATE, and DELETE combine both modification and read operations.</span></span> <span data-ttu-id="6c498-552">陳述式先執行讀取作業來取得資料，再執行必要的修改作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-552">The statement first performs read operations to acquire data before performing the required modification operations.</span></span> <span data-ttu-id="6c498-553">因此，資料修改陳述式通常會同時要求共用鎖定和獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-553">Data modification statements, therefore, typically request both shared locks and exclusive locks.</span></span> <span data-ttu-id="6c498-554">例如，UPDATE 陳述式可能基於與一個資料表的聯結來修改另一個資料表的資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-554">For example, an UPDATE statement might modify rows in one table based on a join with another table.</span></span> <span data-ttu-id="6c498-555">在這個案例中，除了對已更新的資料列要求獨佔鎖定之外，UPDATE 陳述式還對聯結資料表中讀取的資料列要求共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-555">In this case, the UPDATE statement requests shared locks on the rows read in the join table in addition to requesting exclusive locks on the updated rows.</span></span>  
  
#### <a name="intent-locks"></a><span data-ttu-id="6c498-556">意圖鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-556">Intent Locks</span></span>  

 <span data-ttu-id="6c498-557">[!INCLUDE[ssDE](../includes/ssde-md.md)] 使用意圖鎖定來保護，它把共用 (S) 鎖定或獨佔 (X) 鎖定放在鎖定階層中較低的資源上。</span><span class="sxs-lookup"><span data-stu-id="6c498-557">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses intent locks to protect placing a shared (S) lock or exclusive (X) lock on a resource lower in the lock hierarchy.</span></span> <span data-ttu-id="6c498-558">意圖鎖定會稱作意圖鎖定，是因為它們是在較低層級的鎖定之前取得的，因此表示將鎖定放在較低層級的意圖。</span><span class="sxs-lookup"><span data-stu-id="6c498-558">Intent locks are named intent locks because they are acquired before a lock at the lower level, and therefore signal intent to place locks at a lower level.</span></span>  
  
 <span data-ttu-id="6c498-559">意圖鎖定有兩個用途：</span><span class="sxs-lookup"><span data-stu-id="6c498-559">Intent locks serve two purposes:</span></span>  
  
-   <span data-ttu-id="6c498-560">防止其他交易修改較高層級的資源，而導致較低層級的鎖定失效。</span><span class="sxs-lookup"><span data-stu-id="6c498-560">To prevent other transactions from modifying the higher-level resource in a way that would invalidate the lock at the lower level.</span></span>  
  
-   <span data-ttu-id="6c498-561">為了改進 [!INCLUDE[ssDE](../includes/ssde-md.md)] 偵測資料粒度較高層級的鎖定衝突的效率。</span><span class="sxs-lookup"><span data-stu-id="6c498-561">To improve the efficiency of the [!INCLUDE[ssDE](../includes/ssde-md.md)] in detecting lock conflicts at the higher level of granularity.</span></span>  
  
 <span data-ttu-id="6c498-562">例如，在資料表內的頁面或資料列要求共用 (S) 鎖定之前，先在資料表層級要求共用意圖鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-562">For example, a shared intent lock is requested at the table level before shared (S) locks are requested on pages or rows within that table.</span></span> <span data-ttu-id="6c498-563">在資料表層級上設定意圖鎖定讓另一筆交易無法後續取得包含該分頁之資料表的獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-563">Setting an intent lock at the table level prevents another transaction from subsequently acquiring an exclusive (X) lock on the table containing that page.</span></span> <span data-ttu-id="6c498-564">意圖鎖定可以提昇效能，因為 [!INCLUDE[ssDE](../includes/ssde-md.md)] 只會在資料表層級上檢查意圖鎖定，來判斷交易是否可安全地取得該資料表的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-564">Intent locks improve performance because the [!INCLUDE[ssDE](../includes/ssde-md.md)] examines intent locks only at the table level to determine if a transaction can safely acquire a lock on that table.</span></span> <span data-ttu-id="6c498-565">這種方式省略了必須檢查資料表的每個資料列或分頁的鎖定來判斷交易是否可以鎖定整個資料表的需求。</span><span class="sxs-lookup"><span data-stu-id="6c498-565">This removes the requirement to examine every row or page lock on the table to determine if a transaction can lock the entire table.</span></span>  
  
 <span data-ttu-id="6c498-566">意圖鎖定包括意圖共用 (IS)、意圖獨佔 (IX) 與共用意圖獨佔 (SIX)。</span><span class="sxs-lookup"><span data-stu-id="6c498-566">Intent locks include intent shared (IS), intent exclusive (IX), and shared with intent exclusive (SIX).</span></span>  
  
|<span data-ttu-id="6c498-567">鎖定模式</span><span class="sxs-lookup"><span data-stu-id="6c498-567">Lock mode</span></span>|<span data-ttu-id="6c498-568">描述</span><span class="sxs-lookup"><span data-stu-id="6c498-568">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="6c498-569">意圖共用 (IS)</span><span class="sxs-lookup"><span data-stu-id="6c498-569">Intent shared (IS)</span></span>|<span data-ttu-id="6c498-570">保護在階層較低位置的某些 (但不是全部) 資源上要求的或取得的共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-570">Protects requested or acquired shared locks on some (but not all) resources lower in the hierarchy.</span></span>|  
|<span data-ttu-id="6c498-571">意圖獨佔 (IX)</span><span class="sxs-lookup"><span data-stu-id="6c498-571">Intent exclusive (IX)</span></span>|<span data-ttu-id="6c498-572">保護在階層較低位置的某些 (但不是全部) 資源上要求的或取得的獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-572">Protects requested or acquired exclusive locks on some (but not all) resources lower in the hierarchy.</span></span> <span data-ttu-id="6c498-573">IX 是 IS 的超集，它也保護在較低層級資源要求的共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-573">IX is a superset of IS, and it also protects requesting shared locks on lower level resources.</span></span>|  
|<span data-ttu-id="6c498-574">與意圖獨佔共用 (SIX)</span><span class="sxs-lookup"><span data-stu-id="6c498-574">Shared with intent exclusive (SIX)</span></span>|<span data-ttu-id="6c498-575">保護對階層較低位置的所有資源要求的或取得的共用鎖定，以及對某些 (但非全部) 較低層級資源的意圖獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-575">Protects requested or acquired shared locks on all resources lower in the hierarchy and intent exclusive locks on some (but not all) of the lower level resources.</span></span> <span data-ttu-id="6c498-576">在最上層的資源中允許同時發生的 IS 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-576">Concurrent IS locks at the top-level resource are allowed.</span></span> <span data-ttu-id="6c498-577">例如，在資料表上取得 SIX 鎖定也會取得所修改頁面的意圖獨佔鎖定，以及所修改資料列的獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-577">For example, acquiring a SIX lock on a table also acquires intent exclusive locks on the pages being modified and exclusive locks on the modified rows.</span></span> <span data-ttu-id="6c498-578">每個資源一次只能有一個 SIX 鎖定以防止其他的交易更新資源，雖然其他的交易可藉由取得資料表層級的 IS 鎖定來讀取階層架構中位於較低層級的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-578">There can be only one SIX lock per resource at one time, preventing updates to the resource made by other transactions, although other transactions can read resources lower in the hierarchy by obtaining IS locks at the table level.</span></span>|  
|<span data-ttu-id="6c498-579">意圖更新 (IU)</span><span class="sxs-lookup"><span data-stu-id="6c498-579">Intent update (IU)</span></span>|<span data-ttu-id="6c498-580">保護對階層中較低的所有資源要求的或取得的更新鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-580">Protects requested or acquired update locks on all resources lower in the hierarchy.</span></span> <span data-ttu-id="6c498-581">IU 鎖定只使用於頁面資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-581">IU locks are used only on page resources.</span></span> <span data-ttu-id="6c498-582">如果發生更新作業，IU 鎖定會轉換成 IX 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-582">IU locks are converted to IX locks if an update operation takes place.</span></span>|  
|<span data-ttu-id="6c498-583">共用意圖更新 (SIU)</span><span class="sxs-lookup"><span data-stu-id="6c498-583">Shared intent update (SIU)</span></span>|<span data-ttu-id="6c498-584">S 和 IU 鎖定的結合，這是個別取得這些鎖定又同時保留兩種鎖定的結果。</span><span class="sxs-lookup"><span data-stu-id="6c498-584">A combination of S and IU locks, as a result of acquiring these locks separately and simultaneously holding both locks.</span></span> <span data-ttu-id="6c498-585">例如，交易執行具有 PAGLOCK 提示的查詢，然後執行更新作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-585">For example, a transaction executes a query with the PAGLOCK hint and then executes an update operation.</span></span> <span data-ttu-id="6c498-586">具有 PAGLOCK 提示的查詢取得 S 鎖定，而更新作業則取得 IU 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-586">The query with the PAGLOCK hint acquires the S lock, and the update operation acquires the IU lock.</span></span>|  
|<span data-ttu-id="6c498-587">更新意圖獨佔 (UIX)</span><span class="sxs-lookup"><span data-stu-id="6c498-587">Update intent exclusive (UIX)</span></span>|<span data-ttu-id="6c498-588">U 和 IX 鎖定的結合，這是個別取得這些鎖定又同時保留兩種鎖定的結果。</span><span class="sxs-lookup"><span data-stu-id="6c498-588">A combination of U and IX locks, as a result of acquiring these locks separately and simultaneously holding both locks.</span></span>|  
  
#### <a name="schema-locks"></a><span data-ttu-id="6c498-589">結構描述鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-589">Schema Locks</span></span>  

 <span data-ttu-id="6c498-590">[!INCLUDE[ssDE](../includes/ssde-md.md)] 是在資料表的資料定義語言 (DDL) 作業 (例如加入資料行或卸除資料表) 期間使用結構描述修改 (Sch-M) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-590">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses schema modification (Sch-M) locks during a table data definition language (DDL) operation, such as adding a column or dropping a table.</span></span> <span data-ttu-id="6c498-591">在保留期間，Sch-M 鎖定禁止資料表的並行存取。</span><span class="sxs-lookup"><span data-stu-id="6c498-591">During the time that it is held, the Sch-M lock prevents concurrent access to the table.</span></span> <span data-ttu-id="6c498-592">這表示 Sch-M 鎖定會封鎖所有外在作業，直到釋放鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-592">This means the Sch-M lock blocks all outside operations until the lock is released.</span></span>  
  
 <span data-ttu-id="6c498-593">有些資料操作語言 (DML) 作業 (例如資料表截斷) 使用 Sch-M 鎖定來防止並行作業存取受影響的資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-593">Some data manipulation language (DML) operations, such as table truncation, use Sch-M locks to prevent access to affected tables by concurrent operations.</span></span>  
  
 <span data-ttu-id="6c498-594">[!INCLUDE[ssDE](../includes/ssde-md.md)] 在編譯並執行查詢時，會使用結構描述穩定性 (Sch-S) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-594">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses schema stability (Sch-S) locks when compiling and executing queries.</span></span> <span data-ttu-id="6c498-595">Sch-S 鎖定並未封鎖任何交易式鎖定，包括獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-595">Sch-S locks do not block any transactional locks, including exclusive (X) locks.</span></span> <span data-ttu-id="6c498-596">因此，其他的交易在查詢編譯期間可以繼續執行，包括對資料表使用 X 鎖定的那些交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-596">Therefore, other transactions, including those with X locks on a table, continue to run while a query is being compiled.</span></span> <span data-ttu-id="6c498-597">不過，取得 Sch-M 鎖定的並行 DDL 作業和並行 DML 作業無法在資料表上執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-597">However, concurrent DDL operations, and concurrent DML operations that acquire Sch-M locks, cannot be performed on the table.</span></span>  
  
#### <a name="bulk-update-locks"></a><span data-ttu-id="6c498-598">大量更新鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-598">Bulk Update Locks</span></span>  

 <span data-ttu-id="6c498-599">大量更新 (BU) 鎖定允許多個執行緒將資料同時大量載入到相同資料表，同時禁止未大量載入資料的其他處理序存取該資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-599">Bulk update (BU) locks allow multiple threads to bulk load data concurrently into the same table while preventing other processes that are not bulk loading data from accessing the table.</span></span> <span data-ttu-id="6c498-600">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會在下列兩種情況都成立時使用大量更新 (BU) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-600">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses bulk update (BU) locks when both of the following conditions are true.</span></span>  
  
-   <span data-ttu-id="6c498-601">當您使用 Transact-SQL BULK INSERT 陳述式或 OPENROWSET(BULK) 函數，或使用任何的大量插入 API 命令如 .NET SqlBulkCopy、OLEDB 快速載入 API 或 ODBC 大量複製 API 等，大量複製資料到資料表中。</span><span class="sxs-lookup"><span data-stu-id="6c498-601">You use the Transact-SQL BULK INSERT statement, or the OPENROWSET(BULK) function, or you use one of the Bulk Insert API commands such as .NET SqlBulkCopy, OLEDB Fast Load APIs, or the ODBC Bulk Copy APIs to bulk copy data into a table.</span></span>  
  
-   <span data-ttu-id="6c498-602">當已指定 **TABLOCK** 提示，或者使用 **sp_tableoption** 設定了 **table lock on bulk load**資料表選項。</span><span class="sxs-lookup"><span data-stu-id="6c498-602">The **TABLOCK** hint is specified or the **table lock on bulk load** table option is set using **sp_tableoption**.</span></span>  
  
> [!TIP]  
>  <span data-ttu-id="6c498-603">與 BULK INSERT 陳述式 (持有較不嚴格的大量更新鎖定) 不同之處在於，具 TABLOCK 提示的 INSERT INTO...SELECT 對資料表持有獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-603">Unlike the BULK INSERT statement, which holds a less restrictive Bulk Update lock, INSERT INTO...SELECT with the TABLOCK hint holds an exclusive (X) lock on the table.</span></span> <span data-ttu-id="6c498-604">這代表您無法使用平行插入作業插入資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-604">This means that you cannot insert rows using parallel insert operations.</span></span>  
  
#### <a name="key-range-locks"></a><span data-ttu-id="6c498-605">索引鍵範圍鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-605">Key-Range Locks</span></span>  

 <span data-ttu-id="6c498-606">使用可序列化的交易隔離等級時，索引鍵範圍鎖定可保護由 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式讀取之記錄集內隱含包括的資料列範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-606">Key-range locks protect a range of rows implicitly included in a record set being read by a [!INCLUDE[tsql](../includes/tsql-md.md)] statement while using the serializable transaction isolation level.</span></span> <span data-ttu-id="6c498-607">索引鍵範圍鎖定可預防虛設項目讀取。</span><span class="sxs-lookup"><span data-stu-id="6c498-607">Key-range locking prevents phantom reads.</span></span> <span data-ttu-id="6c498-608">透過保護資料列之間的索引鍵範圍，也可防止某交易存取的記錄集內的虛設項目插入或刪除。</span><span class="sxs-lookup"><span data-stu-id="6c498-608">By protecting the ranges of keys between rows, it also prevents phantom insertions or deletions into a record set accessed by a transaction.</span></span>  
  
### <a name="lock-compatibility"></a><span data-ttu-id="6c498-609">鎖定相容性</span><span class="sxs-lookup"><span data-stu-id="6c498-609">Lock Compatibility</span></span>  

 <span data-ttu-id="6c498-610">鎖定相容性可控制多筆交易是否可同時對相同的資源取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-610">Lock compatibility controls whether multiple transactions can acquire locks on the same resource at the same time.</span></span> <span data-ttu-id="6c498-611">若資源已被其他交易鎖定，則只有在要求的鎖定模式與現有鎖定模式相容時，才能授與新的鎖定要求。</span><span class="sxs-lookup"><span data-stu-id="6c498-611">If a resource is already locked by another transaction, a new lock request can be granted only if the mode of the requested lock is compatible with the mode of the existing lock.</span></span> <span data-ttu-id="6c498-612">若所要求鎖定的模式與現有鎖定不相容，則要求新鎖定的交易會等候現有鎖定被釋放，或等候鎖定逾時間隔過期。</span><span class="sxs-lookup"><span data-stu-id="6c498-612">If the mode of the requested lock is not compatible with the existing lock, the transaction requesting the new lock waits for the existing lock to be released or for the lock timeout interval to expire.</span></span> <span data-ttu-id="6c498-613">例如，沒有任何一種鎖定模式與獨佔鎖定相容。</span><span class="sxs-lookup"><span data-stu-id="6c498-613">For example, no lock modes are compatible with exclusive locks.</span></span> <span data-ttu-id="6c498-614">有獨佔 (X) 鎖定存在時，其他的交易都無法取得該資源的任何一種鎖定 (共用、更新或獨佔)，直到獨佔 (X) 鎖定被釋放為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-614">While an exclusive (X) lock is held, no other transaction can acquire a lock of any kind (shared, update, or exclusive) on that resource until the exclusive (X) lock is released.</span></span> <span data-ttu-id="6c498-615">此外，如果資源已套用共用 (S) 鎖定，則即使第一筆交易尚未完成，其他的交易仍可取得該項目的共用鎖定或更新 (U) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-615">Alternatively, if a shared (S) lock has been applied to a resource, other transactions can also acquire a shared lock or an update (U) lock on that item even if the first transaction has not completed.</span></span> <span data-ttu-id="6c498-616">然而在共用鎖定尚未釋放之前，其他的交易仍然無法取得獨占鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-616">However, other transactions cannot acquire an exclusive lock until the shared lock has been released.</span></span>  
  
 <span data-ttu-id="6c498-617">下表顯示常見鎖定模式的相容性。</span><span class="sxs-lookup"><span data-stu-id="6c498-617">The following table shows the compatibility of the most commonly encountered lock modes.</span></span>  
  
||<span data-ttu-id="6c498-618">現有已授與的模式</span><span class="sxs-lookup"><span data-stu-id="6c498-618">Existing granted mode</span></span>||||||  
|------|---------------------------|------|------|------|------|------|  
|<span data-ttu-id="6c498-619">**要求的模式**</span><span class="sxs-lookup"><span data-stu-id="6c498-619">**Requested mode**</span></span>|<span data-ttu-id="6c498-620">**IS**</span><span class="sxs-lookup"><span data-stu-id="6c498-620">**IS**</span></span>|<span data-ttu-id="6c498-621">**S**</span><span class="sxs-lookup"><span data-stu-id="6c498-621">**S**</span></span>|<span data-ttu-id="6c498-622">**U**</span><span class="sxs-lookup"><span data-stu-id="6c498-622">**U**</span></span>|<span data-ttu-id="6c498-623">**IX**</span><span class="sxs-lookup"><span data-stu-id="6c498-623">**IX**</span></span>|<span data-ttu-id="6c498-624">**SIX**</span><span class="sxs-lookup"><span data-stu-id="6c498-624">**SIX**</span></span>|<span data-ttu-id="6c498-625">**X**</span><span class="sxs-lookup"><span data-stu-id="6c498-625">**X**</span></span>|  
|<span data-ttu-id="6c498-626">**意圖共用 (IS)**</span><span class="sxs-lookup"><span data-stu-id="6c498-626">**Intent shared (IS)**</span></span>|<span data-ttu-id="6c498-627">是</span><span class="sxs-lookup"><span data-stu-id="6c498-627">Yes</span></span>|<span data-ttu-id="6c498-628">是</span><span class="sxs-lookup"><span data-stu-id="6c498-628">Yes</span></span>|<span data-ttu-id="6c498-629">是</span><span class="sxs-lookup"><span data-stu-id="6c498-629">Yes</span></span>|<span data-ttu-id="6c498-630">是</span><span class="sxs-lookup"><span data-stu-id="6c498-630">Yes</span></span>|<span data-ttu-id="6c498-631">是</span><span class="sxs-lookup"><span data-stu-id="6c498-631">Yes</span></span>|<span data-ttu-id="6c498-632">否</span><span class="sxs-lookup"><span data-stu-id="6c498-632">No</span></span>|  
|<span data-ttu-id="6c498-633">**共用 (S)**</span><span class="sxs-lookup"><span data-stu-id="6c498-633">**Shared (S)**</span></span>|<span data-ttu-id="6c498-634">是</span><span class="sxs-lookup"><span data-stu-id="6c498-634">Yes</span></span>|<span data-ttu-id="6c498-635">是</span><span class="sxs-lookup"><span data-stu-id="6c498-635">Yes</span></span>|<span data-ttu-id="6c498-636">是</span><span class="sxs-lookup"><span data-stu-id="6c498-636">Yes</span></span>|<span data-ttu-id="6c498-637">否</span><span class="sxs-lookup"><span data-stu-id="6c498-637">No</span></span>|<span data-ttu-id="6c498-638">否</span><span class="sxs-lookup"><span data-stu-id="6c498-638">No</span></span>|<span data-ttu-id="6c498-639">否</span><span class="sxs-lookup"><span data-stu-id="6c498-639">No</span></span>|  
|<span data-ttu-id="6c498-640">**更新 (U)**</span><span class="sxs-lookup"><span data-stu-id="6c498-640">**Update (U)**</span></span>|<span data-ttu-id="6c498-641">是</span><span class="sxs-lookup"><span data-stu-id="6c498-641">Yes</span></span>|<span data-ttu-id="6c498-642">是</span><span class="sxs-lookup"><span data-stu-id="6c498-642">Yes</span></span>|<span data-ttu-id="6c498-643">否</span><span class="sxs-lookup"><span data-stu-id="6c498-643">No</span></span>|<span data-ttu-id="6c498-644">否</span><span class="sxs-lookup"><span data-stu-id="6c498-644">No</span></span>|<span data-ttu-id="6c498-645">否</span><span class="sxs-lookup"><span data-stu-id="6c498-645">No</span></span>|<span data-ttu-id="6c498-646">否</span><span class="sxs-lookup"><span data-stu-id="6c498-646">No</span></span>|  
|<span data-ttu-id="6c498-647">**意圖獨佔 (IX)**</span><span class="sxs-lookup"><span data-stu-id="6c498-647">**Intent exclusive (IX)**</span></span>|<span data-ttu-id="6c498-648">是</span><span class="sxs-lookup"><span data-stu-id="6c498-648">Yes</span></span>|<span data-ttu-id="6c498-649">否</span><span class="sxs-lookup"><span data-stu-id="6c498-649">No</span></span>|<span data-ttu-id="6c498-650">否</span><span class="sxs-lookup"><span data-stu-id="6c498-650">No</span></span>|<span data-ttu-id="6c498-651">是</span><span class="sxs-lookup"><span data-stu-id="6c498-651">Yes</span></span>|<span data-ttu-id="6c498-652">否</span><span class="sxs-lookup"><span data-stu-id="6c498-652">No</span></span>|<span data-ttu-id="6c498-653">否</span><span class="sxs-lookup"><span data-stu-id="6c498-653">No</span></span>|  
|<span data-ttu-id="6c498-654">**與意圖獨佔共用 (SIX)**</span><span class="sxs-lookup"><span data-stu-id="6c498-654">**Shared with intent exclusive (SIX)**</span></span>|<span data-ttu-id="6c498-655">是</span><span class="sxs-lookup"><span data-stu-id="6c498-655">Yes</span></span>|<span data-ttu-id="6c498-656">否</span><span class="sxs-lookup"><span data-stu-id="6c498-656">No</span></span>|<span data-ttu-id="6c498-657">否</span><span class="sxs-lookup"><span data-stu-id="6c498-657">No</span></span>|<span data-ttu-id="6c498-658">否</span><span class="sxs-lookup"><span data-stu-id="6c498-658">No</span></span>|<span data-ttu-id="6c498-659">否</span><span class="sxs-lookup"><span data-stu-id="6c498-659">No</span></span>|<span data-ttu-id="6c498-660">否</span><span class="sxs-lookup"><span data-stu-id="6c498-660">No</span></span>|  
|<span data-ttu-id="6c498-661">**獨占 (X)**</span><span class="sxs-lookup"><span data-stu-id="6c498-661">**Exclusive (X)**</span></span>|<span data-ttu-id="6c498-662">否</span><span class="sxs-lookup"><span data-stu-id="6c498-662">No</span></span>|<span data-ttu-id="6c498-663">否</span><span class="sxs-lookup"><span data-stu-id="6c498-663">No</span></span>|<span data-ttu-id="6c498-664">否</span><span class="sxs-lookup"><span data-stu-id="6c498-664">No</span></span>|<span data-ttu-id="6c498-665">否</span><span class="sxs-lookup"><span data-stu-id="6c498-665">No</span></span>|<span data-ttu-id="6c498-666">否</span><span class="sxs-lookup"><span data-stu-id="6c498-666">No</span></span>|<span data-ttu-id="6c498-667">否</span><span class="sxs-lookup"><span data-stu-id="6c498-667">No</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-668">意圖獨佔 (IX) 鎖定與 IX 鎖定模式相容，因為 IX 表示意圖是僅更新某些資料列而非更新全部。</span><span class="sxs-lookup"><span data-stu-id="6c498-668">An intent exclusive (IX) lock is compatible with an IX lock mode because IX means the intention is to update only some of the rows rather than all of them.</span></span> <span data-ttu-id="6c498-669">嘗試讀取或更新某些資料列的其他交易也可獲得許可，只要這些資料列與其他交易所更新的資料列不相同即可。</span><span class="sxs-lookup"><span data-stu-id="6c498-669">Other transactions that attempt to read or update some of the rows are also permitted as long as they are not the same rows being updated by other transactions.</span></span> <span data-ttu-id="6c498-670">此外，如果兩筆交易嘗試更新相同的資料列，這兩筆交易都會被授與資料表和頁面層級的 IX 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-670">Further, if two transactions attempt to update the same row, both transactions will be granted an IX lock at table and page level.</span></span> <span data-ttu-id="6c498-671">不過，其中一筆交易會被授與資料列層級的 X 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-671">However, one transaction will be granted an X lock at row level.</span></span> <span data-ttu-id="6c498-672">另一筆交易則必須等到系統移除資料列層級鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-672">The other transaction must wait until the row-level lock is removed.</span></span>  
  
 <span data-ttu-id="6c498-673">使用下表來判斷 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中所有可用鎖定模式的相容性。</span><span class="sxs-lookup"><span data-stu-id="6c498-673">Use the following table to determine the compatibility of all the lock modes available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="6c498-674">![顯示鎖定相容性矩陣的圖表](media/lockconflicttable.gif "顯示鎖定相容性矩陣的圖表")</span><span class="sxs-lookup"><span data-stu-id="6c498-674">![Diagram showing lock compatibility matrix](media/lockconflicttable.gif "Diagram showing lock compatibility matrix")</span></span>  
  
### <a name="key-range-locking"></a><span data-ttu-id="6c498-675">索引鍵範圍鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-675">Key-Range Locking</span></span>  

 <span data-ttu-id="6c498-676">使用可序列化的交易隔離等級時，索引鍵範圍鎖定可保護由 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式讀取之記錄集內隱含包括的資料列範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-676">Key-range locks protect a range of rows implicitly included in a record set being read by a [!INCLUDE[tsql](../includes/tsql-md.md)] statement while using the serializable transaction isolation level.</span></span> <span data-ttu-id="6c498-677">可序列化的隔離等級要求在交易期間執行的任何查詢，在交易期間每次執行時都必須取得相同的資料列集。</span><span class="sxs-lookup"><span data-stu-id="6c498-677">The serializable isolation level requires that any query executed during a transaction must obtain the same set of rows every time it is executed during the transaction.</span></span> <span data-ttu-id="6c498-678">索引鍵範圍鎖定藉由預防其他交易插入新資料列時，這些資料列的索引鍵落在可序列化交易讀取的索引鍵範圍，來保護此種需求。</span><span class="sxs-lookup"><span data-stu-id="6c498-678">A key range lock protects this requirement by preventing other transactions from inserting new rows whose keys would fall in the range of keys read by the serializable transaction.</span></span>  
  
 <span data-ttu-id="6c498-679">索引鍵範圍鎖定可預防虛設項目讀取。</span><span class="sxs-lookup"><span data-stu-id="6c498-679">Key-range locking prevents phantom reads.</span></span> <span data-ttu-id="6c498-680">藉由保護資料列之間的索引鍵範圍，也可以預防虛設項目插入到交易存取的記錄集。</span><span class="sxs-lookup"><span data-stu-id="6c498-680">By protecting the ranges of keys between rows, it also prevents phantom insertions into a set of records accessed by a transaction.</span></span>  
  
 <span data-ttu-id="6c498-681">索引鍵範圍鎖定是放置於索引之上，指定開始和結束的索引鍵值。</span><span class="sxs-lookup"><span data-stu-id="6c498-681">A key-range lock is placed on an index, specifying a beginning and ending key value.</span></span> <span data-ttu-id="6c498-682">因為這些動作會先在索引上取得鎖定，因此這種鎖定可封鎖任何嘗試插入、更新或刪除含有索引鍵值落入範圍的任何資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-682">This lock blocks any attempt to insert, update, or delete any row with a key value that falls in the range because those operations would first have to acquire a lock on the index.</span></span> <span data-ttu-id="6c498-683">例如，可序列化的交易可能會發出 SELECT 陳述式，讀取其索引鍵值在 **'** AAA **'** 和 **'** CZZ **'** 之間的所有資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-683">For example, a serializable transaction could issue a SELECT statement that reads all rows whose key values are between **'** AAA **'** and **'** CZZ **'**.</span></span> <span data-ttu-id="6c498-684">從 **'** AAA **'** 到 **'** CZZ **'** 範圍中索引鍵值的索引鍵範圍鎖定，可預防其他交易將含有索引鍵值的資料列插入到該範圍內的任何地方，例如 **'** ADG **'** 、 **'** BBD **'** 或 **'** CAL **'** 。</span><span class="sxs-lookup"><span data-stu-id="6c498-684">A key-range lock on the key values in the range from **'** AAA **'** to **'** CZZ **'** prevents other transactions from inserting rows with key values anywhere in that range, such as **'** ADG **'**, **'** BBD **'**, or **'** CAL **'**.</span></span>  
  
#### <a name="key-range-lock-modes"></a><span data-ttu-id="6c498-685">索引鍵範圍鎖定模式</span><span class="sxs-lookup"><span data-stu-id="6c498-685">Key-Range Lock Modes</span></span>  

 <span data-ttu-id="6c498-686">索引鍵範圍鎖定包括範圍以及資料列元件，以範圍-資料列的格式來指定：</span><span class="sxs-lookup"><span data-stu-id="6c498-686">Key-range locks include both a range and a row component specified in range-row format:</span></span>  
  
-   <span data-ttu-id="6c498-687">範圍代表保護兩個連續索引項之間的範圍的鎖定模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-687">Range represents the lock mode protecting the range between two consecutive index entries.</span></span>  
  
-   <span data-ttu-id="6c498-688">資料列代表保護索引項的鎖定模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-688">Row represents the lock mode protecting the index entry.</span></span>  
  
-   <span data-ttu-id="6c498-689">模式代表所使用的合併鎖定模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-689">Mode represents the combined lock mode used.</span></span> <span data-ttu-id="6c498-690">索引鍵範圍鎖定模式由兩個部份組成。</span><span class="sxs-lookup"><span data-stu-id="6c498-690">Key-range lock modes consist of two parts.</span></span> <span data-ttu-id="6c498-691">第一個部份代表用來鎖定索引鍵範圍的鎖定類型 (Range*T*)，第二個部份代表用來鎖定特定索引鍵的鎖定類型 (*K*)。</span><span class="sxs-lookup"><span data-stu-id="6c498-691">The first represents the type of lock used to lock the index range (Range*T*) and the second represents the lock type used to lock a specific key (*K*).</span></span> <span data-ttu-id="6c498-692">這兩個部份使用連字號 (-) 來連接，例如 Range*T*-*K*。</span><span class="sxs-lookup"><span data-stu-id="6c498-692">The two parts are connected with a hyphen (-), such as Range*T*-*K*.</span></span>  
  
    |<span data-ttu-id="6c498-693">範圍</span><span class="sxs-lookup"><span data-stu-id="6c498-693">Range</span></span>|<span data-ttu-id="6c498-694">資料列</span><span class="sxs-lookup"><span data-stu-id="6c498-694">Row</span></span>|<span data-ttu-id="6c498-695">[模式]</span><span class="sxs-lookup"><span data-stu-id="6c498-695">Mode</span></span>|<span data-ttu-id="6c498-696">描述</span><span class="sxs-lookup"><span data-stu-id="6c498-696">Description</span></span>|  
    |-----------|---------|----------|-----------------|  
    |<span data-ttu-id="6c498-697">RangeS</span><span class="sxs-lookup"><span data-stu-id="6c498-697">RangeS</span></span>|<span data-ttu-id="6c498-698">S</span><span class="sxs-lookup"><span data-stu-id="6c498-698">S</span></span>|<span data-ttu-id="6c498-699">RangeS-S</span><span class="sxs-lookup"><span data-stu-id="6c498-699">RangeS-S</span></span>|<span data-ttu-id="6c498-700">共用範圍，共用資源鎖定；可序列化範圍掃描。</span><span class="sxs-lookup"><span data-stu-id="6c498-700">Shared range, shared resource lock; serializable range scan.</span></span>|  
    |<span data-ttu-id="6c498-701">RangeS</span><span class="sxs-lookup"><span data-stu-id="6c498-701">RangeS</span></span>|<span data-ttu-id="6c498-702">U</span><span class="sxs-lookup"><span data-stu-id="6c498-702">U</span></span>|<span data-ttu-id="6c498-703">RangeS-U</span><span class="sxs-lookup"><span data-stu-id="6c498-703">RangeS-U</span></span>|<span data-ttu-id="6c498-704">共用範圍，更新資源鎖定；可序列化更新掃描。</span><span class="sxs-lookup"><span data-stu-id="6c498-704">Shared range, update resource lock; serializable update scan.</span></span>|  
    |<span data-ttu-id="6c498-705">RangeI</span><span class="sxs-lookup"><span data-stu-id="6c498-705">RangeI</span></span>|<span data-ttu-id="6c498-706">Null</span><span class="sxs-lookup"><span data-stu-id="6c498-706">Null</span></span>|<span data-ttu-id="6c498-707">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="6c498-707">RangeI-N</span></span>|<span data-ttu-id="6c498-708">插入範圍，Null 資源鎖定；在插入新的索引鍵到索引之前用來測試範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-708">Insert range, null resource lock; used to test ranges before inserting a new key into an index.</span></span>|  
    |<span data-ttu-id="6c498-709">RangeX</span><span class="sxs-lookup"><span data-stu-id="6c498-709">RangeX</span></span>|<span data-ttu-id="6c498-710">X</span><span class="sxs-lookup"><span data-stu-id="6c498-710">X</span></span>|<span data-ttu-id="6c498-711">RangeX-X</span><span class="sxs-lookup"><span data-stu-id="6c498-711">RangeX-X</span></span>|<span data-ttu-id="6c498-712">獨占範圍，獨占資源鎖定；在範圍內更新索引鍵時使用。</span><span class="sxs-lookup"><span data-stu-id="6c498-712">Exclusive range, exclusive resource lock; used when updating a key in a range.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-713">內部的 Null 鎖定模式與其他所有的鎖定模式皆相容。</span><span class="sxs-lookup"><span data-stu-id="6c498-713">The internal Null lock mode is compatible with all other lock modes.</span></span>  
  
 <span data-ttu-id="6c498-714">索引鍵範圍鎖定模式的相容性矩陣顯示，哪些鎖定與重疊索引鍵和範圍中取得的其他鎖定相容。</span><span class="sxs-lookup"><span data-stu-id="6c498-714">Key-range lock modes have a compatibility matrix that shows which locks are compatible with other locks obtained on overlapping keys and ranges.</span></span>  
  
||<span data-ttu-id="6c498-715">現有已授與的模式</span><span class="sxs-lookup"><span data-stu-id="6c498-715">Existing granted mode</span></span>|||||||  
|------|---------------------------|------|------|------|------|------|------|  
|<span data-ttu-id="6c498-716">**要求的模式**</span><span class="sxs-lookup"><span data-stu-id="6c498-716">**Requested mode**</span></span>|<span data-ttu-id="6c498-717">**S**</span><span class="sxs-lookup"><span data-stu-id="6c498-717">**S**</span></span>|<span data-ttu-id="6c498-718">**U**</span><span class="sxs-lookup"><span data-stu-id="6c498-718">**U**</span></span>|<span data-ttu-id="6c498-719">**X**</span><span class="sxs-lookup"><span data-stu-id="6c498-719">**X**</span></span>|<span data-ttu-id="6c498-720">**RangeS-S**</span><span class="sxs-lookup"><span data-stu-id="6c498-720">**RangeS-S**</span></span>|<span data-ttu-id="6c498-721">**RangeS-U**</span><span class="sxs-lookup"><span data-stu-id="6c498-721">**RangeS-U**</span></span>|<span data-ttu-id="6c498-722">**RangeI-N**</span><span class="sxs-lookup"><span data-stu-id="6c498-722">**RangeI-N**</span></span>|<span data-ttu-id="6c498-723">**RangeX-X**</span><span class="sxs-lookup"><span data-stu-id="6c498-723">**RangeX-X**</span></span>|  
|<span data-ttu-id="6c498-724">**共用 (S)**</span><span class="sxs-lookup"><span data-stu-id="6c498-724">**Shared (S)**</span></span>|<span data-ttu-id="6c498-725">是</span><span class="sxs-lookup"><span data-stu-id="6c498-725">Yes</span></span>|<span data-ttu-id="6c498-726">是</span><span class="sxs-lookup"><span data-stu-id="6c498-726">Yes</span></span>|<span data-ttu-id="6c498-727">否</span><span class="sxs-lookup"><span data-stu-id="6c498-727">No</span></span>|<span data-ttu-id="6c498-728">是</span><span class="sxs-lookup"><span data-stu-id="6c498-728">Yes</span></span>|<span data-ttu-id="6c498-729">是</span><span class="sxs-lookup"><span data-stu-id="6c498-729">Yes</span></span>|<span data-ttu-id="6c498-730">是</span><span class="sxs-lookup"><span data-stu-id="6c498-730">Yes</span></span>|<span data-ttu-id="6c498-731">否</span><span class="sxs-lookup"><span data-stu-id="6c498-731">No</span></span>|  
|<span data-ttu-id="6c498-732">**更新 (U)**</span><span class="sxs-lookup"><span data-stu-id="6c498-732">**Update (U)**</span></span>|<span data-ttu-id="6c498-733">是</span><span class="sxs-lookup"><span data-stu-id="6c498-733">Yes</span></span>|<span data-ttu-id="6c498-734">否</span><span class="sxs-lookup"><span data-stu-id="6c498-734">No</span></span>|<span data-ttu-id="6c498-735">否</span><span class="sxs-lookup"><span data-stu-id="6c498-735">No</span></span>|<span data-ttu-id="6c498-736">是</span><span class="sxs-lookup"><span data-stu-id="6c498-736">Yes</span></span>|<span data-ttu-id="6c498-737">否</span><span class="sxs-lookup"><span data-stu-id="6c498-737">No</span></span>|<span data-ttu-id="6c498-738">是</span><span class="sxs-lookup"><span data-stu-id="6c498-738">Yes</span></span>|<span data-ttu-id="6c498-739">否</span><span class="sxs-lookup"><span data-stu-id="6c498-739">No</span></span>|  
|<span data-ttu-id="6c498-740">**獨占 (X)**</span><span class="sxs-lookup"><span data-stu-id="6c498-740">**Exclusive (X)**</span></span>|<span data-ttu-id="6c498-741">否</span><span class="sxs-lookup"><span data-stu-id="6c498-741">No</span></span>|<span data-ttu-id="6c498-742">否</span><span class="sxs-lookup"><span data-stu-id="6c498-742">No</span></span>|<span data-ttu-id="6c498-743">否</span><span class="sxs-lookup"><span data-stu-id="6c498-743">No</span></span>|<span data-ttu-id="6c498-744">否</span><span class="sxs-lookup"><span data-stu-id="6c498-744">No</span></span>|<span data-ttu-id="6c498-745">否</span><span class="sxs-lookup"><span data-stu-id="6c498-745">No</span></span>|<span data-ttu-id="6c498-746">是</span><span class="sxs-lookup"><span data-stu-id="6c498-746">Yes</span></span>|<span data-ttu-id="6c498-747">否</span><span class="sxs-lookup"><span data-stu-id="6c498-747">No</span></span>|  
|<span data-ttu-id="6c498-748">**RangeS-S**</span><span class="sxs-lookup"><span data-stu-id="6c498-748">**RangeS-S**</span></span>|<span data-ttu-id="6c498-749">是</span><span class="sxs-lookup"><span data-stu-id="6c498-749">Yes</span></span>|<span data-ttu-id="6c498-750">是</span><span class="sxs-lookup"><span data-stu-id="6c498-750">Yes</span></span>|<span data-ttu-id="6c498-751">否</span><span class="sxs-lookup"><span data-stu-id="6c498-751">No</span></span>|<span data-ttu-id="6c498-752">是</span><span class="sxs-lookup"><span data-stu-id="6c498-752">Yes</span></span>|<span data-ttu-id="6c498-753">是</span><span class="sxs-lookup"><span data-stu-id="6c498-753">Yes</span></span>|<span data-ttu-id="6c498-754">否</span><span class="sxs-lookup"><span data-stu-id="6c498-754">No</span></span>|<span data-ttu-id="6c498-755">否</span><span class="sxs-lookup"><span data-stu-id="6c498-755">No</span></span>|  
|<span data-ttu-id="6c498-756">**RangeS-U**</span><span class="sxs-lookup"><span data-stu-id="6c498-756">**RangeS-U**</span></span>|<span data-ttu-id="6c498-757">是</span><span class="sxs-lookup"><span data-stu-id="6c498-757">Yes</span></span>|<span data-ttu-id="6c498-758">否</span><span class="sxs-lookup"><span data-stu-id="6c498-758">No</span></span>|<span data-ttu-id="6c498-759">否</span><span class="sxs-lookup"><span data-stu-id="6c498-759">No</span></span>|<span data-ttu-id="6c498-760">是</span><span class="sxs-lookup"><span data-stu-id="6c498-760">Yes</span></span>|<span data-ttu-id="6c498-761">否</span><span class="sxs-lookup"><span data-stu-id="6c498-761">No</span></span>|<span data-ttu-id="6c498-762">否</span><span class="sxs-lookup"><span data-stu-id="6c498-762">No</span></span>|<span data-ttu-id="6c498-763">否</span><span class="sxs-lookup"><span data-stu-id="6c498-763">No</span></span>|  
|<span data-ttu-id="6c498-764">**RangeI-N**</span><span class="sxs-lookup"><span data-stu-id="6c498-764">**RangeI-N**</span></span>|<span data-ttu-id="6c498-765">是</span><span class="sxs-lookup"><span data-stu-id="6c498-765">Yes</span></span>|<span data-ttu-id="6c498-766">是</span><span class="sxs-lookup"><span data-stu-id="6c498-766">Yes</span></span>|<span data-ttu-id="6c498-767">是</span><span class="sxs-lookup"><span data-stu-id="6c498-767">Yes</span></span>|<span data-ttu-id="6c498-768">否</span><span class="sxs-lookup"><span data-stu-id="6c498-768">No</span></span>|<span data-ttu-id="6c498-769">否</span><span class="sxs-lookup"><span data-stu-id="6c498-769">No</span></span>|<span data-ttu-id="6c498-770">是</span><span class="sxs-lookup"><span data-stu-id="6c498-770">Yes</span></span>|<span data-ttu-id="6c498-771">否</span><span class="sxs-lookup"><span data-stu-id="6c498-771">No</span></span>|  
|<span data-ttu-id="6c498-772">**RangeX-X**</span><span class="sxs-lookup"><span data-stu-id="6c498-772">**RangeX-X**</span></span>|<span data-ttu-id="6c498-773">否</span><span class="sxs-lookup"><span data-stu-id="6c498-773">No</span></span>|<span data-ttu-id="6c498-774">否</span><span class="sxs-lookup"><span data-stu-id="6c498-774">No</span></span>|<span data-ttu-id="6c498-775">否</span><span class="sxs-lookup"><span data-stu-id="6c498-775">No</span></span>|<span data-ttu-id="6c498-776">否</span><span class="sxs-lookup"><span data-stu-id="6c498-776">No</span></span>|<span data-ttu-id="6c498-777">否</span><span class="sxs-lookup"><span data-stu-id="6c498-777">No</span></span>|<span data-ttu-id="6c498-778">否</span><span class="sxs-lookup"><span data-stu-id="6c498-778">No</span></span>|<span data-ttu-id="6c498-779">否</span><span class="sxs-lookup"><span data-stu-id="6c498-779">No</span></span>|  
  
#### <a name="conversion-locks"></a><span data-ttu-id="6c498-780">轉換鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-780">Conversion Locks</span></span>  

 <span data-ttu-id="6c498-781">轉換鎖定是在索引鍵範圍鎖定與另一種鎖定重疊時建立。</span><span class="sxs-lookup"><span data-stu-id="6c498-781">Conversion locks are created when a key-range lock overlaps another lock.</span></span>  
  
|<span data-ttu-id="6c498-782">鎖定 1</span><span class="sxs-lookup"><span data-stu-id="6c498-782">Lock 1</span></span>|<span data-ttu-id="6c498-783">鎖定 2</span><span class="sxs-lookup"><span data-stu-id="6c498-783">Lock 2</span></span>|<span data-ttu-id="6c498-784">轉換鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-784">Conversion lock</span></span>|  
|------------|------------|---------------------|  
|<span data-ttu-id="6c498-785">S</span><span class="sxs-lookup"><span data-stu-id="6c498-785">S</span></span>|<span data-ttu-id="6c498-786">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="6c498-786">RangeI-N</span></span>|<span data-ttu-id="6c498-787">RangeI-S</span><span class="sxs-lookup"><span data-stu-id="6c498-787">RangeI-S</span></span>|  
|<span data-ttu-id="6c498-788">U</span><span class="sxs-lookup"><span data-stu-id="6c498-788">U</span></span>|<span data-ttu-id="6c498-789">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="6c498-789">RangeI-N</span></span>|<span data-ttu-id="6c498-790">RangeI-U</span><span class="sxs-lookup"><span data-stu-id="6c498-790">RangeI-U</span></span>|  
|<span data-ttu-id="6c498-791">X</span><span class="sxs-lookup"><span data-stu-id="6c498-791">X</span></span>|<span data-ttu-id="6c498-792">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="6c498-792">RangeI-N</span></span>|<span data-ttu-id="6c498-793">RangeI-X</span><span class="sxs-lookup"><span data-stu-id="6c498-793">RangeI-X</span></span>|  
|<span data-ttu-id="6c498-794">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="6c498-794">RangeI-N</span></span>|<span data-ttu-id="6c498-795">RangeS-S</span><span class="sxs-lookup"><span data-stu-id="6c498-795">RangeS-S</span></span>|<span data-ttu-id="6c498-796">RangeX-S</span><span class="sxs-lookup"><span data-stu-id="6c498-796">RangeX-S</span></span>|  
|<span data-ttu-id="6c498-797">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="6c498-797">RangeI-N</span></span>|<span data-ttu-id="6c498-798">RangeS-U</span><span class="sxs-lookup"><span data-stu-id="6c498-798">RangeS-U</span></span>|<span data-ttu-id="6c498-799">RangeX-U</span><span class="sxs-lookup"><span data-stu-id="6c498-799">RangeX-U</span></span>|  
  
 <span data-ttu-id="6c498-800">在不同的複雜環境下，可以觀察到短期的轉換鎖定，有時是在並行的處理序執行時。</span><span class="sxs-lookup"><span data-stu-id="6c498-800">Conversion locks can be observed for a short period of time under different complex circumstances, sometimes while running concurrent processes.</span></span>  
  
#### <a name="serializable-range-scan-singleton-fetch-delete-and-insert"></a><span data-ttu-id="6c498-801">可序列化範圍掃描、單一擷取、刪除以及插入</span><span class="sxs-lookup"><span data-stu-id="6c498-801">Serializable Range Scan, Singleton Fetch, Delete, and Insert</span></span>  

 <span data-ttu-id="6c498-802">索引鍵範圍鎖定可確保下列動作是可序列化：</span><span class="sxs-lookup"><span data-stu-id="6c498-802">Key-range locking ensures that the following operations are serializable:</span></span>  
  
-   <span data-ttu-id="6c498-803">範圍掃描查詢</span><span class="sxs-lookup"><span data-stu-id="6c498-803">Range scan query</span></span>  
  
-   <span data-ttu-id="6c498-804">單一擷取不存在的資料列</span><span class="sxs-lookup"><span data-stu-id="6c498-804">Singleton fetch of nonexistent row</span></span>  
  
-   <span data-ttu-id="6c498-805">刪除動作</span><span class="sxs-lookup"><span data-stu-id="6c498-805">Delete operation</span></span>  
  
-   <span data-ttu-id="6c498-806">插入動作</span><span class="sxs-lookup"><span data-stu-id="6c498-806">Insert operation</span></span>  
  
 <span data-ttu-id="6c498-807">在索引鍵範圍鎖定發生之前，必須滿足下列條件：</span><span class="sxs-lookup"><span data-stu-id="6c498-807">Before key-range locking can occur, the following conditions must be satisfied:</span></span>  
  
-   <span data-ttu-id="6c498-808">交易隔離等級必須設為 SERIALIZABLE。</span><span class="sxs-lookup"><span data-stu-id="6c498-808">The transaction-isolation level must be set to SERIALIZABLE.</span></span>  
  
-   <span data-ttu-id="6c498-809">查詢處理器必須使用索引來實作範圍篩選述詞。</span><span class="sxs-lookup"><span data-stu-id="6c498-809">The query processor must use an index to implement the range filter predicate.</span></span> <span data-ttu-id="6c498-810">例如，SELECT 陳述式中的 WHERE 子句可利用此述詞建立一個範圍條件：ColumnX BETWEEN N **'** AAA **'** AND N **'** CZZ **'** 。</span><span class="sxs-lookup"><span data-stu-id="6c498-810">For example, the WHERE clause in a SELECT statement could establish a range condition with this predicate: ColumnX BETWEEN N **'** AAA **'** AND N **'** CZZ **'**.</span></span> <span data-ttu-id="6c498-811">如果 **ColumnX** 涵蓋在索引鍵中，才會取得索引鍵範圍鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-811">A key-range lock can only be acquired if **ColumnX** is covered by an index key.</span></span>  
  
#### <a name="examples"></a><span data-ttu-id="6c498-812">範例</span><span class="sxs-lookup"><span data-stu-id="6c498-812">Examples</span></span>  

 <span data-ttu-id="6c498-813">下列資料表和索引是用來作為索引鍵範圍鎖定範例要遵循的基礎。</span><span class="sxs-lookup"><span data-stu-id="6c498-813">The following table and index are used as a basis for the key-range locking examples that follow.</span></span>  
  
 <span data-ttu-id="6c498-814">![具有索引 B 型樹狀的資料庫資料表圖例](media/btree4.gif "具有索引 B 型樹狀的資料庫資料表圖例")</span><span class="sxs-lookup"><span data-stu-id="6c498-814">![Database table with index b-tree illustration](media/btree4.gif "Database table with index b-tree illustration")</span></span>  
  
##### <a name="range-scan-query"></a><span data-ttu-id="6c498-815">範圍掃描查詢</span><span class="sxs-lookup"><span data-stu-id="6c498-815">Range Scan Query</span></span>  

 <span data-ttu-id="6c498-816">為了確保範圍掃描查詢是可序列化，相同的查詢每次在相同交易內執行時都必須傳回相同的結果。</span><span class="sxs-lookup"><span data-stu-id="6c498-816">To ensure a range scan query is serializable, the same query should return the same results each time it is executed within the same transaction.</span></span> <span data-ttu-id="6c498-817">其他的交易絕不能把新的資料列插入範圍掃描查詢內；否則這些動作將會變成虛設項目插入。</span><span class="sxs-lookup"><span data-stu-id="6c498-817">New rows must not be inserted within the range scan query by other transactions; otherwise, these become phantom inserts.</span></span> <span data-ttu-id="6c498-818">例如，以下的查詢使用上述的資料表與索引：</span><span class="sxs-lookup"><span data-stu-id="6c498-818">For example, the following query uses the table and index in the previous illustration:</span></span>  
  
```sql  
SELECT name  
    FROM mytable  
    WHERE name BETWEEN 'A' AND 'C';  
```  
  
 <span data-ttu-id="6c498-819">放置索引鍵範圍鎖定的索引項對應到名稱介於資料值 Adam 與 Dale 之間的資料列範圍，讓前次查詢中限定的新資料列無法新增或刪除。</span><span class="sxs-lookup"><span data-stu-id="6c498-819">Key-range locks are placed on the index entries corresponding to the range of data rows where the name is between the values Adam and Dale, preventing new rows qualifying in the previous query from being added or deleted.</span></span> <span data-ttu-id="6c498-820">雖然此範圍內的第一個名稱是 Adam，但位於此索引項的 RangeS-S 模式的索引鍵範圍鎖定會確保以字母 A 開頭的新名稱無法新增至 Adam 前面，例如 Abigail。</span><span class="sxs-lookup"><span data-stu-id="6c498-820">Although the first name in this range is Adam, the RangeS-S mode key-range lock on this index entry ensures that no new names beginning with the letter A can be added before Adam, such as Abigail.</span></span> <span data-ttu-id="6c498-821">同樣的，位於 Dale 的索引項的 RangeS-S 索引鍵範圍鎖定，則確保以字母 C 開頭的新名稱皆無法新增至 Carlos 後面，例如 Clive。</span><span class="sxs-lookup"><span data-stu-id="6c498-821">Similarly, the RangeS-S key-range lock on the index entry for Dale ensures that no new names beginning with the letter C can be added after Carlos, such as Clive.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-822">持有的 RangeS-S 鎖定的數量為 *n*+1，其中 *n* 為符合查詢的資料列數量。</span><span class="sxs-lookup"><span data-stu-id="6c498-822">The number of RangeS-S locks held is *n*+1, where *n* is the number of rows that satisfy the query.</span></span>  
  
##### <a name="singleton-fetch-of-nonexistent-data"></a><span data-ttu-id="6c498-823">單一擷取不存在的資料</span><span class="sxs-lookup"><span data-stu-id="6c498-823">Singleton Fetch of Nonexistent Data</span></span>  

 <span data-ttu-id="6c498-824">如果交易內的查詢嘗試選取不存在的資料列，則在同一筆交易內稍後的某一點所提交的查詢必須傳回相同的結果。</span><span class="sxs-lookup"><span data-stu-id="6c498-824">If a query within a transaction attempts to select a row that does not exist, issuing the query at a later point within the same transaction has to return the same result.</span></span> <span data-ttu-id="6c498-825">其他的任何交易皆不得插入這個不存在的資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-825">No other transaction can be allowed to insert that nonexistent row.</span></span> <span data-ttu-id="6c498-826">例如，給定以下的查詢：</span><span class="sxs-lookup"><span data-stu-id="6c498-826">For example, given this query:</span></span>  
  
```sql 
SELECT name  
    FROM mytable  
    WHERE name = 'Bill';  
```  
  
 <span data-ttu-id="6c498-827">將索引鍵範圍鎖定放在與名稱範圍從 `Ben` 到 `Bing` 對應的索引項，因為要把名稱 `Bill` 插入這兩個相鄰的索引項之間。</span><span class="sxs-lookup"><span data-stu-id="6c498-827">A key-range lock is placed on the index entry corresponding to the name range from `Ben` to `Bing` because the name `Bill` would be inserted between these two adjacent index entries.</span></span> <span data-ttu-id="6c498-828">將 RangeS-S 模式的索引鍵範圍鎖定放在索引項 `Bing`之上。</span><span class="sxs-lookup"><span data-stu-id="6c498-828">The RangeS-S mode key-range lock is placed on the index entry `Bing`.</span></span> <span data-ttu-id="6c498-829">這可預防其他交易將值 (例如 `Bill`) 插入到索引項 `Ben` 和 `Bing`之間。</span><span class="sxs-lookup"><span data-stu-id="6c498-829">This prevents any other transaction from inserting values, such as `Bill`, between the index entries `Ben` and `Bing`.</span></span>  
  
##### <a name="delete-operation"></a><span data-ttu-id="6c498-830">刪除作業</span><span class="sxs-lookup"><span data-stu-id="6c498-830">Delete Operation</span></span>  

 <span data-ttu-id="6c498-831">在交易內刪除某個值時，交易進行刪除動作期間不需鎖定該值所處之範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-831">When deleting a value within a transaction, the range the value falls into does not have to be locked for the duration of the transaction performing the delete operation.</span></span> <span data-ttu-id="6c498-832">鎖定欲刪除的索引鍵值直到交易結束，即足以維持可序列化能力。</span><span class="sxs-lookup"><span data-stu-id="6c498-832">Locking the deleted key value until the end of the transaction is sufficient to maintain serializability.</span></span> <span data-ttu-id="6c498-833">例如，給定以下的 DELETE 陳述式：</span><span class="sxs-lookup"><span data-stu-id="6c498-833">For example, given this DELETE statement:</span></span>  
  
```sql  
DELETE mytable  
    WHERE name = 'Bob';  
```  
  
 <span data-ttu-id="6c498-834">將獨占 (X) 鎖定放在與名稱 `Bob`對應的索引項。</span><span class="sxs-lookup"><span data-stu-id="6c498-834">An exclusive (X) lock is placed on the index entry corresponding to the name `Bob`.</span></span> <span data-ttu-id="6c498-835">其他交易可在被刪除的值 `Bob`前後插入或刪除值。</span><span class="sxs-lookup"><span data-stu-id="6c498-835">Other transactions can insert or delete values before or after the deleted value `Bob`.</span></span> <span data-ttu-id="6c498-836">但是，嘗試讀取、插入或是刪除 `Bob` 這個值的任何交易，在進行刪除動作的交易尚未認可或回復之前都會被封鎖。</span><span class="sxs-lookup"><span data-stu-id="6c498-836">However, any transaction that attempts to read, insert, or delete the value `Bob` will be blocked until the deleting transaction either commits or rolls back.</span></span>  
  
 <span data-ttu-id="6c498-837">可以使用三種基本鎖定模式來執行範圍刪除：資料列、分頁或資料表鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-837">Range delete can be executed using three basic lock modes: row, page, or table lock.</span></span> <span data-ttu-id="6c498-838">資料列、分頁或資料表的鎖定策略是由查詢最佳化工具來決定，或者亦可由使用者透過最佳化提示 (如 ROWLOCK、PAGLOCK 或 TABLOCK) 來指定。</span><span class="sxs-lookup"><span data-stu-id="6c498-838">The row, page, or table locking strategy is decided by query optimizer or can be specified by the user through optimizer hints such as ROWLOCK, PAGLOCK, or TABLOCK.</span></span> <span data-ttu-id="6c498-839">使用 PAGLOCK 或 TABLOCK 時，如果所有資料列都會從此分頁刪除， [!INCLUDE[ssDE](../includes/ssde-md.md)] 會立即重新配置索引頁。</span><span class="sxs-lookup"><span data-stu-id="6c498-839">When PAGLOCK or TABLOCK is used, the [!INCLUDE[ssDE](../includes/ssde-md.md)] immediately deallocates an index page if all rows are deleted from this page.</span></span> <span data-ttu-id="6c498-840">相反的，若是使用 ROWLOCK，所有已刪除的資料列則僅標示為已刪除；稍後再使用背景工作將這些資料列從索引頁中移除。</span><span class="sxs-lookup"><span data-stu-id="6c498-840">In contrast, when ROWLOCK is used, all deleted rows are marked only as deleted; they are removed from the index page later using a background task.</span></span>  
  
##### <a name="insert-operation"></a><span data-ttu-id="6c498-841">插入動作</span><span class="sxs-lookup"><span data-stu-id="6c498-841">Insert Operation</span></span>  

 <span data-ttu-id="6c498-842">在交易內插入某個值時，交易進行插入動作期間不需鎖定該值所處之範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-842">When inserting a value within a transaction, the range the value falls into does not have to be locked for the duration of the transaction performing the insert operation.</span></span> <span data-ttu-id="6c498-843">鎖定欲插入的索引鍵值直到交易結束，即足以維持可序列化能力。</span><span class="sxs-lookup"><span data-stu-id="6c498-843">Locking the inserted key value until the end of the transaction is sufficient to maintain serializability.</span></span> <span data-ttu-id="6c498-844">例如，給定以下的 INSERT 陳述式：</span><span class="sxs-lookup"><span data-stu-id="6c498-844">For example, given this INSERT statement:</span></span>  
  
```sql  
INSERT mytable VALUES ('Dan');  
```  
  
 <span data-ttu-id="6c498-845">將 RangeI-N 模式的索引鍵範圍鎖定放在與名稱 David 對應的索引項來測試範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-845">The RangeI-N mode key-range lock is placed on the index entry corresponding to the name David to test the range.</span></span> <span data-ttu-id="6c498-846">如果授與鎖定，便插入 `Dan` 並將獨占 (X) 鎖定放在 `Dan`這個值。</span><span class="sxs-lookup"><span data-stu-id="6c498-846">If the lock is granted, `Dan` is inserted and an exclusive (X) lock is placed on the value `Dan`.</span></span> <span data-ttu-id="6c498-847">RangeI-N 模式的索引鍵範圍鎖定只有在測試範圍時才需要，且在交易進行插入動作期間不需持有。</span><span class="sxs-lookup"><span data-stu-id="6c498-847">The RangeI-N mode key-range lock is necessary only to test the range and is not held for the duration of the transaction performing the insert operation.</span></span> <span data-ttu-id="6c498-848">其他的交易皆可在插入值 `Dan`的前面或後面插入或刪除值。</span><span class="sxs-lookup"><span data-stu-id="6c498-848">Other transactions can insert or delete values before or after the inserted value `Dan`.</span></span> <span data-ttu-id="6c498-849">但是，嘗試讀取、插入或是刪除 `Dan` 這個值的任何交易在進行插入動作的交易尚未認可或回復之前都會被鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-849">However, any transaction attempting to read, insert, or delete the value `Dan` will be locked until the inserting transaction either commits or rolls back.</span></span>  
  
### <a name="dynamic-locking"></a><span data-ttu-id="6c498-850">動態鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-850">Dynamic Locking</span></span>  

 <span data-ttu-id="6c498-851">使用像資料列鎖定等低層級鎖定，可藉由降低兩個交易同時要求相同片段的資料鎖定之可能性來增加並行。</span><span class="sxs-lookup"><span data-stu-id="6c498-851">Using low-level locks, such as row locks, increases concurrency by decreasing the probability that two transactions will request locks on the same piece of data at the same time.</span></span> <span data-ttu-id="6c498-852">使用低層級鎖定也會增加鎖定的數目以及需要管理鎖定的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-852">Using low-level locks also increases the number of locks and the resources needed to manage them.</span></span> <span data-ttu-id="6c498-853">使用高層級的資料表或頁面鎖定可降低額外負荷，但必須花費降低並行的成本。</span><span class="sxs-lookup"><span data-stu-id="6c498-853">Using high-level table or page locks lowers overhead, but at the expense of lowering concurrency.</span></span>  
  
 <span data-ttu-id="6c498-854">![顯示成本與資料粒度之比較的圖表](media/lockcht.gif "顯示成本與資料粒度之比較的圖表")</span><span class="sxs-lookup"><span data-stu-id="6c498-854">![Diagram showing cost versus granularity](media/lockcht.gif "Diagram showing cost versus granularity")</span></span>  
  
 <span data-ttu-id="6c498-855">[!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]使用動態鎖定策略來判斷最具成本效益的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-855">The [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses a dynamic locking strategy to determine the most cost-effective locks.</span></span> <span data-ttu-id="6c498-856">[!INCLUDE[ssDE](../includes/ssde-md.md)] 在執行查詢時會依照結構描述與查詢的特性，自動決定最合適的鎖定類型。</span><span class="sxs-lookup"><span data-stu-id="6c498-856">The [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically determines what locks are most appropriate when the query is executed, based on the characteristics of the schema and query.</span></span> <span data-ttu-id="6c498-857">例如，為了降低鎖定的額外負荷，最佳化工具在進行索引掃描時可能會選擇頁面層級的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-857">For example, to reduce the overhead of locking, the optimizer may choose page-level locks in an index when performing an index scan.</span></span>  
  
 <span data-ttu-id="6c498-858">動態鎖定具有下列優點：</span><span class="sxs-lookup"><span data-stu-id="6c498-858">Dynamic locking has the following advantages:</span></span>  
  
-   <span data-ttu-id="6c498-859">簡化資料庫的管理。</span><span class="sxs-lookup"><span data-stu-id="6c498-859">Simplified database administration.</span></span> <span data-ttu-id="6c498-860">資料庫管理員並不需要調整鎖定擴大的臨界值。</span><span class="sxs-lookup"><span data-stu-id="6c498-860">Database administrators do not have to adjust lock escalation thresholds.</span></span>  
  
-   <span data-ttu-id="6c498-861">提升效能。</span><span class="sxs-lookup"><span data-stu-id="6c498-861">Increased performance.</span></span> <span data-ttu-id="6c498-862">[!INCLUDE[ssDE](../includes/ssde-md.md)] 藉由使用適合於工作的鎖定，將系統的負擔降至最低。</span><span class="sxs-lookup"><span data-stu-id="6c498-862">The [!INCLUDE[ssDE](../includes/ssde-md.md)] minimizes system overhead by using locks appropriate to the task.</span></span>  
  
-   <span data-ttu-id="6c498-863">應用程式開發人員可以專注於開發。</span><span class="sxs-lookup"><span data-stu-id="6c498-863">Application developers can concentrate on development.</span></span> <span data-ttu-id="6c498-864">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會自動調整鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-864">The [!INCLUDE[ssDE](../includes/ssde-md.md)] adjusts locking automatically.</span></span>  
  
 <span data-ttu-id="6c498-865">在 [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 及更新版本中，隨著 LOCK_ESCALATION 選項的引進，鎖定擴大的行為也已經變更。</span><span class="sxs-lookup"><span data-stu-id="6c498-865">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the behavior of lock escalation has changed with the introduction of the LOCK_ESCALATION option.</span></span> <span data-ttu-id="6c498-866">如需詳細資訊，請參閱＜ [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql)＞的 LOCK_ESCALATION 選項。</span><span class="sxs-lookup"><span data-stu-id="6c498-866">For more information, see the LOCK_ESCALATION option of [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
### <a name="deadlocking"></a><span data-ttu-id="6c498-867">死結</span><span class="sxs-lookup"><span data-stu-id="6c498-867">Deadlocking</span></span>  

 <span data-ttu-id="6c498-868">當二或多個工作各自具有某個資源的鎖定，但其他工作嘗試要鎖定此資源，而造成工作永久封鎖彼此時，會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-868">A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock.</span></span> <span data-ttu-id="6c498-869">例如：</span><span class="sxs-lookup"><span data-stu-id="6c498-869">For example:</span></span>  
  
-   <span data-ttu-id="6c498-870">交易 A 取得資料列 1 的共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-870">Transaction A acquires a share lock on row 1.</span></span>  
  
-   <span data-ttu-id="6c498-871">交易 B 取得資料列 2 的共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-871">Transaction B acquires a share lock on row 2.</span></span>  
  
-   <span data-ttu-id="6c498-872">交易 A 現在要求資料列 2 的獨佔鎖定，但會被封鎖直到交易 B 完成並釋出對資料列 2 的共用鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-872">Transaction A now requests an exclusive lock on row 2, and is blocked until transaction B finishes and releases the share lock it has on row 2.</span></span>  
  
-   <span data-ttu-id="6c498-873">交易 B 現在要求資料列 1 的獨佔鎖定，但會被封鎖直到交易 A 完成並釋出對資料列 1 的共用鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-873">Transaction B now requests an exclusive lock on row 1, and is blocked until transaction A finishes and releases the share lock it has on row 1.</span></span>  
  
 <span data-ttu-id="6c498-874">等到交易 B 完成後，交易 A 才能完成，但交易 B 卻被交易 A 封鎖了。這個狀況也稱為「循環相依性」：交易 A 相依於交易 B，且交易 B 因為相依於交易 A 而形成封閉式循環。</span><span class="sxs-lookup"><span data-stu-id="6c498-874">Transaction A cannot complete until transaction B completes, but transaction B is blocked by transaction A. This condition is also called a cyclic dependency: Transaction A has a dependency on transaction B, and transaction B closes the circle by having a dependency on transaction A.</span></span>  
  
 <span data-ttu-id="6c498-875">在死結中的這兩個交易會一直等下去，除非由外部處理序解除此死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-875">Both transactions in a deadlock will wait forever unless the deadlock is broken by an external process.</span></span> <span data-ttu-id="6c498-876">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 死結監視器會定期檢查是否有工作處於死結狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-876">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] deadlock monitor periodically checks for tasks that are in a deadlock.</span></span> <span data-ttu-id="6c498-877">如果監視器偵測到循環相依性，它會選擇其中一個工作作為犧牲者，以錯誤來結束其交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-877">If the monitor detects a cyclic dependency, it chooses one of the tasks as a victim and terminates its transaction with an error.</span></span> <span data-ttu-id="6c498-878">這樣另一個工作便可以完成其交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-878">This allows the other task to complete its transaction.</span></span> <span data-ttu-id="6c498-879">因為錯誤而結束交易的應用程式可以重試交易，通常在另一個死結交易完成之後便會完成。</span><span class="sxs-lookup"><span data-stu-id="6c498-879">The application with the transaction that terminated with an error can retry the transaction, which usually completes after the other deadlocked transaction has finished.</span></span>  
  
 <span data-ttu-id="6c498-880">死結通常會和一般的封鎖產生混淆。</span><span class="sxs-lookup"><span data-stu-id="6c498-880">Deadlocking is often confused with normal blocking.</span></span> <span data-ttu-id="6c498-881">當交易要求鎖定的資源被另一個交易鎖定時，提出要求的交易會等待鎖定釋出。</span><span class="sxs-lookup"><span data-stu-id="6c498-881">When a transaction requests a lock on a resource locked by another transaction, the requesting transaction waits until the lock is released.</span></span> <span data-ttu-id="6c498-882">依預設，除非設定了 LOCK_TIMEOUT，否則 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 交易不會逾時。</span><span class="sxs-lookup"><span data-stu-id="6c498-882">By default, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] transactions do not time out, unless LOCK_TIMEOUT is set.</span></span> <span data-ttu-id="6c498-883">提出要求的交易會被封鎖，但非死結，因為提出要求的交易尚未封鎖目前擁有鎖定的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-883">The requesting transaction is blocked, not deadlocked, because the requesting transaction has not done anything to block the transaction owning the lock.</span></span> <span data-ttu-id="6c498-884">最後，主控交易會完成並釋出鎖定，然後提出要求的交易會被授與鎖定並繼續進行。</span><span class="sxs-lookup"><span data-stu-id="6c498-884">Eventually, the owning transaction will complete and release the lock, and then the requesting transaction will be granted the lock and proceed.</span></span>  
  
 <span data-ttu-id="6c498-885">死結 (Deadlock) 有時也稱為致命環節 (Deadly Embrace)。</span><span class="sxs-lookup"><span data-stu-id="6c498-885">Deadlocks are sometimes called a deadly embrace.</span></span>  
  
 <span data-ttu-id="6c498-886">死結可能發生在任何具有多執行緒的系統上，而不只是在關聯式資料庫管理系統，並且可能發生在資料庫物件鎖定之外的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-886">Deadlock is a condition that can occur on any system with multiple threads, not just on a relational database management system, and can occur for resources other than locks on database objects.</span></span> <span data-ttu-id="6c498-887">例如，在多執行緒作業系統中的一個執行緒可能取得一或多個資源，像是記憶體區塊。</span><span class="sxs-lookup"><span data-stu-id="6c498-887">For example, a thread in a multithreaded operating system might acquire one or more resources, such as blocks of memory.</span></span> <span data-ttu-id="6c498-888">若要取得的資源目前為另一個執行緒所擁有，前者的執行緒可能就必須等候擁有資源的執行緒釋放目標資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-888">If the resource being acquired is currently owned by another thread, the first thread may have to wait for the owning thread to release the target resource.</span></span> <span data-ttu-id="6c498-889">等候的執行緒便是所謂的與擁有該特定資源的執行緒具有依存性。</span><span class="sxs-lookup"><span data-stu-id="6c498-889">The waiting thread is said to have a dependency on the owning thread for that particular resource.</span></span> <span data-ttu-id="6c498-890">在 [!INCLUDE[ssDE](../includes/ssde-md.md)]的執行個體中，當工作階段取得非資料庫資源 (例如記憶體或執行緒) 時，可能會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-890">In an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], sessions can deadlock when acquiring nondatabase resources, such as memory or threads.</span></span>  
  
 <span data-ttu-id="6c498-891">![顯示交易死結的圖表](media/dedlck1.gif "顯示交易死結的圖表")</span><span class="sxs-lookup"><span data-stu-id="6c498-891">![Diagram showing transaction deadlock](media/dedlck1.gif "Diagram showing transaction deadlock")</span></span>  
  
 <span data-ttu-id="6c498-892">在上圖中，在 **Part** 資料表鎖定資源上，交易 T1 相依於交易 T2。</span><span class="sxs-lookup"><span data-stu-id="6c498-892">In the illustration, transaction T1 has a dependency on transaction T2 for the **Part** table lock resource.</span></span> <span data-ttu-id="6c498-893">同樣的，在 **Supplier** 資料表鎖定資源上，交易 T2 相依於交易 T1。</span><span class="sxs-lookup"><span data-stu-id="6c498-893">Similarly, transaction T2 has a dependency on transaction T1 for the **Supplier** table lock resource.</span></span> <span data-ttu-id="6c498-894">由於這些相依性形成循環，交易 T1 與 T2 之間便構成死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-894">Because these dependencies form a cycle, there is a deadlock between transactions T1 and T2.</span></span>  
  
 <span data-ttu-id="6c498-895">當資料表已分割，而且 ALTER TABLE 的 LOCK_ESCALATION 設定為 AUTO 時，也可能會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-895">Deadlocks can also occur when a table is partitioned and the LOCK_ESCALATION setting of ALTER TABLE is set to AUTO.</span></span> <span data-ttu-id="6c498-896">當 LOCK_ESCALATION 設定為 AUTO 時，可讓 [!INCLUDE[ssDE](../includes/ssde-md.md)] 鎖定 HoBT 層級 (而不是 TABLE 層級) 上的資料表資料分割來增加並行。</span><span class="sxs-lookup"><span data-stu-id="6c498-896">When LOCK_ESCALATION is set to AUTO, concurrency increases by allowing the [!INCLUDE[ssDE](../includes/ssde-md.md)] to lock table partitions at the HoBT level instead of at the TABLE level.</span></span> <span data-ttu-id="6c498-897">但是，當個別交易在資料表中保留資料分割鎖定，而且想要鎖定其他交易資料分割上的某個地方時，這就會造成死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-897">However, when separate transactions hold partition locks in a table and want a lock somewhere on the other transactions partition, this causes a deadlock.</span></span> <span data-ttu-id="6c498-898">您可以將 LOCK_ESCALATION 設定為 TABLE 來避免這種類型的死結；雖然這項設定會藉由強制資料分割的大量更新等候資料表鎖定，因而減少並行。</span><span class="sxs-lookup"><span data-stu-id="6c498-898">This type of deadlock can be avoided by setting LOCK_ESCALATION to TABLE; although this setting will reduce concurrency by forcing large updates to a partition to wait for a table lock.</span></span>  
  
#### <a name="detecting-and-ending-deadlocks"></a><span data-ttu-id="6c498-899">偵測與結束死結</span><span class="sxs-lookup"><span data-stu-id="6c498-899">Detecting and Ending Deadlocks</span></span>  

 <span data-ttu-id="6c498-900">當二或多個工作各自具有某個資源的鎖定，但其他工作嘗試要鎖定此資源，而造成工作永久封鎖彼此時，會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-900">A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock.</span></span> <span data-ttu-id="6c498-901">下圖顯示死結狀態的高階檢視，其中：</span><span class="sxs-lookup"><span data-stu-id="6c498-901">The following graph presents a high level view of a deadlock state where:</span></span>  
  
-   <span data-ttu-id="6c498-902">工作 T1 有資源 R1 的鎖定 (由 R1 到 T1 的箭頭所表示)，並且已要求資源 R2 的鎖定 (由 T1 到 R2 的箭頭所表示)。</span><span class="sxs-lookup"><span data-stu-id="6c498-902">Task T1 has a lock on resource R1 (indicated by the arrow from R1 to T1) and has requested a lock on resource R2 (indicated by the arrow from T1 to R2).</span></span>  
  
-   <span data-ttu-id="6c498-903">工作 T2 有資源 R2 的鎖定 (由 R2 到 T2 的箭頭所表示)，並且已要求資源 R1 的鎖定 (由 T2 到 R1 的箭頭所表示)。</span><span class="sxs-lookup"><span data-stu-id="6c498-903">Task T2 has a lock on resource R2 (indicated by the arrow from R2 to T2) and has requested a lock on resource R1 (indicated by the arrow from T2 to R1).</span></span>  
  
-   <span data-ttu-id="6c498-904">因為在有資源可用之前，沒有一項工作可以繼續，而在有工作繼續之前，沒有一項資源可以釋放，所以會有死結狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-904">Because neither task can continue until a resource is available and neither resource can be released until a task continues, a deadlock state exists.</span></span>  
  
 <span data-ttu-id="6c498-905">![顯示處於死結狀態的工作其圖表](media/task-deadlock-state.gif "顯示處於死結狀態的工作其圖表")</span><span class="sxs-lookup"><span data-stu-id="6c498-905">![Diagram showing tasks in a deadlock state](media/task-deadlock-state.gif "Diagram showing tasks in a deadlock state")</span></span>  
  
 <span data-ttu-id="6c498-906">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 自動偵測 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中的死結循環。</span><span class="sxs-lookup"><span data-stu-id="6c498-906">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] automatically detects deadlock cycles within [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6c498-907">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會選擇其中一個工作階段作為死結犧牲者，讓目前交易終止並產生錯誤，以破除死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-907">The [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses one of the sessions as a deadlock victim and the current transaction is terminated with an error to break the deadlock.</span></span>  
  
##### <a name="resources-that-can-deadlock"></a><span data-ttu-id="6c498-908">可能發生死結的資源</span><span class="sxs-lookup"><span data-stu-id="6c498-908">Resources That Can Deadlock</span></span>  

 <span data-ttu-id="6c498-909">每個使用者工作階段可能有一或多個工作代表工作階段執行，其中每個工作可能會取得或等待取得各種資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-909">Each user session might have one or more tasks running on its behalf where each task might acquire or wait to acquire a variety of resources.</span></span> <span data-ttu-id="6c498-910">下列類型的資源會導致封鎖，而造成死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-910">The following types of resources can cause blocking that could result in a deadlock.</span></span>  
  
-   <span data-ttu-id="6c498-911">**鎖定**。</span><span class="sxs-lookup"><span data-stu-id="6c498-911">**Locks**.</span></span> <span data-ttu-id="6c498-912">等待取得像是物件、分頁、資料列、中繼資料和應用程式等資源的鎖定，可能會導致死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-912">Waiting to acquire locks on resources, such as objects, pages, rows, metadata, and applications can cause deadlock.</span></span> <span data-ttu-id="6c498-913">例如，交易 T1 有資料列 r1 的共用 (S) 鎖定，並且正在等待取得 r2 的獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-913">For example, transaction T1 has a shared (S) lock on row r1 and is waiting to get an exclusive (X) lock on r2.</span></span> <span data-ttu-id="6c498-914">交易 T2 有 r2 的共用 (S) 鎖定，並且正在等待取得資料列 r1 的獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-914">Transaction T2 has a shared (S) lock on r2 and is waiting to get an exclusive (X) lock on row r1.</span></span> <span data-ttu-id="6c498-915">這樣會產生鎖定循環，因為 T1 和 T2 都在等待對方釋放已鎖定的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-915">This results in a lock cycle in which T1 and T2 wait for each other to release the locked resources.</span></span>  
  
-   <span data-ttu-id="6c498-916">**工作者執行緒**。</span><span class="sxs-lookup"><span data-stu-id="6c498-916">**Worker threads**.</span></span> <span data-ttu-id="6c498-917">等待可用工作者執行緒的佇列工作，可能會導致死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-917">A queued task waiting for an available worker thread can cause deadlock.</span></span> <span data-ttu-id="6c498-918">如果佇列工作擁有正在封鎖所有工作者執行緒的資源，便會產生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-918">If the queued task owns resources that are blocking all worker threads, a deadlock will result.</span></span> <span data-ttu-id="6c498-919">例如，工作階段 S1 啟動交易，並且取得資料列 r1 的共用 (S) 鎖定，然後進入睡眠。</span><span class="sxs-lookup"><span data-stu-id="6c498-919">For example, session S1 starts a transaction and acquires a shared (S) lock on row r1 and then goes to sleep.</span></span> <span data-ttu-id="6c498-920">在所有可用工作者執行緒上執行的使用中工作階段，正在嘗試取得資料列 r1 的獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-920">Active sessions running on all available worker threads are trying to acquire exclusive (X) locks on row r1.</span></span> <span data-ttu-id="6c498-921">因為工作階段 S1 無法取得工作者執行緒，所以它無法認可交易並釋放資料列 r1 的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-921">Because session S1 cannot acquire a worker thread, it cannot commit the transaction and release the lock on row r1.</span></span> <span data-ttu-id="6c498-922">這樣會產生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-922">This results in a deadlock.</span></span>  
  
-   <span data-ttu-id="6c498-923">**記憶體**。</span><span class="sxs-lookup"><span data-stu-id="6c498-923">**Memory**.</span></span> <span data-ttu-id="6c498-924">當並行要求正在等待記憶體授權，但可用記憶體不足而無法滿足授權時，便會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-924">When concurrent requests are waiting for memory grants that cannot be satisfied with the available memory, a deadlock can occur.</span></span> <span data-ttu-id="6c498-925">例如，兩個並行查詢 Q1 和 Q2 以使用者自訂函數執行，分別取得 10MB 和 20MB 記憶體。</span><span class="sxs-lookup"><span data-stu-id="6c498-925">For example, two concurrent queries, Q1 and Q2, execute as user-defined functions that acquire 10MB and 20MB of memory respectively.</span></span> <span data-ttu-id="6c498-926">如果每個查詢需要 30MB 而可用的總記憶體是 20MB，則 Q1 和 Q2 必須等待對方釋放記憶體。這樣會產生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-926">If each query needs 30MB and the total available memory is 20MB, then Q1 and Q2 must wait for each other to release memory, and this results in a deadlock.</span></span>  
  
-   <span data-ttu-id="6c498-927">**與執行平行查詢相關的資源** 。與交換通訊埠相關聯的協調器、產生者或取用者，通常在包含至少一個不屬於平行查詢的其他處理序時，可能會彼此封鎖，而導致死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-927">**Parallel query execution-related resources** Coordinator, producer, or consumer threads associated with an exchange port may block each other causing a deadlock usually when including at least one other process that is not a part of the parallel query.</span></span> <span data-ttu-id="6c498-928">而且，當平行查詢開始執行時， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 會根據目前工作負載來判斷平行程度或工作者執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="6c498-928">Also, when a parallel query starts execution, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] determines the degree of parallelism, or the number of worker threads, based upon the current workload.</span></span> <span data-ttu-id="6c498-929">如果系統工作負載意外變更，例如有新查詢開始在伺服器上執行或系統的工作者執行緒用盡，此時會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-929">If the system workload unexpectedly changes, for example, where new queries start running on the server or the system runs out of worker threads, then a deadlock could occur.</span></span>  
  
-   <span data-ttu-id="6c498-930">**Multiple Active Result Set (MARS) 資源**。</span><span class="sxs-lookup"><span data-stu-id="6c498-930">**Multiple Active Result Sets (MARS) resources**.</span></span> <span data-ttu-id="6c498-931">這些資源在 MARS 下是用來控制多個使用中要求的交錯情形。</span><span class="sxs-lookup"><span data-stu-id="6c498-931">These resources are used to control interleaving of multiple active requests under MARS.</span></span> <span data-ttu-id="6c498-932">如需詳細資訊，請參閱 [SQL Server 中的 Multiple Active Result Sets (MARS)](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx)。</span><span class="sxs-lookup"><span data-stu-id="6c498-932">For more information, see [Multiple Active Result Sets (MARS) in SQL Server](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx).</span></span>  
  
    -   <span data-ttu-id="6c498-933">**使用者資源**。</span><span class="sxs-lookup"><span data-stu-id="6c498-933">**User resource**.</span></span> <span data-ttu-id="6c498-934">當執行緒正在等待的資源可能受使用者應用程式控制時，此資源會視為外部或使用者資源，並且如同鎖定處理。</span><span class="sxs-lookup"><span data-stu-id="6c498-934">When a thread is waiting for a resource that is potentially controlled by a user application, the resource is considered to be an external or user resource and is treated like a lock.</span></span>  
  
    -   <span data-ttu-id="6c498-935">**工作階段 Mutex**。</span><span class="sxs-lookup"><span data-stu-id="6c498-935">**Session mutex**.</span></span> <span data-ttu-id="6c498-936">工作階段中執行的工作為交錯的，這表示同時只能有一個工作在此工作階段執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-936">The tasks running in one session are interleaved, meaning that only one task can run under the session at a given time.</span></span> <span data-ttu-id="6c498-937">工作必須具有對工作階段 Mutex 的獨佔存取權才能執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-937">Before the task can run, it must have exclusive access to the session mutex.</span></span>  
  
    -   <span data-ttu-id="6c498-938">**交易 Mutex**。</span><span class="sxs-lookup"><span data-stu-id="6c498-938">**Transaction mutex**.</span></span> <span data-ttu-id="6c498-939">交易中執行的所有工作為交錯的，這表示同時只能有一個工作在此交易執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-939">All tasks running in one transaction are interleaved, meaning that only one task can run under the transaction at a given time.</span></span> <span data-ttu-id="6c498-940">工作必須具有對交易 Mutex 的獨佔存取權才能執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-940">Before the task can run, it must have exclusive access to the transaction mutex.</span></span>  
  
     <span data-ttu-id="6c498-941">工作必須取得工作階段 Mutex，才能在 MARS 下執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-941">In order for a task to run under MARS, it must acquire the session mutex.</span></span> <span data-ttu-id="6c498-942">如果工作在交易下執行，則它必須接著取得交易 Mutex。</span><span class="sxs-lookup"><span data-stu-id="6c498-942">If the task is running under a transaction, it must then acquire the transaction mutex.</span></span> <span data-ttu-id="6c498-943">這可保證在給定工作階段和給定交易中，同時只有一個工作使用中。</span><span class="sxs-lookup"><span data-stu-id="6c498-943">This guarantees that only one task is active at one time in a given session and a given transaction.</span></span> <span data-ttu-id="6c498-944">一旦取得所需的 Mutex，工作即可執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-944">Once the required mutexes have been acquired, the task can execute.</span></span> <span data-ttu-id="6c498-945">當工作完成或在要求中途退出時，會以取得 Mutex 的相反順序，先釋放交易 Mutex，接著再釋放工作階段 Mutex。</span><span class="sxs-lookup"><span data-stu-id="6c498-945">When the task finishes, or yields in the middle of the request, it will first release transaction mutex followed by the session mutex in reverse order of acquisition.</span></span> <span data-ttu-id="6c498-946">不過，這些資源可能會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-946">However, deadlocks can occur with these resources.</span></span> <span data-ttu-id="6c498-947">在下列程式碼範例中，同一個工作階段中執行了兩個工作 (使用者要求 U1 和使用者要求 U2)。</span><span class="sxs-lookup"><span data-stu-id="6c498-947">In the following code example, two tasks, user request U1 and user request U2, are running in the same session.</span></span>  
  
    ```  
    U1:    Rs1=Command1.Execute("insert sometable EXEC usp_someproc");  
    U2:    Rs2=Command2.Execute("select colA from sometable");  
    ```  
  
     <span data-ttu-id="6c498-948">從使用者要求 U1 執行的預存程序已取得工作階段 Mutex。</span><span class="sxs-lookup"><span data-stu-id="6c498-948">The stored procedure executing from user request U1 has acquired the session mutex.</span></span> <span data-ttu-id="6c498-949">如果預存程序花很長的時間執行，則 [!INCLUDE[ssDE](../includes/ssde-md.md)] 會假設此預存程序正在等待使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="6c498-949">If the stored procedure takes a long time to execute, it is assumed by the [!INCLUDE[ssDE](../includes/ssde-md.md)] that the stored procedure is waiting for input from the user.</span></span> <span data-ttu-id="6c498-950">當使用者正在等待 U2 的結果集時，使用者要求 U2 正在等待工作階段 Mutex，而 U1 正在等待使用者資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-950">User request U2 is waiting for the session mutex while the user is waiting for the result set from U2, and U1 is waiting for a user resource.</span></span> <span data-ttu-id="6c498-951">這就是死結狀態，邏輯上可用下圖說明：</span><span class="sxs-lookup"><span data-stu-id="6c498-951">This is deadlock state logically illustrated as:</span></span>  
  
 <span data-ttu-id="6c498-952">![顯示使用者處理序死結的邏輯圖。](media/udb9-logicflowexamplec.gif "顯示使用者處理序死結的邏輯圖。")</span><span class="sxs-lookup"><span data-stu-id="6c498-952">![Logic diagram showing user process deadlock.](media/udb9-logicflowexamplec.gif "Logic diagram showing user process deadlock.")</span></span>  
  
##### <a name="deadlock-detection"></a><span data-ttu-id="6c498-953">死結偵測</span><span class="sxs-lookup"><span data-stu-id="6c498-953">Deadlock Detection</span></span>  

 <span data-ttu-id="6c498-954">上節列出的所有資源都參與 [!INCLUDE[ssDE](../includes/ssde-md.md)] 死結偵測配置。</span><span class="sxs-lookup"><span data-stu-id="6c498-954">All of the resources listed in the section above participate in the [!INCLUDE[ssDE](../includes/ssde-md.md)] deadlock detection scheme.</span></span> <span data-ttu-id="6c498-955">死結偵測由鎖定監視器執行緒所執行，它會定期在 [!INCLUDE[ssDE](../includes/ssde-md.md)]執行個體的所有工作中啟動搜尋。</span><span class="sxs-lookup"><span data-stu-id="6c498-955">Deadlock detection is performed by a lock monitor thread that periodically initiates a search through all of the tasks in an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span> <span data-ttu-id="6c498-956">下列幾點描述搜尋程序：</span><span class="sxs-lookup"><span data-stu-id="6c498-956">The following points describe the search process:</span></span>  
  
-   <span data-ttu-id="6c498-957">預設間隔是 5 秒。</span><span class="sxs-lookup"><span data-stu-id="6c498-957">The default interval is 5 seconds.</span></span>  
  
-   <span data-ttu-id="6c498-958">如果鎖定監視器執行緒發現死結，死結偵測間隔會從 5 秒降低，最低降至 100 毫秒，視死結頻率而定。</span><span class="sxs-lookup"><span data-stu-id="6c498-958">If the lock monitor thread finds deadlocks, the deadlock detection interval will drop from 5 seconds to as low as 100 milliseconds depending on the frequency of deadlocks.</span></span>  
  
-   <span data-ttu-id="6c498-959">如果鎖定監視器執行緒停止尋找死結， [!INCLUDE[ssDE](../includes/ssde-md.md)] 會增加搜尋間隔為 5 秒。</span><span class="sxs-lookup"><span data-stu-id="6c498-959">If the lock monitor thread stops finding deadlocks, the [!INCLUDE[ssDE](../includes/ssde-md.md)] increases the intervals between searches to 5 seconds.</span></span>  
  
-   <span data-ttu-id="6c498-960">如果剛偵測到死結，則會假設後續還有必須等待鎖定的執行緒進入死結循環。</span><span class="sxs-lookup"><span data-stu-id="6c498-960">If a deadlock has just been detected, it is assumed that the next threads that must wait for a lock are entering the deadlock cycle.</span></span> <span data-ttu-id="6c498-961">在偵測到死結之後，前面幾個鎖定等待會立即觸發死結搜尋，而不需等到下個死結偵測間隔。</span><span class="sxs-lookup"><span data-stu-id="6c498-961">The first couple of lock waits after a deadlock has been detected will immediately trigger a deadlock search rather than wait for the next deadlock detection interval.</span></span> <span data-ttu-id="6c498-962">例如，如果目前間隔是 5 秒，並且剛偵測到死結，則下個鎖定等待會立即啟動死結偵測設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-962">For example, if the current interval is 5 seconds, and a deadlock was just detected, the next lock wait will kick off the deadlock detector immediately.</span></span> <span data-ttu-id="6c498-963">如果這個鎖定等待是死結的一部分，則會立即偵測到它，而不需等到下個死結搜尋期間。</span><span class="sxs-lookup"><span data-stu-id="6c498-963">If this lock wait is part of a deadlock, it will be detected right away rather than during next deadlock search.</span></span>  
  
 <span data-ttu-id="6c498-964">[!INCLUDE[ssDE](../includes/ssde-md.md)] 通常僅執行定期的死結偵測。</span><span class="sxs-lookup"><span data-stu-id="6c498-964">The [!INCLUDE[ssDE](../includes/ssde-md.md)] typically performs periodic deadlock detection only.</span></span> <span data-ttu-id="6c498-965">由於系統會遇到的死結數量通常很少，週期的死結偵測即可協助將系統在死結偵測上的額外負荷降低。</span><span class="sxs-lookup"><span data-stu-id="6c498-965">Because the number of deadlocks encountered in the system is usually small, periodic deadlock detection helps to reduce the overhead of deadlock detection in the system.</span></span>  
  
 <span data-ttu-id="6c498-966">當鎖定監視執行緒為特定的執行緒啟動死結搜尋時，便對執行緒正在等候的資源進行識別。</span><span class="sxs-lookup"><span data-stu-id="6c498-966">When the lock monitor initiates deadlock search for a particular thread, it identifies the resource on which the thread is waiting.</span></span> <span data-ttu-id="6c498-967">而後再由鎖定監視找出該特定資源的擁有者執行緒，並繼續為這些執行緒進行遞迴的死結搜尋直到找出循環為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-967">The lock monitor then finds the owner(s) for that particular resource and recursively continues the deadlock search for those threads until it finds a cycle.</span></span> <span data-ttu-id="6c498-968">以此方式識別到的循環即構成死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-968">A cycle identified in this manner forms a deadlock.</span></span>  
  
 <span data-ttu-id="6c498-969">在偵測到死結之後， [!INCLUDE[ssDE](../includes/ssde-md.md)] 會選擇其中一個執行緒作為死結犧牲者，結束死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-969">After a deadlock is detected, the [!INCLUDE[ssDE](../includes/ssde-md.md)] ends a deadlock by choosing one of the threads as a deadlock victim.</span></span> <span data-ttu-id="6c498-970">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會結束目前為此執行緒所執行的批次、回復死結犧牲者的交易，並且傳回 1205 錯誤至應用程式。</span><span class="sxs-lookup"><span data-stu-id="6c498-970">The [!INCLUDE[ssDE](../includes/ssde-md.md)] terminates the current batch being executed for the thread, rolls back the transaction of the deadlock victim, and returns a 1205 error to the application.</span></span> <span data-ttu-id="6c498-971">回復死結犧牲者的交易，將會釋放交易所持有的所有鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-971">Rolling back the transaction for the deadlock victim releases all locks held by the transaction.</span></span> <span data-ttu-id="6c498-972">這可讓其他執行緒的交易變成解除封鎖的狀態並繼續進行。</span><span class="sxs-lookup"><span data-stu-id="6c498-972">This allows the transactions of the other threads to become unblocked and continue.</span></span> <span data-ttu-id="6c498-973">1205 死結犧牲者錯誤會將與死結相關的執行緒和資源資訊記錄在錯誤記錄檔中。</span><span class="sxs-lookup"><span data-stu-id="6c498-973">The 1205 deadlock victim error records information about the threads and resources involved in a deadlock in the error log.</span></span>  
  
 <span data-ttu-id="6c498-974">依預設， [!INCLUDE[ssDE](../includes/ssde-md.md)] 會選擇執行回復成本最低之交易的工作階段作為死結犧牲者。</span><span class="sxs-lookup"><span data-stu-id="6c498-974">By default, the [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses as the deadlock victim the session running the transaction that is least expensive to roll back.</span></span> <span data-ttu-id="6c498-975">或者，使用者也可以使用 SET DEADLOCK_PRIORITY 陳述式，指定死結情況下工作階段的優先權。</span><span class="sxs-lookup"><span data-stu-id="6c498-975">Alternatively, a user can specify the priority of sessions in a deadlock situation using the SET DEADLOCK_PRIORITY statement.</span></span> <span data-ttu-id="6c498-976">DEADLOCK_PRIORITY 可以設為 LOW、NORMAL 或 HIGH，或設為 -10 到 10 範圍內的任何整數值。</span><span class="sxs-lookup"><span data-stu-id="6c498-976">DEADLOCK_PRIORITY can be set to LOW, NORMAL, or HIGH, or alternatively can be set to any integer value in the range (-10 to 10).</span></span> <span data-ttu-id="6c498-977">死結優先權預設為 NORMAL。</span><span class="sxs-lookup"><span data-stu-id="6c498-977">The deadlock priority defaults to NORMAL.</span></span> <span data-ttu-id="6c498-978">如果兩個工作階段有不同的死結優先權，優先權較低的工作階段會被選為死結犧牲者。</span><span class="sxs-lookup"><span data-stu-id="6c498-978">If two sessions have different deadlock priorities, the session with the lower priority is chosen as the deadlock victim.</span></span> <span data-ttu-id="6c498-979">如果兩個工作階段有相同的死結優先權，則會選擇回復成本最低之交易的工作階段。</span><span class="sxs-lookup"><span data-stu-id="6c498-979">If both sessions have the same deadlock priority, the session with the transaction that is least expensive to roll back is chosen.</span></span> <span data-ttu-id="6c498-980">如果死結循環中相關的工作階段具有相同的死結優先權和相同成本，則會隨機選擇犧牲者。</span><span class="sxs-lookup"><span data-stu-id="6c498-980">If sessions involved in the deadlock cycle have the same deadlock priority and the same cost, a victim is chosen randomly.</span></span>  
  
 <span data-ttu-id="6c498-981">使用 CLR 時，死結監視器會為 Managed 程序內所存取的同步處理資源 (監視器、讀取器/寫入器鎖定和執行緒聯結) 自動偵測是否有死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-981">When working with CLR, the deadlock monitor automatically detects deadlock for synchronization resources (monitors, reader/writer lock and thread join) accessed inside managed procedures.</span></span> <span data-ttu-id="6c498-982">不過，死結是透過在選為死結犧牲者的程序中擲回例外狀況來解決。</span><span class="sxs-lookup"><span data-stu-id="6c498-982">However, the deadlock is resolved by throwing an exception in the procedure that was selected to be the deadlock victim.</span></span> <span data-ttu-id="6c498-983">例外狀況並不會自動釋放犧牲者目前所擁有的資源；您必須明確釋放資源，了解這點很重要。</span><span class="sxs-lookup"><span data-stu-id="6c498-983">It is important to understand that the exception does not automatically release resources currently owned by the victim; the resources must be explicitly released.</span></span> <span data-ttu-id="6c498-984">與例外狀況行為一致，用來識別死結犧牲者的例外狀況可以在發生後解除。</span><span class="sxs-lookup"><span data-stu-id="6c498-984">Consistent with exception behavior, the exception used to identify a deadlock victim can be caught and dismissed.</span></span>  
  
##### <a name="deadlock-information-tools"></a><span data-ttu-id="6c498-985">死結資訊工具</span><span class="sxs-lookup"><span data-stu-id="6c498-985">Deadlock Information Tools</span></span>  

 <span data-ttu-id="6c498-986">為了檢視死結資訊， [!INCLUDE[ssDE](../includes/ssde-md.md)] 以兩個追蹤旗標的形式以及 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)]中的死結圖形事件來提供監督工具。</span><span class="sxs-lookup"><span data-stu-id="6c498-986">To view deadlock information, the [!INCLUDE[ssDE](../includes/ssde-md.md)] provides monitoring tools in the form of two trace flags, and the deadlock graph event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)].</span></span>  
  
###### <a name="trace-flag-1204-and-trace-flag-1222"></a><span data-ttu-id="6c498-987">追蹤旗標 1204 和追蹤旗標 1222</span><span class="sxs-lookup"><span data-stu-id="6c498-987">Trace Flag 1204 and Trace Flag 1222</span></span>  

 <span data-ttu-id="6c498-988">發生死結時，追蹤旗標 1204 和追蹤旗標 1222 會傳回在 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 錯誤記錄檔中擷取到的資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-988">When deadlocks occur, trace flag 1204 and trace flag 1222 return information that is captured in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span> <span data-ttu-id="6c498-989">追蹤旗標 1204 報告死結所涉及的每一個節點格式化的死結資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-989">Trace flag 1204 reports deadlock information formatted by each node involved in the deadlock.</span></span> <span data-ttu-id="6c498-990">追蹤旗標 1222 先按處理序再按資源來格式化死結資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-990">Trace flag 1222 formats deadlock information, first by processes and then by resources.</span></span> <span data-ttu-id="6c498-991">可同時啟用兩種追蹤旗標來取得相同死結事件的兩種表示法。</span><span class="sxs-lookup"><span data-stu-id="6c498-991">It is possible to enable both trace flags to obtain two representations of the same deadlock event.</span></span>  
  
 <span data-ttu-id="6c498-992">除了定義追蹤旗標 1204 和 1222 的屬性之外，下表還顯示其相似性和差異。</span><span class="sxs-lookup"><span data-stu-id="6c498-992">In addition to defining the properties of trace flag 1204 and 1222, the following table also shows the similarities and differences.</span></span>  
  
|<span data-ttu-id="6c498-993">屬性</span><span class="sxs-lookup"><span data-stu-id="6c498-993">Property</span></span>|<span data-ttu-id="6c498-994">追蹤旗標 1204 和追蹤旗標 1222</span><span class="sxs-lookup"><span data-stu-id="6c498-994">Trace Flag 1204 and Trace Flag 1222</span></span>|<span data-ttu-id="6c498-995">僅追蹤旗標 1204</span><span class="sxs-lookup"><span data-stu-id="6c498-995">Trace Flag 1204 only</span></span>|<span data-ttu-id="6c498-996">僅追蹤旗標 1222</span><span class="sxs-lookup"><span data-stu-id="6c498-996">Trace Flag 1222 only</span></span>|  
|--------------|-----------------------------------------|--------------------------|--------------------------|  
|<span data-ttu-id="6c498-997">輸出格式</span><span class="sxs-lookup"><span data-stu-id="6c498-997">Output format</span></span>|<span data-ttu-id="6c498-998">輸出是擷取到 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 錯誤記錄檔中。</span><span class="sxs-lookup"><span data-stu-id="6c498-998">Output is captured in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span>|<span data-ttu-id="6c498-999">聚焦於死結所涉及的節點。</span><span class="sxs-lookup"><span data-stu-id="6c498-999">Focused on the nodes involved in the deadlock.</span></span> <span data-ttu-id="6c498-1000">每一個節點有一個專用區段，最後區段描述死結犧牲者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1000">Each node has a dedicated section, and the final section describes the deadlock victim.</span></span>|<span data-ttu-id="6c498-1001">以類似 XML 格式傳回不符合 XML 結構描述定義 (XSD) 結構描述的資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1001">Returns information in an XML-like format that does not conform to an XML Schema Definition (XSD) schema.</span></span> <span data-ttu-id="6c498-1002">此格式有三大區段。</span><span class="sxs-lookup"><span data-stu-id="6c498-1002">The format has three major sections.</span></span> <span data-ttu-id="6c498-1003">第一個區段宣告死結犧牲者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1003">The first section declares the deadlock victim.</span></span> <span data-ttu-id="6c498-1004">第二個區段描述死結所涉及的每一個處理序。</span><span class="sxs-lookup"><span data-stu-id="6c498-1004">The second section describes each process involved in the deadlock.</span></span> <span data-ttu-id="6c498-1005">第三個區段描述與追蹤旗標 1204 中的節點同義的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-1005">The third section describes the resources that are synonymous with nodes in trace flag 1204.</span></span>|  
|<span data-ttu-id="6c498-1006">識別屬性</span><span class="sxs-lookup"><span data-stu-id="6c498-1006">Identifying attributes</span></span>|<span data-ttu-id="6c498-1007">**SPID： \<x> ECID： \<x> 。**</span><span class="sxs-lookup"><span data-stu-id="6c498-1007">**SPID:\<x> ECID:\<x>.**</span></span> <span data-ttu-id="6c498-1008">識別平行處理序中的系統處理序識別碼執行緒。</span><span class="sxs-lookup"><span data-stu-id="6c498-1008">Identifies the system process ID thread in cases of parallel processes.</span></span> <span data-ttu-id="6c498-1009">專案 `SPID:<x> ECID:0` （其中 \<x> 由 SPID 值取代）代表主執行緒。</span><span class="sxs-lookup"><span data-stu-id="6c498-1009">The entry `SPID:<x> ECID:0`, where \<x> is replaced by the SPID value, represents the main thread.</span></span> <span data-ttu-id="6c498-1010">專案 `SPID:<x> ECID:<y>` （其中 \<x> 由 SPID 值取代且 \<y> 大於0）代表相同 SPID 的子執行緒。</span><span class="sxs-lookup"><span data-stu-id="6c498-1010">The entry `SPID:<x> ECID:<y>`, where \<x> is replaced by the SPID value and \<y> is greater than 0, represents the sub-threads for the same SPID.</span></span><br /><br /> <span data-ttu-id="6c498-1011">**BatchID** (追蹤旗標 1222 的**sbid** )。</span><span class="sxs-lookup"><span data-stu-id="6c498-1011">**BatchID** (**sbid** for trace flag 1222).</span></span> <span data-ttu-id="6c498-1012">識別程式碼執行從中要求或保留鎖定的批次。</span><span class="sxs-lookup"><span data-stu-id="6c498-1012">Identifies the batch from which code execution is requesting or holding a lock.</span></span> <span data-ttu-id="6c498-1013">停用 Multiple Active Result Sets (MARS) 時，BatchID 值為 0。</span><span class="sxs-lookup"><span data-stu-id="6c498-1013">When Multiple Active Result Sets (MARS) is disabled, the BatchID value is 0.</span></span> <span data-ttu-id="6c498-1014">啟用 MARS 時，作用中批次的值為 1 到 *n*。</span><span class="sxs-lookup"><span data-stu-id="6c498-1014">When MARS is enabled, the value for active batches is 1 to *n*.</span></span> <span data-ttu-id="6c498-1015">如果工作階段中沒有作用中批次，BatchID 為 0。</span><span class="sxs-lookup"><span data-stu-id="6c498-1015">If there are no active batches in the session, BatchID is 0.</span></span><br /><br /> <span data-ttu-id="6c498-1016">**模式**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1016">**Mode**.</span></span> <span data-ttu-id="6c498-1017">指定執行緒所要求、授與或等待之特定資源的鎖定類型。</span><span class="sxs-lookup"><span data-stu-id="6c498-1017">Specifies the type of lock for a particular resource that is requested, granted, or waited on by a thread.</span></span> <span data-ttu-id="6c498-1018">模式可為 IS (意圖共用)、S (共用)、U (更新)、IX (意圖獨佔)、SIX (共用意圖獨佔) 和 X (獨佔)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1018">Mode can be IS (Intent Shared), S (Shared), U (Update), IX (Intent Exclusive), SIX (Shared with Intent Exclusive), and X (Exclusive).</span></span><br /><br /> <span data-ttu-id="6c498-1019">**Line #** (追蹤旗標 1222 的**line** )。</span><span class="sxs-lookup"><span data-stu-id="6c498-1019">**Line #** (**line** for trace flag 1222).</span></span> <span data-ttu-id="6c498-1020">列出發生死結時正在執行之目前陳述式批次中的行號。</span><span class="sxs-lookup"><span data-stu-id="6c498-1020">Lists the line number in the current batch of statements that was being executed when the deadlock occurred.</span></span><br /><br /> <span data-ttu-id="6c498-1021">**Input Buf** (追蹤旗標 1222 的**inputbuf** )。</span><span class="sxs-lookup"><span data-stu-id="6c498-1021">**Input Buf** (**inputbuf** for trace flag 1222).</span></span> <span data-ttu-id="6c498-1022">列出目前批次中的所有陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1022">Lists all the statements in the current batch.</span></span>|<span data-ttu-id="6c498-1023">**節點**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1023">**Node**.</span></span> <span data-ttu-id="6c498-1024">代表死結鏈結中的項目號碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1024">Represents the entry number in the deadlock chain.</span></span><br /><br /> <span data-ttu-id="6c498-1025">**清單**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1025">**Lists**.</span></span> <span data-ttu-id="6c498-1026">鎖定擁有者可以是這些清單的一部分：</span><span class="sxs-lookup"><span data-stu-id="6c498-1026">The lock owner can be part of these lists:</span></span><br /><br /> <span data-ttu-id="6c498-1027">**授與清單**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1027">**Grant List**.</span></span> <span data-ttu-id="6c498-1028">列舉資源的目前擁有者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1028">Enumerates the current owners of the resource.</span></span><br /><br /> <span data-ttu-id="6c498-1029">**轉換清單**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1029">**Convert List**.</span></span> <span data-ttu-id="6c498-1030">列舉嘗試將其鎖定轉換為更高層的目前擁有者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1030">Enumerates the current owners that are trying to convert their locks to a higher level.</span></span><br /><br /> <span data-ttu-id="6c498-1031">**等待清單**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1031">**Wait List**.</span></span> <span data-ttu-id="6c498-1032">列舉資源的目前最新鎖定要求。</span><span class="sxs-lookup"><span data-stu-id="6c498-1032">Enumerates current new lock requests for the resource.</span></span><br /><br /> <span data-ttu-id="6c498-1033">**陳述式類型**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1033">**Statement Type**.</span></span> <span data-ttu-id="6c498-1034">描述執行緒有權限的 DML 陳述式的類型 (SELECT、INSERT、UPDATE 或 DELETE)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1034">Describes the type of DML statement (SELECT, INSERT, UPDATE, or DELETE) on which the threads have permissions.</span></span><br /><br /> <span data-ttu-id="6c498-1035">**犧牲者資源擁有者**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1035">**Victim Resource Owner**.</span></span> <span data-ttu-id="6c498-1036">指定 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 選擇作為犧牲者來中斷死結循環的參與執行緒。</span><span class="sxs-lookup"><span data-stu-id="6c498-1036">Specifies the participating thread that [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] chooses as the victim to break the deadlock cycle.</span></span> <span data-ttu-id="6c498-1037">選擇的執行緒和所有現存的子執行緒會終止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1037">The chosen thread and all existing sub-threads are terminated.</span></span><br /><br /> <span data-ttu-id="6c498-1038">**下一分支**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1038">**Next Branch**.</span></span> <span data-ttu-id="6c498-1039">代表相同 SPID 中兩個以上涉及死結循環的子執行緒。</span><span class="sxs-lookup"><span data-stu-id="6c498-1039">Represents the two or more sub-threads from the same SPID that are involved in the deadlock cycle.</span></span>|<span data-ttu-id="6c498-1040">**deadlock victim**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1040">**deadlock victim**.</span></span> <span data-ttu-id="6c498-1041">代表被選為死結犧牲者之工作的實體記憶位址 (請參閱 [sys.dm_os_tasks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql))。</span><span class="sxs-lookup"><span data-stu-id="6c498-1041">Represents the physical memory address of the task (see [sys.dm_os_tasks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql)) that was selected as a deadlock victim.</span></span> <span data-ttu-id="6c498-1042">在未解決的死結案例中，它可能會是 0 (零)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1042">It may be 0 (zero) in the case of an unresolved deadlock.</span></span> <span data-ttu-id="6c498-1043">回復中的工作不可選為死結犧牲者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1043">A task that is rolling back cannot be chosen as a deadlock victim.</span></span><br /><br /> <span data-ttu-id="6c498-1044">**executionstack**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1044">**executionstack**.</span></span> <span data-ttu-id="6c498-1045">代表發生死結時正在執行的 [!INCLUDE[tsql](../includes/tsql-md.md)] 程式碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1045">Represents [!INCLUDE[tsql](../includes/tsql-md.md)] code that is being executed at the time the deadlock occurs.</span></span><br /><br /> <span data-ttu-id="6c498-1046">**priority**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1046">**priority**.</span></span> <span data-ttu-id="6c498-1047">代表死結優先權。</span><span class="sxs-lookup"><span data-stu-id="6c498-1047">Represents deadlock priority.</span></span> <span data-ttu-id="6c498-1048">在特定案例中， [!INCLUDE[ssDE](../includes/ssde-md.md)] 可能會選擇在短時間內變更死結優先權，以達到更佳的並行效果。</span><span class="sxs-lookup"><span data-stu-id="6c498-1048">In certain cases, the [!INCLUDE[ssDE](../includes/ssde-md.md)] may opt to alter the deadlock priority for a short duration to achieve better concurrency.</span></span><br /><br /> <span data-ttu-id="6c498-1049">**logused**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1049">**logused**.</span></span> <span data-ttu-id="6c498-1050">工作所使用的記錄檔空間。</span><span class="sxs-lookup"><span data-stu-id="6c498-1050">Log space used by the task.</span></span><br /><br /> <span data-ttu-id="6c498-1051">**owner id**。具有要求控制權之交易的識別碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1051">**owner id**. The ID of the transaction that has control of the request.</span></span><br /><br /> <span data-ttu-id="6c498-1052">**status**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1052">**status**.</span></span> <span data-ttu-id="6c498-1053">工作的狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-1053">State of the task.</span></span> <span data-ttu-id="6c498-1054">它是下列其中一值：</span><span class="sxs-lookup"><span data-stu-id="6c498-1054">It is one of the following values:</span></span><br /><br /> <span data-ttu-id="6c498-1055">>> **pending**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1055">>> **pending**.</span></span> <span data-ttu-id="6c498-1056">等待工作者執行緒。</span><span class="sxs-lookup"><span data-stu-id="6c498-1056">Waiting for a worker thread.</span></span><br /><br /> <span data-ttu-id="6c498-1057">>> **runnable**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1057">>> **runnable**.</span></span> <span data-ttu-id="6c498-1058">可開始執行但等待配量。</span><span class="sxs-lookup"><span data-stu-id="6c498-1058">Ready to run but waiting for a quantum.</span></span><br /><br /> <span data-ttu-id="6c498-1059">>> **running**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1059">>> **running**.</span></span> <span data-ttu-id="6c498-1060">目前在排程器上執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1060">Currently running on the scheduler.</span></span><br /><br /> <span data-ttu-id="6c498-1061">>> **suspended**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1061">>> **suspended**.</span></span> <span data-ttu-id="6c498-1062">執行已暫停。</span><span class="sxs-lookup"><span data-stu-id="6c498-1062">Execution is suspended.</span></span><br /><br /> <span data-ttu-id="6c498-1063">>> **done**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1063">>> **done**.</span></span> <span data-ttu-id="6c498-1064">工作已完成。</span><span class="sxs-lookup"><span data-stu-id="6c498-1064">Task has completed.</span></span><br /><br /> <span data-ttu-id="6c498-1065">>> **spinloop**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1065">>> **spinloop**.</span></span> <span data-ttu-id="6c498-1066">等待單一執行緒存取鎖變成可用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1066">Waiting for a spinlock to become free.</span></span><br /><br /> <span data-ttu-id="6c498-1067">**waitresource**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1067">**waitresource**.</span></span> <span data-ttu-id="6c498-1068">工作所需的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-1068">The resource needed by the task.</span></span><br /><br /> <span data-ttu-id="6c498-1069">**waittime**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1069">**waittime**.</span></span> <span data-ttu-id="6c498-1070">等待資源的時間 (以毫秒為單位)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1070">Time in milliseconds waiting for the resource.</span></span><br /><br /> <span data-ttu-id="6c498-1071">**schedulerid**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1071">**schedulerid**.</span></span> <span data-ttu-id="6c498-1072">與這個工作相關聯的排程器。</span><span class="sxs-lookup"><span data-stu-id="6c498-1072">Scheduler associated with this task.</span></span> <span data-ttu-id="6c498-1073">請參閱 [sys.dm_os_schedulers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1073">See [sys.dm_os_schedulers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql).</span></span><br /><br /> <span data-ttu-id="6c498-1074">**hostname**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1074">**hostname**.</span></span> <span data-ttu-id="6c498-1075">工作站的名稱。</span><span class="sxs-lookup"><span data-stu-id="6c498-1075">The name of the workstation.</span></span><br /><br /> <span data-ttu-id="6c498-1076">**isolationlevel**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1076">**isolationlevel**.</span></span> <span data-ttu-id="6c498-1077">目前交易隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1077">The current transaction isolation level.</span></span><br /><br /> <span data-ttu-id="6c498-1078">**Xactid**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1078">**Xactid**.</span></span> <span data-ttu-id="6c498-1079">具有要求控制權之交易的識別碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1079">The ID of the transaction that has control of the request.</span></span><br /><br /> <span data-ttu-id="6c498-1080">**currentdb**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1080">**currentdb**.</span></span> <span data-ttu-id="6c498-1081">資料庫的識別碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1081">The ID of the database.</span></span><br /><br /> <span data-ttu-id="6c498-1082">**lastbatchstarted**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1082">**lastbatchstarted**.</span></span> <span data-ttu-id="6c498-1083">用戶端處理序上次啟動批次執行的時間。</span><span class="sxs-lookup"><span data-stu-id="6c498-1083">The last time a client process started batch execution.</span></span><br /><br /> <span data-ttu-id="6c498-1084">**lastbatchcompleted**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1084">**lastbatchcompleted**.</span></span> <span data-ttu-id="6c498-1085">用戶端處理序上次完成批次執行的時間。</span><span class="sxs-lookup"><span data-stu-id="6c498-1085">The last time a client process completed batch execution.</span></span><br /><br /> <span data-ttu-id="6c498-1086">**clientoption1 和 clientoption2**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1086">**clientoption1 and clientoption2**.</span></span> <span data-ttu-id="6c498-1087">此用戶端連接上的設定選項。</span><span class="sxs-lookup"><span data-stu-id="6c498-1087">Set options on this client connection.</span></span> <span data-ttu-id="6c498-1088">這是位元遮罩，其中包含通常由 SET 陳述式 (例如 SET NOCOUNT 和 SET XACTABORT) 所控制之選項的資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1088">This is a bitmask that includes information about options usually controlled by SET statements such as SET NOCOUNT and SET XACTABORT.</span></span><br /><br /> <span data-ttu-id="6c498-1089">**associatedObjectId**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1089">**associatedObjectId**.</span></span> <span data-ttu-id="6c498-1090">代表 HoBT (堆積或 B 型樹狀目錄) 識別碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1090">Represents the HoBT (heap or b-tree) ID.</span></span>|  
|<span data-ttu-id="6c498-1091">資源屬性</span><span class="sxs-lookup"><span data-stu-id="6c498-1091">Resource attributes</span></span>|<span data-ttu-id="6c498-1092">**RID**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1092">**RID**.</span></span> <span data-ttu-id="6c498-1093">識別在資料表內保留或要求鎖定的單一資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-1093">Identifies the single row within a table on which a lock is held or requested.</span></span> <span data-ttu-id="6c498-1094">RID 是以 RID: *db_id:file_id:page_no:row_no*表示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1094">RID is represented as RID: *db_id:file_id:page_no:row_no*.</span></span> <span data-ttu-id="6c498-1095">例如： `RID: 6:1:20789:0` 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1095">For example, `RID: 6:1:20789:0`.</span></span><br /><br /> <span data-ttu-id="6c498-1096">**OBJECT**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1096">**OBJECT**.</span></span> <span data-ttu-id="6c498-1097">識別保留或要求鎖定的資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1097">Identifies the table on which a lock is held or requested.</span></span> <span data-ttu-id="6c498-1098">OBJECT 是以 OBJECT: *db_id:object_id*表示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1098">OBJECT is represented as OBJECT: *db_id:object_id*.</span></span> <span data-ttu-id="6c498-1099">例如： `TAB: 6:2009058193` 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1099">For example, `TAB: 6:2009058193`.</span></span><br /><br /> <span data-ttu-id="6c498-1100">**KEY**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1100">**KEY**.</span></span> <span data-ttu-id="6c498-1101">識別在索引內保留或要求鎖定的索引鍵範圍。</span><span class="sxs-lookup"><span data-stu-id="6c498-1101">Identifies the key range within an index on which a lock is held or requested.</span></span> <span data-ttu-id="6c498-1102">KEY 是以 KEY: *db_id:hobt_id* (*index key hash value*) 表示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1102">KEY is represented as KEY: *db_id:hobt_id* (*index key hash value*).</span></span> <span data-ttu-id="6c498-1103">例如： `KEY: 6:72057594057457664 (350007a4d329)` 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1103">For example, `KEY: 6:72057594057457664 (350007a4d329)`.</span></span><br /><br /> <span data-ttu-id="6c498-1104">**PAG**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1104">**PAG**.</span></span> <span data-ttu-id="6c498-1105">識別保留或要求鎖定的頁面資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-1105">Identifies the page resource on which a lock is held or requested.</span></span> <span data-ttu-id="6c498-1106">PAG 是以 PAG: *db_id:file_id:page_no*表示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1106">PAG is represented as PAG: *db_id:file_id:page_no*.</span></span> <span data-ttu-id="6c498-1107">例如： `PAG: 6:1:20789` 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1107">For example, `PAG: 6:1:20789`.</span></span><br /><br /> <span data-ttu-id="6c498-1108">**EXT**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1108">**EXT**.</span></span> <span data-ttu-id="6c498-1109">識別範圍結構。</span><span class="sxs-lookup"><span data-stu-id="6c498-1109">Identifies the extent structure.</span></span> <span data-ttu-id="6c498-1110">EXT 是以 EXT: *db_id:file_id:extent_no*表示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1110">EXT is represented as EXT: *db_id:file_id:extent_no*.</span></span> <span data-ttu-id="6c498-1111">例如： `EXT: 6:1:9` 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1111">For example, `EXT: 6:1:9`.</span></span><br /><br /> <span data-ttu-id="6c498-1112">**DB**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1112">**DB**.</span></span> <span data-ttu-id="6c498-1113">識別資料庫鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1113">Identifies the database lock.</span></span> <span data-ttu-id="6c498-1114">**DB 會以下列其中一種方式表示：**</span><span class="sxs-lookup"><span data-stu-id="6c498-1114">**DB is represented in one of the following ways:**</span></span><br /><br /> <span data-ttu-id="6c498-1115">DB: *db_id*</span><span class="sxs-lookup"><span data-stu-id="6c498-1115">DB: *db_id*</span></span><br /><br /> <span data-ttu-id="6c498-1116">DB: *db_id*[BULK-OP-DB]，識別備份資料庫使用的資料庫鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1116">DB: *db_id*[BULK-OP-DB], which identifies the database lock taken by the backup database.</span></span><br /><br /> <span data-ttu-id="6c498-1117">DB: *db_id*[BULK-OP-LOG]，識別該特定資料庫的備份記錄檔所使用的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1117">DB: *db_id*[BULK-OP-LOG], which identifies the lock taken by the backup log for that particular database.</span></span><br /><br /> <span data-ttu-id="6c498-1118">**APP**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1118">**APP**.</span></span> <span data-ttu-id="6c498-1119">識別應用程式資源使用的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1119">Identifies the lock taken by an application resource.</span></span> <span data-ttu-id="6c498-1120">APP 是以 APP: *lock_resource*表示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1120">APP is represented as APP: *lock_resource*.</span></span> <span data-ttu-id="6c498-1121">例如： `APP: Formf370f478` 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1121">For example, `APP: Formf370f478`.</span></span><br /><br /> <span data-ttu-id="6c498-1122">**METADATA**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1122">**METADATA**.</span></span> <span data-ttu-id="6c498-1123">代表死結所涉及的中繼資料資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-1123">Represents metadata resources involved in a deadlock.</span></span> <span data-ttu-id="6c498-1124">因為 METADATA 有許多子資源，所以傳回的值視含有死結的子資源而定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1124">Because METADATA has many subresources, the value returned depends upon the subresource that has deadlocked.</span></span> <span data-ttu-id="6c498-1125">例如，中繼資料。USER_TYPE 傳回 `user_type_id =` \<*integer_value*> 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1125">For example, METADATA.USER_TYPE returns `user_type_id =` \<*integer_value*>.</span></span> <span data-ttu-id="6c498-1126">如需有關 METADATA 資源和子資源的詳細資訊，請參閱 [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1126">For more information about METADATA resources and subresources, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span><br /><br /> <span data-ttu-id="6c498-1127">**HOBT**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1127">**HOBT**.</span></span> <span data-ttu-id="6c498-1128">代表死結所涉及的堆積或 B 型樹狀目錄。</span><span class="sxs-lookup"><span data-stu-id="6c498-1128">Represents a heap or b-tree involved in a deadlock.</span></span>|<span data-ttu-id="6c498-1129">None 與此追蹤旗標互斥。</span><span class="sxs-lookup"><span data-stu-id="6c498-1129">None exclusive to this trace flag.</span></span>|<span data-ttu-id="6c498-1130">None 與此追蹤旗標互斥。</span><span class="sxs-lookup"><span data-stu-id="6c498-1130">None exclusive to this trace flag.</span></span>|  
  
###### <a name="trace-flag-1204-example"></a><span data-ttu-id="6c498-1131">追蹤旗標 1204 範例</span><span class="sxs-lookup"><span data-stu-id="6c498-1131">Trace Flag 1204 Example</span></span>  

 <span data-ttu-id="6c498-1132">下列範例顯示追蹤旗標 1204 開啟時的輸出。</span><span class="sxs-lookup"><span data-stu-id="6c498-1132">The following example shows the output when trace flag 1204 is turned on.</span></span> <span data-ttu-id="6c498-1133">在此案例中，節點 1 中的資料表是一個不含索引的堆積，節點 2 中的資料表是一個含非叢集索引的堆積。</span><span class="sxs-lookup"><span data-stu-id="6c498-1133">In this case, the table in Node 1 is a heap with no indexes, and the table in Node 2 is a heap with a nonclustered index.</span></span> <span data-ttu-id="6c498-1134">當發生死結時，正在更新節點 2 中的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="6c498-1134">The index key in Node 2 is being updated when the deadlock occurs.</span></span>  
  
```  
Deadlock encountered .... Printing deadlock information  
Wait-for graph  
  
Node:1  
  
RID: 6:1:20789:0               CleanCnt:3 Mode:X Flags: 0x2  
 Grant List 0:  
   Owner:0x0315D6A0 Mode: X          
     Flg:0x0 Ref:0 Life:02000000 SPID:55 ECID:0 XactLockInfo: 0x04D9E27C  
   SPID: 55 ECID: 0 Statement Type: UPDATE Line #: 6  
   Input Buf: Language Event:   
BEGIN TRANSACTION  
   EXEC usp_p2  
 Requested By:   
   ResType:LockOwner Stype:'OR'Xdes:0x03A3DAD0   
     Mode: U SPID:54 BatchID:0 ECID:0 TaskProxy:(0x04976374) Value:0x315d200 Cost:(0/868)  
  
Node:2  
  
KEY: 6:72057594057457664 (350007a4d329) CleanCnt:2 Mode:X Flags: 0x0  
 Grant List 0:  
   Owner:0x0315D140 Mode: X          
     Flg:0x0 Ref:0 Life:02000000 SPID:54 ECID:0 XactLockInfo: 0x03A3DAF4  
   SPID: 54 ECID: 0 Statement Type: UPDATE Line #: 6  
   Input Buf: Language Event:   
     BEGIN TRANSACTION  
       EXEC usp_p1  
 Requested By:   
   ResType:LockOwner Stype:'OR'Xdes:0x04D9E258   
     Mode: U SPID:55 BatchID:0 ECID:0 TaskProxy:(0x0475E374) Value:0x315d4a0 Cost:(0/380)  
  
Victim Resource Owner:  
 ResType:LockOwner Stype:'OR'Xdes:0x04D9E258   
     Mode: U SPID:55 BatchID:0 ECID:0 TaskProxy:(0x0475E374) Value:0x315d4a0 Cost:(0/380)  
```  
  
###### <a name="trace-flag-1222-example"></a><span data-ttu-id="6c498-1135">追蹤旗標 1222 範例</span><span class="sxs-lookup"><span data-stu-id="6c498-1135">Trace Flag 1222 Example</span></span>  

 <span data-ttu-id="6c498-1136">下列範例顯示追蹤旗標 1222 開啟時的輸出。</span><span class="sxs-lookup"><span data-stu-id="6c498-1136">The following example shows the output when trace flag 1222 is turned on.</span></span> <span data-ttu-id="6c498-1137">在此案例中，有一個資料表是不含索引的堆積，另一個資料表是含非叢集索引的堆積。</span><span class="sxs-lookup"><span data-stu-id="6c498-1137">In this case, one table is a heap with no indexes, and the other table is a heap with a nonclustered index.</span></span> <span data-ttu-id="6c498-1138">在第二份資料表中，當發生死結時，正在更新索引鍵。</span><span class="sxs-lookup"><span data-stu-id="6c498-1138">In the second table, the index key is being updated when the deadlock occurs.</span></span>  
  
```  
deadlock-list  
 deadlock victim=process689978  
  process-list  
   process id=process6891f8 taskpriority=0 logused=868   
   waitresource=RID: 6:1:20789:0 waittime=1359 ownerId=310444   
   transactionname=user_transaction   
   lasttranstarted=2005-09-05T11:22:42.733 XDES=0x3a3dad0   
   lockMode=U schedulerid=1 kpid=1952 status=suspended spid=54   
   sbid=0 ecid=0 priority=0 transcount=2   
   lastbatchstarted=2005-09-05T11:22:42.733   
   lastbatchcompleted=2005-09-05T11:22:42.733   
   clientapp=Microsoft SQL Server Management Studio - Query   
   hostname=TEST_SERVER hostpid=2216 loginname=DOMAIN\user   
   isolationlevel=read committed (2) xactid=310444 currentdb=6   
   lockTimeout=4294967295 clientoption1=671090784 clientoption2=390200  
    executionStack  
     frame procname=AdventureWorks2012.dbo.usp_p1 line=6 stmtstart=202   
     sqlhandle=0x0300060013e6446b027cbb00c69600000100000000000000  
     UPDATE T2 SET COL1 = 3 WHERE COL1 = 1;       
     frame procname=adhoc line=3 stmtstart=44   
     sqlhandle=0x01000600856aa70f503b8104000000000000000000000000  
     EXEC usp_p1       
    inputbuf  
      BEGIN TRANSACTION  
       EXEC usp_p1  
   process id=process689978 taskpriority=0 logused=380   
   waitresource=KEY: 6:72057594057457664 (350007a4d329)     
   waittime=5015 ownerId=310462 transactionname=user_transaction   
   lasttranstarted=2005-09-05T11:22:44.077 XDES=0x4d9e258 lockMode=U   
   schedulerid=1 kpid=3024 status=suspended spid=55 sbid=0 ecid=0   
   priority=0 transcount=2 lastbatchstarted=2005-09-05T11:22:44.077   
   lastbatchcompleted=2005-09-05T11:22:44.077   
   clientapp=Microsoft SQL Server Management Studio - Query   
   hostname=TEST_SERVER hostpid=2216 loginname=DOMAIN\user   
   isolationlevel=read committed (2) xactid=310462 currentdb=6   
   lockTimeout=4294967295 clientoption1=671090784 clientoption2=390200  
    executionStack  
     frame procname=AdventureWorks2012.dbo.usp_p2 line=6 stmtstart=200   
     sqlhandle=0x030006004c0a396c027cbb00c69600000100000000000000  
     UPDATE T1 SET COL1 = 4 WHERE COL1 = 1;       
     frame procname=adhoc line=3 stmtstart=44   
     sqlhandle=0x01000600d688e709b85f8904000000000000000000000000  
     EXEC usp_p2       
    inputbuf  
      BEGIN TRANSACTION  
        EXEC usp_p2      
  resource-list  
   ridlock fileid=1 pageid=20789 dbid=6 objectname=AdventureWorks2012.dbo.T2   
   id=lock3136940 mode=X associatedObjectId=72057594057392128  
    owner-list  
     owner id=process689978 mode=X  
    waiter-list  
     waiter id=process6891f8 mode=U requestType=wait  
   keylock hobtid=72057594057457664 dbid=6 objectname=AdventureWorks2012.dbo.T1   
   indexname=nci_T1_COL1 id=lock3136fc0 mode=X   
   associatedObjectId=72057594057457664  
    owner-list  
     owner id=process6891f8 mode=X  
    waiter-list  
     waiter id=process689978 mode=U requestType=wait  
```  
  
###### <a name="profiler-deadlock-graph-event"></a><span data-ttu-id="6c498-1139">Profiler 死結圖形事件</span><span class="sxs-lookup"><span data-stu-id="6c498-1139">Profiler Deadlock Graph Event</span></span>  

 <span data-ttu-id="6c498-1140">這是 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] 中的一個事件，它提供與死結相關之工作和資源的圖形描述。</span><span class="sxs-lookup"><span data-stu-id="6c498-1140">This is an event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] that presents a graphical depiction of the tasks and resources involved in a deadlock.</span></span> <span data-ttu-id="6c498-1141">下列範例顯示死結圖形事件開啟時 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] 的輸出。</span><span class="sxs-lookup"><span data-stu-id="6c498-1141">The following example shows the output from [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] when the deadlock graph event is turned on.</span></span>  
  
 <span data-ttu-id="6c498-1142">![顯示使用者處理序死結的邏輯流程圖。](media/udb9-profilerdeadlockgraphc.gif "顯示使用者處理序死結的邏輯流程圖。")</span><span class="sxs-lookup"><span data-stu-id="6c498-1142">![Logic flow diagram showing user process deadlock.](media/udb9-profilerdeadlockgraphc.gif "Logic flow diagram showing user process deadlock.")</span></span>  
  
 <span data-ttu-id="6c498-1143">如需有關執行 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] 鎖死圖形的詳細資訊，請參閱[&#40;SQL Server Profiler&#41;儲存鎖死圖形](../relational-databases/performance/save-deadlock-graphs-sql-server-profiler.md)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1143">For more information about running the [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] deadlock graph, see [Save Deadlock Graphs &#40;SQL Server Profiler&#41;](../relational-databases/performance/save-deadlock-graphs-sql-server-profiler.md).</span></span>  
  
#### <a name="handling-deadlocks"></a><span data-ttu-id="6c498-1144">處理死結</span><span class="sxs-lookup"><span data-stu-id="6c498-1144">Handling Deadlocks</span></span>  

 <span data-ttu-id="6c498-1145">當 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]執行個體選擇某個交易作為死結犧牲者時，會終止目前的批次、復原交易，然後將錯誤訊息 1205 傳回給應用程式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1145">When an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] chooses a transaction as a deadlock victim, it terminates the current batch, rolls back the transaction, and returns error message 1205 to the application.</span></span>  
  
 `Your transaction (process ID #52) was deadlocked on {lock | communication buffer | thread} resources with another process and has been chosen as the deadlock victim. Rerun your transaction.`  
  
 <span data-ttu-id="6c498-1146">由於任何提交 [!INCLUDE[tsql](../includes/tsql-md.md)] 查詢的應用程式都可能被選為死結的犧牲者，應用程式應該要有錯誤處理常式來攔截錯誤訊息 1205。</span><span class="sxs-lookup"><span data-stu-id="6c498-1146">Because any application submitting [!INCLUDE[tsql](../includes/tsql-md.md)] queries can be chosen as the deadlock victim, applications should have an error handler that can trap error message 1205.</span></span> <span data-ttu-id="6c498-1147">如果應用程式不捕捉此錯誤，就不知道其交易已經復原而繼續執行，此時就會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="6c498-1147">If an application does not trap the error, the application can proceed unaware that its transaction has been rolled back and errors can occur.</span></span>  
  
 <span data-ttu-id="6c498-1148">實作捕捉錯誤訊息 1205 的錯誤處理常式，讓應用程式得以處理死結的狀況並採取補救措施 (例如，將陷入死結的查詢自動重新送出)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1148">Implementing an error handler that traps error message 1205 allows an application to handle the deadlock situation and take remedial action (for example, automatically resubmitting the query that was involved in the deadlock).</span></span> <span data-ttu-id="6c498-1149">藉由自動重新送出查詢，使用者就不需要知道死結曾經發生。</span><span class="sxs-lookup"><span data-stu-id="6c498-1149">By resubmitting the query automatically, the user does not need to know that a deadlock occurred.</span></span>  
  
 <span data-ttu-id="6c498-1150">應用程式應該在重新送出查詢之前稍做停頓。</span><span class="sxs-lookup"><span data-stu-id="6c498-1150">The application should pause briefly before resubmitting its query.</span></span> <span data-ttu-id="6c498-1151">這可讓死結中的另一筆交易有機會完成動作，並釋放它讓死結循環形成的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1151">This gives the other transaction involved in the deadlock a chance to complete and release its locks that formed part of the deadlock cycle.</span></span> <span data-ttu-id="6c498-1152">這樣一來，當重新送出的查詢要求鎖定時，就比較不會再度發生死結的情形。</span><span class="sxs-lookup"><span data-stu-id="6c498-1152">This minimizes the likelihood of the deadlock reoccurring when the resubmitted query requests its locks.</span></span>  
  
#### <a name="minimizing-deadlocks"></a><span data-ttu-id="6c498-1153">將死結數量降至最低</span><span class="sxs-lookup"><span data-stu-id="6c498-1153">Minimizing Deadlocks</span></span>  

 <span data-ttu-id="6c498-1154">雖然死結無法完全避免，但是遵守某些程式碼撰寫的慣例可以將死結產生的機會降到最低。</span><span class="sxs-lookup"><span data-stu-id="6c498-1154">Although deadlocks cannot be completely avoided, following certain coding conventions can minimize the chance of generating a deadlock.</span></span> <span data-ttu-id="6c498-1155">將死結降至最低可以提高交易的產能並降低系統額外負荷，因為較少的交易需要：</span><span class="sxs-lookup"><span data-stu-id="6c498-1155">Minimizing deadlocks can increase transaction throughput and reduce system overhead because fewer transactions are:</span></span>  
  
-   <span data-ttu-id="6c498-1156">回復，將交易所進行的工作全部恢復。</span><span class="sxs-lookup"><span data-stu-id="6c498-1156">Rolled back, undoing all the work performed by the transaction.</span></span>  
  
-   <span data-ttu-id="6c498-1157">由應用程式重新送出，因為發生死結時已將交易回復。</span><span class="sxs-lookup"><span data-stu-id="6c498-1157">Resubmitted by applications because they were rolled back when deadlocked.</span></span>  
  
 <span data-ttu-id="6c498-1158">若要協助將死結降至最低：</span><span class="sxs-lookup"><span data-stu-id="6c498-1158">To help minimize deadlocks:</span></span>  
  
-   <span data-ttu-id="6c498-1159">以相同的順序來存取物件。</span><span class="sxs-lookup"><span data-stu-id="6c498-1159">Access objects in the same order.</span></span>  
  
-   <span data-ttu-id="6c498-1160">在交易中避免使用者互動。</span><span class="sxs-lookup"><span data-stu-id="6c498-1160">Avoid user interaction in transactions.</span></span>  
  
-   <span data-ttu-id="6c498-1161">將交易維持在單一批次中且愈短愈好。</span><span class="sxs-lookup"><span data-stu-id="6c498-1161">Keep transactions short and in one batch.</span></span>  
  
-   <span data-ttu-id="6c498-1162">使用較低的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1162">Use a lower isolation level.</span></span>  
  
-   <span data-ttu-id="6c498-1163">使用資料列版本設定基礎的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1163">Use a row versioning-based isolation level.</span></span>  
  
    -   <span data-ttu-id="6c498-1164">將 READ_COMMITTED_SNAPSHOT 資料庫選項設為 ON，讓讀取認可交易使用資料列版本設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1164">Set READ_COMMITTED_SNAPSHOT database option ON to enable read-committed transactions to use row versioning.</span></span>  
  
    -   <span data-ttu-id="6c498-1165">使用快照隔離。</span><span class="sxs-lookup"><span data-stu-id="6c498-1165">Use snapshot isolation.</span></span>  
  
-   <span data-ttu-id="6c498-1166">使用繫結連接。</span><span class="sxs-lookup"><span data-stu-id="6c498-1166">Use bound connections.</span></span>  
  
##### <a name="access-objects-in-the-same-order"></a><span data-ttu-id="6c498-1167">以相同的順序來存取物件</span><span class="sxs-lookup"><span data-stu-id="6c498-1167">Access Objects in the Same Order</span></span>  

 <span data-ttu-id="6c498-1168">如果所有同時發生的交易都以相同的順序來存取物件，就比較不會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-1168">If all concurrent transactions access objects in the same order, deadlocks are less likely to occur.</span></span> <span data-ttu-id="6c498-1169">例如，如果同時發生的兩筆交易都取得 **Supplier** 資料表的鎖定，再取得 **Part** 資料表的鎖定，其中一筆交易便被封鎖於 **Supplier** 資料表直到另一筆交易完成為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1169">For example, if two concurrent transactions obtain a lock on the **Supplier** table and then on the **Part** table, one transaction is blocked on the **Supplier** table until the other transaction is completed.</span></span> <span data-ttu-id="6c498-1170">第一筆交易認可或回復之後，第二筆才會繼續，這樣就不會發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-1170">After the first transaction commits or rolls back, the second continues, and a deadlock does not occur.</span></span> <span data-ttu-id="6c498-1171">使用預存程序來進行所有的資料修改動作可將物件的存取順序標準化。</span><span class="sxs-lookup"><span data-stu-id="6c498-1171">Using stored procedures for all data modifications can standardize the order of accessing objects.</span></span>  
  
 <span data-ttu-id="6c498-1172">![顯示死結避免的圖表](media/dedlck2.gif "顯示死結避免的圖表")</span><span class="sxs-lookup"><span data-stu-id="6c498-1172">![Diagram showing deadlock avoidance](media/dedlck2.gif "Diagram showing deadlock avoidance")</span></span>  
  
##### <a name="avoid-user-interaction-in-transactions"></a><span data-ttu-id="6c498-1173">在交易中避免使用者互動</span><span class="sxs-lookup"><span data-stu-id="6c498-1173">Avoid User Interaction in Transactions</span></span>  

 <span data-ttu-id="6c498-1174">避免撰寫包含使用者互動的交易，因為沒有使用者介入的批次執行速度比使用者必須對查詢做出手動回應的批次更快，例如對應用程式所要求的參數提示做出回覆。</span><span class="sxs-lookup"><span data-stu-id="6c498-1174">Avoid writing transactions that include user interaction, because the speed of batches running without user intervention is much faster than the speed at which a user must manually respond to queries, such as replying to a prompt for a parameter requested by an application.</span></span> <span data-ttu-id="6c498-1175">例如，交易如果正在等候使用者輸入，而使用者去用餐，或甚至回家渡假，交易就會被使用者延遲而無法完成。</span><span class="sxs-lookup"><span data-stu-id="6c498-1175">For example, if a transaction is waiting for user input and the user goes to lunch or even home for the weekend, the user delays the transaction from completing.</span></span> <span data-ttu-id="6c498-1176">如此便會降低系統產能，因為交易所持有的任何鎖定只有在交易被認可或回復之後才會釋放。</span><span class="sxs-lookup"><span data-stu-id="6c498-1176">This degrades system throughput because any locks held by the transaction are released only when the transaction is committed or rolled back.</span></span> <span data-ttu-id="6c498-1177">即使並未發生死結的狀況，要存取相同資源的其他交易還是會被封鎖而等待交易完成。</span><span class="sxs-lookup"><span data-stu-id="6c498-1177">Even if a deadlock situation does not arise, other transactions accessing the same resources are blocked while waiting for the transaction to complete.</span></span>  
  
##### <a name="keep-transactions-short-and-in-one-batch"></a><span data-ttu-id="6c498-1178">將交易維持在單一批次中且愈短愈好</span><span class="sxs-lookup"><span data-stu-id="6c498-1178">Keep Transactions Short and in One Batch</span></span>  

 <span data-ttu-id="6c498-1179">死結通常會在許多長時間執行的交易同時執行於相同的資料庫時發生。</span><span class="sxs-lookup"><span data-stu-id="6c498-1179">A deadlock typically occurs when several long-running transactions execute concurrently in the same database.</span></span> <span data-ttu-id="6c498-1180">交易的時間愈久，持有的獨占或更新鎖定就愈久，因而封鎖了其他的活動並導致發生死結狀況的可能性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1180">The longer the transaction, the longer the exclusive or update locks are held, blocking other activity and leading to possible deadlock situations.</span></span>  
  
 <span data-ttu-id="6c498-1181">將交易維持在單一批次中可降低交易期間的網路來回次數，因而降低了完成交易以及釋放鎖定的延遲可能性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1181">Keeping transactions in one batch minimizes network roundtrips during a transaction, reducing possible delays in completing the transaction and releasing locks.</span></span>  
  
##### <a name="use-a-lower-isolation-level"></a><span data-ttu-id="6c498-1182">使用較低的隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1182">Use a Lower Isolation Level</span></span>  

 <span data-ttu-id="6c498-1183">判斷是否可以較低的隔離等級執行交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1183">Determine whether a transaction can run at a lower isolation level.</span></span> <span data-ttu-id="6c498-1184">實作讀取認可讓交易可以對另一筆交易先前讀取 (未修改) 的資料進行讀取，而不必等待前一筆交易完成。</span><span class="sxs-lookup"><span data-stu-id="6c498-1184">Implementing read committed allows a transaction to read data previously read (not modified) by another transaction without waiting for the first transaction to complete.</span></span> <span data-ttu-id="6c498-1185">使用較低的隔離等級 (如讀取認可)，則持有共用鎖定的期間比使用較高的隔離等級(如序列化) 更短。</span><span class="sxs-lookup"><span data-stu-id="6c498-1185">Using a lower isolation level, such as read committed, holds shared locks for a shorter duration than a higher isolation level, such as serializable.</span></span> <span data-ttu-id="6c498-1186">如此就可減少鎖定競爭。</span><span class="sxs-lookup"><span data-stu-id="6c498-1186">This reduces locking contention.</span></span>  
  
##### <a name="use-a-row-versioning-based-isolation-level"></a><span data-ttu-id="6c498-1187">使用資料列版本設定基礎的隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1187">Use a Row Versioning-based Isolation Level</span></span>  

 <span data-ttu-id="6c498-1188">當 READ_COMMITTED_SNAPSHOT 資料庫選項設為 ON 時，在讀取認可隔離等級下執行的交易會使用資料料版本控制，而非讀取作業期間的共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1188">When the READ_COMMITTED_SNAPSHOT database option is set ON, a transaction running under read committed isolation level uses row versioning rather than shared locks during read operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1189">部份應用程式則依靠讀取認可隔離的鎖定和鎖定行為。</span><span class="sxs-lookup"><span data-stu-id="6c498-1189">Some applications rely upon locking and blocking behavior of read committed isolation.</span></span> <span data-ttu-id="6c498-1190">對於這些應用程式，在啟用選項之前，需要進行部份變更。</span><span class="sxs-lookup"><span data-stu-id="6c498-1190">For these applications, some change is required before this option can be enabled.</span></span>  
  
 <span data-ttu-id="6c498-1191">快照隔離也使用資料列版本設定，不使用讀取作業期間的共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1191">Snapshot isolation also uses row versioning, which does not use shared locks during read operations.</span></span> <span data-ttu-id="6c498-1192">ALLOW_SNAPSHOT_ISOLATION 資料庫選項必須設為 ON，交易才能在快照隔離下執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1192">Before a transaction can run under snapshot isolation, the ALLOW_SNAPSHOT_ISOLATION database option must be set ON.</span></span>  
  
 <span data-ttu-id="6c498-1193">實作這些隔離等級可將讀取和寫入作業之間發生的死結降到最低。</span><span class="sxs-lookup"><span data-stu-id="6c498-1193">Implement these isolation levels to minimize deadlocks that can occur between read and write operations.</span></span>  
  
##### <a name="use-bound-connections"></a><span data-ttu-id="6c498-1194">使用繫結連接</span><span class="sxs-lookup"><span data-stu-id="6c498-1194">Use Bound Connections</span></span>  

 <span data-ttu-id="6c498-1195">使用繫結連接，則同一個應用程式所開啟的二或多個連接可以互相合作。</span><span class="sxs-lookup"><span data-stu-id="6c498-1195">Using bound connections, two or more connections opened by the same application can cooperate with each other.</span></span> <span data-ttu-id="6c498-1196">如果先前由主要連接獲得鎖定，則會讓次要連接持有獲得的鎖定，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="6c498-1196">Any locks acquired by the secondary connections are held as if they were acquired by the primary connection, and vice versa.</span></span> <span data-ttu-id="6c498-1197">所以它們不會互相鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1197">Therefore they do not block each other.</span></span>  
  
### <a name="lock-partitioning"></a><span data-ttu-id="6c498-1198">鎖定資料分割</span><span class="sxs-lookup"><span data-stu-id="6c498-1198">Lock Partitioning</span></span>  

 <span data-ttu-id="6c498-1199">對於大型電腦系統而言，鎖定經常參考的物件將會形成效能瓶頸，這是因為鎖定的取得與釋放，將會在內部鎖定資源上引發競爭問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-1199">For large computer systems, locks on frequently referenced objects can become a performance bottleneck as acquiring and releasing locks place contention on internal locking resources.</span></span> <span data-ttu-id="6c498-1200">鎖定資料分割可將單一鎖定資源分割成多個鎖定資源，進而增強鎖定效能。</span><span class="sxs-lookup"><span data-stu-id="6c498-1200">Lock partitioning enhances locking performance by splitting a single lock resource into multiple lock resources.</span></span> <span data-ttu-id="6c498-1201">這項功能僅適用於擁有 16 顆以上 CPU 的系統，而且它會自動啟用，而不能停用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1201">This feature is only available for systems with 16 or more CPUs, and is automatically enabled and cannot be disabled.</span></span> <span data-ttu-id="6c498-1202">只有物件鎖定可以被分割。具有子類型的物件鎖定不能被分割。</span><span class="sxs-lookup"><span data-stu-id="6c498-1202">Only object locks can be partitioned.Object locks that have a subtype are not partitioned.</span></span> <span data-ttu-id="6c498-1203">如需詳細資訊，請參閱 [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1203">For more information, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span>  
  
#### <a name="understanding-lock-partitioning"></a><span data-ttu-id="6c498-1204">認識鎖定資料分割</span><span class="sxs-lookup"><span data-stu-id="6c498-1204">Understanding Lock Partitioning</span></span>  

 <span data-ttu-id="6c498-1205">鎖定工作會存取數項共用資源，其中兩項資源會因鎖定資料分割而最佳化：</span><span class="sxs-lookup"><span data-stu-id="6c498-1205">Locking tasks access several shared resources, two of which are optimized by lock partitioning:</span></span>  
  
-   <span data-ttu-id="6c498-1206">**單一執行緒存取鎖**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1206">**Spinlock**.</span></span> <span data-ttu-id="6c498-1207">這個資源控制對鎖定資源 (例如資料列或資料表) 的存取。</span><span class="sxs-lookup"><span data-stu-id="6c498-1207">This controls access to a lock resource, such as a row or a table.</span></span>  
  
     <span data-ttu-id="6c498-1208">若沒有鎖定資料分割，便會由單一執行緒存取鎖，管理所有鎖定要求的單一鎖定資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-1208">Without lock partitioning, one spinlock manages all lock requests for a single lock resource.</span></span> <span data-ttu-id="6c498-1209">在經歷大量活動的系統上，因為有許多鎖定要求等候單一執行緒存取鎖變成可用狀態，所以會發生競爭問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-1209">On systems that experience a large volume of activity, contention can occur as lock requests wait for the spinlock to become available.</span></span> <span data-ttu-id="6c498-1210">在這種情況下，取得鎖定將會形成瓶頸，進而對效能產生負面的影響。</span><span class="sxs-lookup"><span data-stu-id="6c498-1210">Under this situation, acquiring locks can become a bottleneck and can negatively impact performance.</span></span>  
  
     <span data-ttu-id="6c498-1211">為了減少單一鎖定資源上的競爭問題，鎖定資料分割會把單一鎖定資源分割成多個鎖定資源，以將負載分散到多個單一執行緒存取鎖。</span><span class="sxs-lookup"><span data-stu-id="6c498-1211">To reduce contention on a single lock resource, lock partitioning splits a single lock resource into multiple lock resources to distribute the load across multiple spinlocks.</span></span>  
  
-   <span data-ttu-id="6c498-1212">**記憶體**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1212">**Memory**.</span></span> <span data-ttu-id="6c498-1213">這個資源用來儲存鎖定資源結構。</span><span class="sxs-lookup"><span data-stu-id="6c498-1213">This is used to store the lock resource structures.</span></span>  
  
     <span data-ttu-id="6c498-1214">取得單一執行緒存取鎖之後，鎖定結構就會儲存在記憶體中以待存取，甚至修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-1214">Once the spinlock is acquired, lock structures are stored in memory and then accessed and possibly modified.</span></span> <span data-ttu-id="6c498-1215">將鎖定存取分散到多個資源，有助於省去在 CPU 之間傳輸記憶體區塊的需要，而這有利於改善效能。</span><span class="sxs-lookup"><span data-stu-id="6c498-1215">Distributing lock access across multiple resources helps to eliminate the need to transfer memory blocks between CPUs, which will help to improve performance.</span></span>  
  
#### <a name="implementing-and-monitoring-lock-partitioning"></a><span data-ttu-id="6c498-1216">實作與監視鎖定資料分割</span><span class="sxs-lookup"><span data-stu-id="6c498-1216">Implementing and Monitoring Lock Partitioning</span></span>  

 <span data-ttu-id="6c498-1217">在擁有 16 顆以上 CPU 的系統中，鎖定資料分割預設會開啟。</span><span class="sxs-lookup"><span data-stu-id="6c498-1217">Lock partitioning is turned on by default for systems with 16 or more CPUs.</span></span> <span data-ttu-id="6c498-1218">啟用鎖定資料分割時，會在 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 錯誤記錄檔中記錄參考用訊息。</span><span class="sxs-lookup"><span data-stu-id="6c498-1218">When lock partitioning is enabled, an informational message is recorded in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span>  
  
 <span data-ttu-id="6c498-1219">在資料分割資源上取得鎖定時：</span><span class="sxs-lookup"><span data-stu-id="6c498-1219">When acquiring locks on a partitioned resource:</span></span>  
  
-   <span data-ttu-id="6c498-1220">只有 NL、SCH-S、IS、IU 和 IX 鎖定模式是在單一資料分割上取得。</span><span class="sxs-lookup"><span data-stu-id="6c498-1220">Only NL, SCH-S, IS, IU, and IX lock modes are acquired on a single partition.</span></span>  
  
-   <span data-ttu-id="6c498-1221">在非 NL、SCH-S、IS、IU 和 IX 的模式下，所有資料分割上都必須取得共用 (S)、獨佔 (X) 和其他鎖定，順序為先在資料分割識別碼為 0 的資料分割上開始取得，接著再依照識別碼順序在其他資料分割上取得。</span><span class="sxs-lookup"><span data-stu-id="6c498-1221">Shared (S), exclusive (X), and other locks in modes other than NL, SCH-S, IS, IU, and IX must be acquired on all partitions starting with partition ID 0 and following in partition ID order.</span></span> <span data-ttu-id="6c498-1222">這些在資料分割資源上的鎖定將比相同模式下的非資料分割資源上的鎖定，佔用更多的記憶體，這是因為每個資料分割實際上都是一個不同的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1222">These locks on a partitioned resource will use more memory than locks in the same mode on a non-partitioned resource since each partition is effectively a separate lock.</span></span> <span data-ttu-id="6c498-1223">記憶體的增加取決於資料分割的數目。</span><span class="sxs-lookup"><span data-stu-id="6c498-1223">The memory increase is determined by the number of partitions.</span></span> <span data-ttu-id="6c498-1224">「Windows 效能監視器」中的 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 鎖定計數器將會顯示有關資料分割鎖定和非資料分割鎖定所佔用記憶體的資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1224">The [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] lock counters in the Windows Performance Monitor will display information about memory used by partitioned and non-partitioned locks.</span></span>  
  
 <span data-ttu-id="6c498-1225">啟動交易時，系統會將交易指派給資料分割。</span><span class="sxs-lookup"><span data-stu-id="6c498-1225">A transaction is assigned to a partition when the transaction starts.</span></span> <span data-ttu-id="6c498-1226">對於交易而言，所有可以分割的鎖定要求都會使用指派給該交易的資料分割。</span><span class="sxs-lookup"><span data-stu-id="6c498-1226">For the transaction, all lock requests that can be partitioned use the partition assigned to that transaction.</span></span> <span data-ttu-id="6c498-1227">使用這個方法，不同交易對同一個物件的鎖定資源的存取，都會分散到不同的資料分割。</span><span class="sxs-lookup"><span data-stu-id="6c498-1227">By this method, access to lock resources of the same object by different transactions is distributed across different partitions.</span></span>  
  
 <span data-ttu-id="6c498-1228">sys.dm_tran_locks 動態管理檢視中的 resource_lock_partition 資料行提供了鎖定資料分割資源的鎖定資料分割識別碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1228">The resource_lock_partition column in the sys.dm_tran_locks Dynamic Management View provides the lock partition ID for a lock partitioned resource.</span></span> <span data-ttu-id="6c498-1229">如需詳細資訊，請參閱 [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1229">For more information, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1230">在 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)]中的 Locks 事件之下，BigintData1 資料行提供了鎖定資料分割資源的鎖定資料分割識別碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1230">Under the Locks event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)], the BigintData1 column provides the lock partition ID for a lock partitioned resource.</span></span>  
  
#### <a name="working-with-lock-partitioning"></a><span data-ttu-id="6c498-1231">使用鎖定資料分割</span><span class="sxs-lookup"><span data-stu-id="6c498-1231">Working with Lock Partitioning</span></span>  

 <span data-ttu-id="6c498-1232">下列程式碼範例說明了鎖定資料分割。</span><span class="sxs-lookup"><span data-stu-id="6c498-1232">The following code examples illustrate lock partitioning.</span></span> <span data-ttu-id="6c498-1233">在這些範例中，會在兩個不同的工作階段中各執行一個交易，以便顯示在具有 16 顆 CPU 之電腦系統上的鎖定資料分割行為。</span><span class="sxs-lookup"><span data-stu-id="6c498-1233">In the examples, two transactions are executed in two different sessions in order to show lock partitioning behavior on a computer system with 16 CPUs.</span></span>  
  
 <span data-ttu-id="6c498-1234">下列 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式會建立稍後範例中將會使用的測試物件。</span><span class="sxs-lookup"><span data-stu-id="6c498-1234">These [!INCLUDE[tsql](../includes/tsql-md.md)] statements create test objects that are used in the examples that follow.</span></span>  
  
```sql  
-- Create a test table.  
CREATE TABLE TestTable  
    (col1        int);  
GO  
  
-- Create a clustered index on the table.  
CREATE CLUSTERED INDEX ci_TestTable   
    ON TestTable (col1);  
GO  
  
-- Populate the table.  
INSERT INTO TestTable VALUES (1);  
GO  
```  
  
##### <a name="example-a"></a><span data-ttu-id="6c498-1235">範例 A</span><span class="sxs-lookup"><span data-stu-id="6c498-1235">Example A</span></span>  

 <span data-ttu-id="6c498-1236">工作階段 1：</span><span class="sxs-lookup"><span data-stu-id="6c498-1236">Session 1:</span></span>  
  
 <span data-ttu-id="6c498-1237">`SELECT` 陳述式會在交易之下執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1237">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="6c498-1238">因為有 `HOLDLOCK` 鎖定提示，所以這個陳述式將在資料表上取得及保留意圖共用 (IS) 鎖定 (在這個範例中，將忽略資料列和頁面鎖定)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1238">Because of the `HOLDLOCK` lock hint, this statement will acquire and retain an Intent shared (IS) lock on the table (for this illustration, row and page locks are ignored).</span></span> <span data-ttu-id="6c498-1239">只有在指派給交易的資料分割上能取得 IS 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1239">The IS lock will be acquired only on the partition assigned to the transaction.</span></span> <span data-ttu-id="6c498-1240">在這個範例中，假設是在分割區 ID 7 上取得 IS 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1240">For this example, it is assumed that the IS lock is acquired on partition ID 7.</span></span>  
  
```sql  
-- Start a transaction.  
BEGIN TRANSACTION  
    -- This SELECT statement will acquire an IS lock on the table.  
    SELECT col1  
        FROM TestTable  
        WITH (HOLDLOCK);  
```  
  
 <span data-ttu-id="6c498-1241">工作階段 2：</span><span class="sxs-lookup"><span data-stu-id="6c498-1241">Session 2:</span></span>  
  
 <span data-ttu-id="6c498-1242">啟動交易，在這個交易之下執行的 `SELECT` 陳述式將在資料表上取得及保留共用 (S) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1242">A transaction is started, and the `SELECT` statement running under this transaction will acquire and retain a shared (S) lock on the table.</span></span> <span data-ttu-id="6c498-1243">所有資料分割上都能取得 S 鎖定，而這會造成多個資料表鎖定，每一個都是針對一個資料分割。</span><span class="sxs-lookup"><span data-stu-id="6c498-1243">The S lock will be acquired on all partitions which results in multiple table locks, one for each partition.</span></span> <span data-ttu-id="6c498-1244">例如在 16 個 CPU 的系統上，將會橫跨鎖定資料分割識別碼 0-15 來發出 16 S 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1244">For example, on a 16-cpu system, 16 S locks will be issued across lock partition IDs 0-15.</span></span> <span data-ttu-id="6c498-1245">因為 S 鎖定與資料分割識別碼 7 上由工作階段 1 中之交易所持有的 IS 鎖定相容，所以交易之間不會發生封鎖現象。</span><span class="sxs-lookup"><span data-stu-id="6c498-1245">Because the S lock is compatible with the IS lock being held on partition ID 7 by the transaction in session 1, there is no blocking between transactions.</span></span>  
  
```sql  
BEGIN TRANSACTION  
    SELECT col1  
        FROM TestTable  
        WITH (TABLOCK, HOLDLOCK);  
```  
  
 <span data-ttu-id="6c498-1246">工作階段 1：</span><span class="sxs-lookup"><span data-stu-id="6c498-1246">Session 1:</span></span>  
  
 <span data-ttu-id="6c498-1247">下列 `SELECT` 陳述式會在工作階段 1 中仍在使用中的交易下執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1247">The following `SELECT` statement is executed under the transaction that is still active under session 1.</span></span> <span data-ttu-id="6c498-1248">因為有獨佔 (X) 資料表鎖定提示，所以交易將會嘗試取得資料表上的 X 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1248">Because of the exclusive (X) table lock hint, the transaction will attempt to acquire an X lock on the table.</span></span> <span data-ttu-id="6c498-1249">不過，由工作階段 2 中之交易所持有的 S 鎖定，將會封鎖資料分割識別碼 0 的 X 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1249">However, the S lock that is being held by the transaction in session 2 will block the X lock at partition ID 0.</span></span>  
  
```sql  
SELECT col1  
    FROM TestTable  
    WITH (TABLOCKX);  
```  
  
##### <a name="example-b"></a><span data-ttu-id="6c498-1250">範例 B</span><span class="sxs-lookup"><span data-stu-id="6c498-1250">Example B</span></span>  

 <span data-ttu-id="6c498-1251">工作階段 1：</span><span class="sxs-lookup"><span data-stu-id="6c498-1251">Session 1:</span></span>  
  
 <span data-ttu-id="6c498-1252">`SELECT` 陳述式會在交易之下執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1252">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="6c498-1253">因為有 `HOLDLOCK` 鎖定提示，所以這個陳述式將在資料表上取得及保留意圖共用 (IS) 鎖定 (在這個範例中，將忽略資料列和頁面鎖定)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1253">Because of the `HOLDLOCK` lock hint, this statement will acquire and retain an Intent shared (IS) lock on the table (for this illustration, row and page locks are ignored).</span></span> <span data-ttu-id="6c498-1254">只有在指派給交易的資料分割上能取得 IS 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1254">The IS lock will be acquired only on the partition assigned to the transaction.</span></span> <span data-ttu-id="6c498-1255">在這個範例中，假設是在資料分割識別碼 6 上取得 IS 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1255">For this example, it is assumed that the IS lock is acquired on partition ID 6.</span></span>  
  
```sql  
-- Start a transaction.  
BEGIN TRANSACTION  
    -- This SELECT statement will acquire an IS lock on the table.  
    SELECT col1  
        FROM TestTable  
        WITH (HOLDLOCK);  
```  
  
 <span data-ttu-id="6c498-1256">工作階段 2：</span><span class="sxs-lookup"><span data-stu-id="6c498-1256">Session 2:</span></span>  
  
 <span data-ttu-id="6c498-1257">`SELECT` 陳述式會在交易之下執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1257">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="6c498-1258">因為有 `TABLOCKX` 封鎖提示，所以交易會嘗試在資料表上取得獨佔 (X) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1258">Because of the `TABLOCKX` lock hint, the transaction tries to acquire an exclusive (X) lock on the table.</span></span> <span data-ttu-id="6c498-1259">請記住，必須在資料分割識別碼 0 開頭的所有資料分割上取得 X 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1259">Remember that the X lock must be acquired on all partitions starting with partition ID 0.</span></span> <span data-ttu-id="6c498-1260">從資料分割識別碼 0 到 5 的所有資料分割上都會取得 X 鎖定，但是在資料分割識別碼 6 上取得的鎖定將會遭到 IS 鎖定封鎖。</span><span class="sxs-lookup"><span data-stu-id="6c498-1260">The X lock will be acquired on all partitions IDs 0-5 but will be blocked by the IS lock that is acquired on partition ID 6.</span></span>  
  
 <span data-ttu-id="6c498-1261">其他交易可以在 X 鎖定還沒到達的資料分割識別碼 7 到 15 上繼續取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1261">On partition IDs 7-15 that the X lock has not yet reached, other transactions can continue to acquire locks.</span></span>  
  
```sql  
BEGIN TRANSACTION  
    SELECT col1  
        FROM TestTable  
        WITH (TABLOCKX, HOLDLOCK);  
```  
  
 <span data-ttu-id="6c498-1262">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="6c498-1262">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="row-versioning-based-isolation-levels-in-the-database-engine"></a><a name="Row_versioning"></a><span data-ttu-id="6c498-1263">資料庫引擎中以資料列版本設定為基礎的隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1263">Row Versioning-based Isolation Levels in the Database Engine</span></span>  

 <span data-ttu-id="6c498-1264">從 SQL Server 2005 開始，Database Engine 引進了現有交易隔離等級 (讀取認可) 的實作，透過使用資料列版本設定以提供陳述式層級的快照。</span><span class="sxs-lookup"><span data-stu-id="6c498-1264">Starting with SQL Server 2005, the Database Engine offers an implementation of an existing transaction isolation level, read committed, that provides a statement level snapshot using row versioning.</span></span> <span data-ttu-id="6c498-1265">SQL Server Database Engine 另還引進一種交易隔離等級稱為快照，同樣是使用資料列版本設定但提供交易層級的快照。</span><span class="sxs-lookup"><span data-stu-id="6c498-1265">SQL Server Database Engine also offers a transaction isolation level, snapshot, that provides a transaction level snapshot also using row versioning.</span></span>  
  
 <span data-ttu-id="6c498-1266">資料列版本設定是 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 中的一般架構，會在資料列遭修改或刪除的情況下叫用寫入時複製機制。</span><span class="sxs-lookup"><span data-stu-id="6c498-1266">Row versioning is a general framework in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] that invokes a copy-on-write mechanism when a row is modified or deleted.</span></span> <span data-ttu-id="6c498-1267">為此，當交易正在執行時，舊版本的資料列務必可供仍需要早先交易一致狀態的交易使用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1267">This requires that while the transaction is running, the old version of the row must be available for transactions that require an earlier transactionally consistent state.</span></span> <span data-ttu-id="6c498-1268">資料列版本設定用於執行下列事項：</span><span class="sxs-lookup"><span data-stu-id="6c498-1268">Row versioning is used to do the following:</span></span>  
  
-   <span data-ttu-id="6c498-1269">在觸發程序中建立 **inserted** 及 **deleted** 資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1269">Build the **inserted** and **deleted** tables in triggers.</span></span> <span data-ttu-id="6c498-1270">經由觸發程序修改過的任何資料列都會被建立版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1270">Any rows modified by the trigger are versioned.</span></span> <span data-ttu-id="6c498-1271">這包括啟動觸發程序之陳述式所修改的資料列，以及觸發程序所做的任何資料修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-1271">This includes the rows modified by the statement that launched the trigger, as well as any data modifications made by the trigger.</span></span>  
  
-   <span data-ttu-id="6c498-1272">支援 Multiple Active Result Sets (MARS)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1272">Support Multiple Active Result Sets (MARS).</span></span> <span data-ttu-id="6c498-1273">如果 MARS 工作階段在有現用結果集的情況下，發出資料修改陳述式 (例如 INSERT、UPDATE 或 DELETE)，就會為修改陳述式所影響的資料列建立版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1273">If a MARS session issues a data modification statement (such as INSERT, UPDATE, or DELETE) at a time there is an active result set, the rows affected by the modification statement are versioned.</span></span>  
  
-   <span data-ttu-id="6c498-1274">支援指定 ONLINE 選項的索引作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1274">Support index operations that specify the ONLINE option.</span></span>  
  
-   <span data-ttu-id="6c498-1275">支援以資料列版本設定為基礎的交易隔離等級：</span><span class="sxs-lookup"><span data-stu-id="6c498-1275">Support row versioning-based transaction isolation levels:</span></span>  
  
    -   <span data-ttu-id="6c498-1276">新的讀取認可隔離等級實作方式，其使用資料列版本設定來提供陳述式層級的讀取一致性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1276">A new implementation of read committed isolation level that uses row versioning to provide statement-level read consistency.</span></span>  
  
    -   <span data-ttu-id="6c498-1277">新的隔離等級 (快照集)，可以提供交易等級的讀取一致性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1277">A new isolation level, snapshot, to provide transaction-level read consistency.</span></span>  
  
 <span data-ttu-id="6c498-1278">`tempdb` 資料庫必須要有足夠的空間供版本存放區使用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1278">The `tempdb` database must have enough space for the version store.</span></span> <span data-ttu-id="6c498-1279">當 `tempdb` 已滿時，更新作業會停止產生版本並繼續執行成功，但讀取作業可能會失敗，因為所需的特定資料列版本已不存在。</span><span class="sxs-lookup"><span data-stu-id="6c498-1279">When `tempdb` is full, update operations will stop generating versions and continue to succeed, but read operations might fail because a particular row version that is needed no longer exists.</span></span> <span data-ttu-id="6c498-1280">這會影響到像是觸發程序、MARS 及線上檢索索引之類的作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1280">This affects operations like triggers, MARS, and online indexing.</span></span>  
  
 <span data-ttu-id="6c498-1281">針對讀取認可及快照交易，使用資料列版本設定的方法是兩個步驟的程序：</span><span class="sxs-lookup"><span data-stu-id="6c498-1281">Using row versioning for read-committed and snapshot transactions is a two-step process:</span></span>  
  
1.  <span data-ttu-id="6c498-1282">將 READ_COMMITTED_SNAPSHOT 及 ALLOW_SNAPSHOT_ISOLATION 其中一個或兩個資料庫選項都設為 ON。</span><span class="sxs-lookup"><span data-stu-id="6c498-1282">Set either or both the READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION database options ON.</span></span>  
  
2.  <span data-ttu-id="6c498-1283">在應用程式中設定適當的交易隔離等級：</span><span class="sxs-lookup"><span data-stu-id="6c498-1283">Set the appropriate transaction isolation level in an application:</span></span>  
  
    -   <span data-ttu-id="6c498-1284">當 READ_COMMITTED_SNAPSHOT 資料庫選項為 ON，設定讀取認可隔離等級的交易就會使用資料列版本設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1284">When the READ_COMMITTED_SNAPSHOT database option is ON, transactions setting the read committed isolation level use row versioning.</span></span>  
  
    -   <span data-ttu-id="6c498-1285">當 ALLOW_SNAPSHOT_ISOLATION 資料庫選項為 ON，交易就會設定快照隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1285">When the ALLOW_SNAPSHOT_ISOLATION database option is ON, transactions can set the snapshot isolation level.</span></span>  
  
 <span data-ttu-id="6c498-1286">當 READ_COMMITTED_SNAPSHOT 或 ALLOW_SNAPSHOT_ISOLATION 其中一個資料庫選項設為 ON， [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 就會指定一個交易序號 (XSN) 給使用資料列版本設定來管理資料的每個交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1286">When either READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION database option is set ON, the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] assigns a transaction sequence number (XSN) to each transaction that manipulates data using row versioning.</span></span> <span data-ttu-id="6c498-1287">交易會在執行 BEGIN TRANSACTION 陳述式時開始。</span><span class="sxs-lookup"><span data-stu-id="6c498-1287">Transactions start at the time a BEGIN TRANSACTION statement is executed.</span></span> <span data-ttu-id="6c498-1288">但是交易序號會從 BEGIN TRANSACTION 陳述式之後的第一個讀取或寫入作業開始。</span><span class="sxs-lookup"><span data-stu-id="6c498-1288">However, the transaction sequence number starts with the first read or write operation after the BEGIN TRANSACTION statement.</span></span> <span data-ttu-id="6c498-1289">每指定一個交易序號，就會累加一個號碼。</span><span class="sxs-lookup"><span data-stu-id="6c498-1289">The transaction sequence number is incremented by one each time it is assigned.</span></span>  
  
 <span data-ttu-id="6c498-1290">當 READ_COMMITTED_SNAPSHOT 或 ALLOW_SNAPSHOT_ISOLATION 其中一個資料庫選項為 ON，就會針對在資料庫中執行的所有資料修改來維護邏輯副本 (版本)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1290">When either the READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION database options are ON, logical copies (versions) are maintained for all data modifications performed in the database.</span></span> <span data-ttu-id="6c498-1291">每次特定交易修改資料列時，[!INCLUDE[ssDE](../includes/ssde-md.md)]執行個體都會在 `tempdb` 中儲存先前認可的資料列映像版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1291">Every time a row is modified by a specific transaction, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] stores a version of the previously committed image of the row in `tempdb`.</span></span> <span data-ttu-id="6c498-1292">每個版本都會標示執行變更之交易的交易序號。</span><span class="sxs-lookup"><span data-stu-id="6c498-1292">Each version is marked with the transaction sequence number of the transaction that made the change.</span></span> <span data-ttu-id="6c498-1293">修改過的資料列版本會以連結清單鏈結起來。</span><span class="sxs-lookup"><span data-stu-id="6c498-1293">The versions of modified rows are chained using a link list.</span></span> <span data-ttu-id="6c498-1294">最新的資料列值一律儲存在目前的資料庫中，並鏈結到儲存在 `tempdb` 中已設定版本的資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-1294">The newest row value is always stored in the current database and chained to the versioned rows stored in `tempdb`.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1295">針對大型物件 (LOB) 修改，只會將變更過的片段複製到 `tempdb` 中的版本存放區。</span><span class="sxs-lookup"><span data-stu-id="6c498-1295">For modification of large objects (LOBs), only the changed fragment is copied to the version store in `tempdb`.</span></span>  
  
 <span data-ttu-id="6c498-1296">資料列版本會被保存夠久的時間，可滿足以資料列版本設定為基礎之隔離等級來執行的交易需求。</span><span class="sxs-lookup"><span data-stu-id="6c498-1296">Row versions are held long enough to satisfy the requirements of transactions running under row versioning-based isolation levels.</span></span> <span data-ttu-id="6c498-1297">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會追蹤最早的有用交易序號，並定期刪除交易序號低於最早有用交易序號的所有資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1297">The [!INCLUDE[ssDE](../includes/ssde-md.md)] tracks the earliest useful transaction sequence number and periodically deletes all row versions stamped with transaction sequence numbers that are lower than the earliest useful sequence number.</span></span>  
  
 <span data-ttu-id="6c498-1298">當兩個資料庫選項都設為 OFF 時，就只會針對由觸發程序或 MARS 工作階段所修改的資料列，或是由 ONLINE (線上) 索引作業所讀取的資料列來建立版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1298">When both database options are set to OFF, only rows modified by triggers or MARS sessions, or read by ONLINE index operations, are versioned.</span></span> <span data-ttu-id="6c498-1299">不再需要那些資料列版本時，就會將其釋出。</span><span class="sxs-lookup"><span data-stu-id="6c498-1299">Those row versions are released when no longer needed.</span></span> <span data-ttu-id="6c498-1300">背景執行緒會定期執行，以移除過時的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1300">A background thread periodically executes to remove stale row versions.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1301">針對短期交易，可能會將修改過的資料列版本快取至緩衝集區，而不會寫入至 `tempdb` 資料庫的磁碟檔案。</span><span class="sxs-lookup"><span data-stu-id="6c498-1301">For short-running transactions, a version of a modified row may get cached in the buffer pool without getting written into the disk files of the `tempdb` database.</span></span> <span data-ttu-id="6c498-1302">如果已建立版本的資料列不需要存在很長的時間，就會直接將它從緩衝集區中卸除，而且不一定會引起 I/O 額外負荷。</span><span class="sxs-lookup"><span data-stu-id="6c498-1302">If the need for the versioned row is short-lived, it will simply get dropped from the buffer pool and may not necessarily incur I/O overhead.</span></span>  
  
### <a name="behavior-when-reading-data"></a><span data-ttu-id="6c498-1303">讀取資料時的行為</span><span class="sxs-lookup"><span data-stu-id="6c498-1303">Behavior When Reading Data</span></span>  

 <span data-ttu-id="6c498-1304">在以資料列版本設定為基礎之隔離下執行的交易要讀取資料時，讀取作業不會在所讀取的資料上取得共用 (S) 鎖定，因此不會阻礙正在修改資料的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1304">When transactions running under row versioning-based isolation read data, the read operations do not acquire shared (S) locks on the data being read, and therefore do not block transactions that are modifying data.</span></span> <span data-ttu-id="6c498-1305">此外，隨著所取得的鎖定數量減少，鎖定資源的額外負荷也會降低。</span><span class="sxs-lookup"><span data-stu-id="6c498-1305">Also, the overhead of locking resources is minimized as the number of locks acquired is reduced.</span></span> <span data-ttu-id="6c498-1306">使用資料列版本設定及快照隔離的讀取認可隔離作業，目的就是要提供已建立版本之資料的陳述式層級或交易等級讀取一致性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1306">Read committed isolation using row versioning and snapshot isolation are designed to provide statement-level or transaction-level read consistencies of versioned data.</span></span>  
  
 <span data-ttu-id="6c498-1307">所有的查詢，包括在資料列版本設定式隔離等級下執行的交易，都會在編譯和執行期間取得 Sch-S (結構描述穩定性) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1307">All queries, including transactions running under row versioning-based isolation levels, acquire Sch-S (schema stability) locks during compilation and execution.</span></span> <span data-ttu-id="6c498-1308">因此，當並行交易在資料表上保有 Sch-M (結構描述修改) 鎖定時，查詢將會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="6c498-1308">Because of this, queries are blocked when a concurrent transaction holds a Sch-M (schema modification) lock on the table.</span></span> <span data-ttu-id="6c498-1309">例如，資料定義語言 (DDL) 作業會在修改資料表的結構描述資訊之前先取得 Sch-M 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1309">For example, a data definition language (DDL) operation acquires a Sch-M lock before it modifies the schema information of the table.</span></span> <span data-ttu-id="6c498-1310">查詢交易，包括在資料列版本設定式隔離等級下執行的交易，在嘗試取得 Sch-S 鎖定時都會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="6c498-1310">Query transactions, including those running under a row versioning-based isolation level, are blocked when attempting to acquire a Sch-S lock.</span></span> <span data-ttu-id="6c498-1311">相反地，保有 Sch-S 鎖定的查詢將會封鎖嘗試取得 Sch-M 鎖定的並行交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1311">Conversely, a query holding a Sch-S lock blocks a concurrent transaction that attempts to acquire a Sch-M lock.</span></span>  
  
 <span data-ttu-id="6c498-1312">當使用快照隔離等級的交易開始時， [!INCLUDE[ssDE](../includes/ssde-md.md)] 的執行個體會記錄目前所有的使用中交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1312">When a transaction using the snapshot isolation level starts, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] records all of the currently active transactions.</span></span> <span data-ttu-id="6c498-1313">當快照交易讀取具有版本鏈結的資料列時， [!INCLUDE[ssDE](../includes/ssde-md.md)] 會依循該鏈結，並擷取下列交易序號的資料列：</span><span class="sxs-lookup"><span data-stu-id="6c498-1313">When the snapshot transaction reads a row that has a version chain, the [!INCLUDE[ssDE](../includes/ssde-md.md)] follows the chain and retrieves the row where the transaction sequence number is:</span></span>  
  
-   <span data-ttu-id="6c498-1314">最接近但小於讀取該資料列之快照交易的序號。</span><span class="sxs-lookup"><span data-stu-id="6c498-1314">Closest to but lower than the sequence number of the snapshot transaction reading the row.</span></span>  
  
-   <span data-ttu-id="6c498-1315">當快照交易開始時，不在使用中交易清單裡的序號。</span><span class="sxs-lookup"><span data-stu-id="6c498-1315">Not in the list of the transactions active when the snapshot transaction started.</span></span>  
  
 <span data-ttu-id="6c498-1316">快照集交易所執行的讀取作業會在快照集交易開始時，擷取已認可之每個資料列的最新版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1316">Read operations performed by a snapshot transaction retrieve the last version of each row that had been committed at the time the snapshot transaction started.</span></span> <span data-ttu-id="6c498-1317">這樣可以讓資料快照集在交易期間保持一致，就像交易一開始的資料一樣。</span><span class="sxs-lookup"><span data-stu-id="6c498-1317">This provides a transactionally consistent snapshot of the data as it existed at the start of the transaction.</span></span>  
  
 <span data-ttu-id="6c498-1318">使用資料列版本設定的讀取認可交易運作的方式也相當類似。</span><span class="sxs-lookup"><span data-stu-id="6c498-1318">Read-committed transactions using row versioning operate in much the same way.</span></span> <span data-ttu-id="6c498-1319">不同的地方在於，讀取認可交易在選擇資料列版本時，不會使用自己的交易序號。</span><span class="sxs-lookup"><span data-stu-id="6c498-1319">The difference is that the read-committed transaction does not use its own transaction sequence number when choosing row versions.</span></span> <span data-ttu-id="6c498-1320">每當有陳述式開始時，讀取認可交易就會讀取針對該 [!INCLUDE[ssDE](../includes/ssde-md.md)]執行個體所發出的最新交易序號。</span><span class="sxs-lookup"><span data-stu-id="6c498-1320">Each time a statement is started, the read-committed transaction reads the latest transaction sequence number issued for that instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span> <span data-ttu-id="6c498-1321">這個交易序號可用來為該陳述式選取正確的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1321">This is the transaction sequence number used to select the correct row versions for that statement.</span></span> <span data-ttu-id="6c498-1322">這樣可以讓讀取認可交易看到與每個陳述式開始時相同的資料快照。</span><span class="sxs-lookup"><span data-stu-id="6c498-1322">This allows read-committed transactions to see a snapshot of the data as it exists at the start of each statement.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1323">即使使用資料列版本設定的讀取認可交易可以提供陳述式層級資料的交易一致性檢視，這種類型的交易所產生或存取的資料列版本還是會保留到交易完成為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1323">Even though read-committed transactions using row versioning provides a transactionally consistent view of the data at a statement level, row versions generated or accessed by this type of transaction are maintained until the transaction completes.</span></span>  
  
### <a name="behavior-when-modifying-data"></a><span data-ttu-id="6c498-1324">修改資料時的行為</span><span class="sxs-lookup"><span data-stu-id="6c498-1324">Behavior When Modifying Data</span></span>  

 <span data-ttu-id="6c498-1325">在使用資料列版本設定的讀取認可交易中，會使用封鎖掃描來選取要更新的資料列，在封鎖掃描中，當資料值被讀取時，就會在資料列上進行更新 (U) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1325">In a read-committed transaction using row versioning, the selection of rows to update is done using a blocking scan where an update (U) lock is taken on the data row as data values are read.</span></span> <span data-ttu-id="6c498-1326">這與不使用資料列版本設定的讀取認可交易是一樣的。</span><span class="sxs-lookup"><span data-stu-id="6c498-1326">This is the same as a read-committed transaction that does not use row versioning.</span></span> <span data-ttu-id="6c498-1327">如果資料列不符合更新條件，就會解除該資料列的更新鎖定，並且會鎖定及掃描下一個資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-1327">If the data row does not meet the update criteria, the update lock is released on that row and the next row is locked and scanned.</span></span>  
  
 <span data-ttu-id="6c498-1328">在快照集隔離下執行的交易會使用開放式的方法來修改資料，在修改資料之前，會在資料上取得鎖定，只強制執行條件約束。</span><span class="sxs-lookup"><span data-stu-id="6c498-1328">Transactions running under snapshot isolation take an optimistic approach to data modification by acquiring locks on data before performing the modification only to enforce constraints.</span></span> <span data-ttu-id="6c498-1329">否則，在修改資料之前，不會在資料上取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1329">Otherwise, locks are not acquired on data until the data is to be modified.</span></span> <span data-ttu-id="6c498-1330">當資料列符合更新條件，快照交易會確認資料列尚未被快照交易開始之後認可的並行交易所修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-1330">When a data row meets the update criteria, the snapshot transaction verifies that the data row has not been modified by a concurrent transaction that committed after the snapshot transaction began.</span></span> <span data-ttu-id="6c498-1331">如果資料列已在快照交易外被修改，就會發生更新衝突，並終止快照交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1331">If the data row has been modified outside of the snapshot transaction, an update conflict occurs and the snapshot transaction is terminated.</span></span> <span data-ttu-id="6c498-1332">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會處理更新衝突，而且沒有可以停用更新衝突偵測的方法。</span><span class="sxs-lookup"><span data-stu-id="6c498-1332">The update conflict is handled by the [!INCLUDE[ssDE](../includes/ssde-md.md)] and there is no way to disable the update conflict detection.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1333">當快照交易存取以下任一項時，在快照隔離下執行的更新作業，會在讀取認可隔離之下於內部執行：</span><span class="sxs-lookup"><span data-stu-id="6c498-1333">Update operations running under snapshot isolation internally execute under read committed isolation when the snapshot transaction accesses any of the following:</span></span>  
>   
>  <span data-ttu-id="6c498-1334">具有 FOREIGN KEY 條件約束的資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1334">A table with a FOREIGN KEY constraint.</span></span>  
>   
>  <span data-ttu-id="6c498-1335">被另一個資料表的 FOREIGN KEY 條件約束所參考的資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1335">A table that is referenced in the FOREIGN KEY constraint of another table.</span></span>  
>   
>  <span data-ttu-id="6c498-1336">參照多個資料表的索引檢視。</span><span class="sxs-lookup"><span data-stu-id="6c498-1336">An indexed view referencing more than one table.</span></span>  
>   
>  <span data-ttu-id="6c498-1337">然而，即使有這些條件限制，更新作業仍會繼續確認資料尚未被其他交易所修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-1337">However, even under these conditions the update operation will continue to verify that the data has not been modified by another transaction.</span></span> <span data-ttu-id="6c498-1338">如果資料已被其他交易所修改，快照交易會發生更新衝突，並終止作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1338">If data has been modified by another transaction, the snapshot transaction encounters an update conflict and is terminated.</span></span>  
  
### <a name="behavior-in-summary"></a><span data-ttu-id="6c498-1339">行為摘要</span><span class="sxs-lookup"><span data-stu-id="6c498-1339">Behavior in Summary</span></span>  

 <span data-ttu-id="6c498-1340">下表摘要說明使用資料列版本設定之快照隔離與讀取認可隔離之間的差異。</span><span class="sxs-lookup"><span data-stu-id="6c498-1340">The following table summarizes the differences between snapshot isolation and read committed isolation using row versioning.</span></span>  
  
|<span data-ttu-id="6c498-1341">屬性</span><span class="sxs-lookup"><span data-stu-id="6c498-1341">Property</span></span>|<span data-ttu-id="6c498-1342">使用資料列版本設定的讀取認可隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1342">Read-committed isolation level using row versioning</span></span>|<span data-ttu-id="6c498-1343">快照隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1343">Snapshot isolation level</span></span>|  
|--------------|----------------------------------------------------------|------------------------------|  
|<span data-ttu-id="6c498-1344">資料庫選項必須設為 ON，才能啟用必要的支援。</span><span class="sxs-lookup"><span data-stu-id="6c498-1344">The database option that must be set to ON to enable the required support.</span></span>|<span data-ttu-id="6c498-1345">READ_COMMITTED_SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="6c498-1345">READ_COMMITTED_SNAPSHOT</span></span>|<span data-ttu-id="6c498-1346">ALLOW_SNAPSHOT_ISOLATION</span><span class="sxs-lookup"><span data-stu-id="6c498-1346">ALLOW_SNAPSHOT_ISOLATION</span></span>|  
|<span data-ttu-id="6c498-1347">工作階段如何要求特定類型的資料列版本設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1347">How a session requests the specific type of row versioning.</span></span>|<span data-ttu-id="6c498-1348">使用預設的讀取認可隔離等級，或是執行 SET TRANSACTION ISOLATION LEVEL 陳述式來指定 READ COMMITTED 隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1348">Use the default read-committed isolation level, or run the SET TRANSACTION ISOLATION LEVEL statement to specify the READ COMMITTED isolation level.</span></span> <span data-ttu-id="6c498-1349">您可以在交易開始後完成此作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1349">This can be done after the transaction starts.</span></span>|<span data-ttu-id="6c498-1350">需要執行 SET TRANSACTION ISOLATION LEVEL，以在交易開始之前指定 SNAPSHOT 隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1350">Requires the execution of SET TRANSACTION ISOLATION LEVEL to specify the SNAPSHOT isolation level before the start of the transaction.</span></span>|  
|<span data-ttu-id="6c498-1351">陳述式所讀取的資料版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1351">The version of data read by statements.</span></span>|<span data-ttu-id="6c498-1352">在每個陳述式開始之前認可的所有資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1352">All data that was committed before the start of each statement.</span></span>|<span data-ttu-id="6c498-1353">在每個交易開始之前認可的所有資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1353">All data that was committed before the start of each transaction.</span></span>|  
|<span data-ttu-id="6c498-1354">如何處理更新。</span><span class="sxs-lookup"><span data-stu-id="6c498-1354">How updates are handled.</span></span>|<span data-ttu-id="6c498-1355">從資料列版本還原成實際的資料，以選取要更新的資料列，並且在所選取的資料列上使用更新鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1355">Reverts from row versions to actual data to select rows to update and uses update locks on the data rows selected.</span></span> <span data-ttu-id="6c498-1356">在所要修改的實際資料列上取得獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1356">Acquires exclusive locks on actual data rows to be modified.</span></span> <span data-ttu-id="6c498-1357">無更新衝突偵測。</span><span class="sxs-lookup"><span data-stu-id="6c498-1357">No update conflict detection.</span></span>|<span data-ttu-id="6c498-1358">使用資料列版本來選取要更新的資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-1358">Uses row versions to select rows to update.</span></span> <span data-ttu-id="6c498-1359">嘗試在所要修改的實際資料列上取得獨佔鎖定，若該資料已被其他交易所修改，就會發生更新衝突，且快照交易會終止進行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1359">Tries to acquire an exclusive lock on the actual data row to be modified, and if the data has been modified by another transaction, an update conflict occurs and the snapshot transaction is terminated.</span></span>|  
|<span data-ttu-id="6c498-1360">更新衝突偵測。</span><span class="sxs-lookup"><span data-stu-id="6c498-1360">Update conflict detection.</span></span>|<span data-ttu-id="6c498-1361">無。</span><span class="sxs-lookup"><span data-stu-id="6c498-1361">None.</span></span>|<span data-ttu-id="6c498-1362">整合支援。</span><span class="sxs-lookup"><span data-stu-id="6c498-1362">Integrated support.</span></span> <span data-ttu-id="6c498-1363">無法停用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1363">Cannot be disabled.</span></span>|  
  
### <a name="row-versioning-resource-usage"></a><span data-ttu-id="6c498-1364">資料列版本設定資源的使用方式</span><span class="sxs-lookup"><span data-stu-id="6c498-1364">Row Versioning Resource Usage</span></span>  

 <span data-ttu-id="6c498-1365">資料列版本設定架構支援 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中提供的下列功能：</span><span class="sxs-lookup"><span data-stu-id="6c498-1365">The row versioning framework supports the following features available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="6c498-1366">觸發程序</span><span class="sxs-lookup"><span data-stu-id="6c498-1366">Triggers</span></span>  
  
-   <span data-ttu-id="6c498-1367">Multiple Active Result Set (MARS)</span><span class="sxs-lookup"><span data-stu-id="6c498-1367">Multiple Active Results Sets (MARS)</span></span>  
  
-   <span data-ttu-id="6c498-1368">線上檢索索引</span><span class="sxs-lookup"><span data-stu-id="6c498-1368">Online indexing</span></span>  
  
 <span data-ttu-id="6c498-1369">資料列版本設定架構也支援下列資料列版本設定式的交易隔離等級 (預設不會啟用)：</span><span class="sxs-lookup"><span data-stu-id="6c498-1369">The row versioning framework also supports the following row versioning-based transaction isolation levels, which by default are not enabled:</span></span>  
  
-   <span data-ttu-id="6c498-1370">當 READ_COMMITTED_SNAPSHOT 資料庫選項是 ON 時，READ_COMMITTED 交易會使用資料列版本設定來提供陳述式層級讀取一致性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1370">When the READ_COMMITTED_SNAPSHOT database option is ON, READ_COMMITTED transactions provide statement-level read consistency using row versioning.</span></span>  
  
-   <span data-ttu-id="6c498-1371">當 ALLOW_SNAPSHOT_ISOLATION 資料庫選項是 ON 時，SNAPSHOT 交易會使用資料列版本設定來提供交易層級讀取一致性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1371">When the ALLOW_SNAPSHOT_ISOLATION database option is ON, SNAPSHOT transactions provide transaction-level read consistency using row versioning.</span></span>  
  
 <span data-ttu-id="6c498-1372">資料列版本設定式的隔離等級因為不需對讀取作業使用共用鎖定，因而減少交易所取得的鎖定數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1372">Row versioning-based isolation levels reduce the number of locks acquired by transaction by eliminating the use of shared locks on read operations.</span></span> <span data-ttu-id="6c498-1373">如此可減少用來管理鎖定的資源，進而增加系統效能。</span><span class="sxs-lookup"><span data-stu-id="6c498-1373">This increases system performance by reducing the resources used to manage locks.</span></span> <span data-ttu-id="6c498-1374">減少交易被其他交易所取得的鎖定封鎖的次數，也可以增加效能。</span><span class="sxs-lookup"><span data-stu-id="6c498-1374">Performance is also increased by reducing the number of times a transaction is blocked by locks acquired by other transactions.</span></span>  
  
 <span data-ttu-id="6c498-1375">資料列版本設定式的隔離等級會增加資料修改所需的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-1375">Row versioning-based isolation levels increase the resources needed by data modifications.</span></span> <span data-ttu-id="6c498-1376">啟用這些選項會使資料庫的所有資料修改建立版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1376">Enabling these options causes all data modifications for the database to be versioned.</span></span> <span data-ttu-id="6c498-1377">即使沒有使用資料列版本設定式的隔離之使用中交易，也會將修改前的資料副本儲存在 tempdb 中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1377">A copy of the data before modification is stored in tempdb even when there are no active transactions using row versioning-based isolation.</span></span> <span data-ttu-id="6c498-1378">修改後的資料包括 tempdb 所儲存的版本化資料的指標。</span><span class="sxs-lookup"><span data-stu-id="6c498-1378">The data after modification includes a pointer to the versioned data stored in tempdb.</span></span> <span data-ttu-id="6c498-1379">若為大型物件，則所變更的物件只有一部分會複製到 tempdb 中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1379">For large objects, only part of the object that changed is copied to tempdb.</span></span>  
  
#### <a name="space-used-in-tempdb"></a><span data-ttu-id="6c498-1380">tempdb 使用的空間</span><span class="sxs-lookup"><span data-stu-id="6c498-1380">Space Used in tempdb</span></span>  

 <span data-ttu-id="6c498-1381">對於 [!INCLUDE[ssDE](../includes/ssde-md.md)] 的每一個執行個體，tempdb 必須有足夠空間來保存該執行個體中每一個資料庫所產生的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1381">For each instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], tempdb must have enough space to hold the row versions generated for every database in the instance.</span></span> <span data-ttu-id="6c498-1382">資料庫管理員必須確定 tempdb 有很大的空間可支援版本存放區。</span><span class="sxs-lookup"><span data-stu-id="6c498-1382">The database administrator must ensure that tempdb has ample space to support the version store.</span></span> <span data-ttu-id="6c498-1383">tempdb 有兩個版本存放區：</span><span class="sxs-lookup"><span data-stu-id="6c498-1383">There are two version stores in tempdb:</span></span>  
  
-   <span data-ttu-id="6c498-1384">線上索引組建版本存放區會用於所有資料庫的線上索引組建。</span><span class="sxs-lookup"><span data-stu-id="6c498-1384">The online index build version store is used for online index builds in all databases.</span></span>  
  
-   <span data-ttu-id="6c498-1385">一般版本存放區，用於所有資料庫的所有其他資料修改作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1385">The common version store is used for all other data modification operations in all databases.</span></span>  
  
 <span data-ttu-id="6c498-1386">資料列版本儲存的時間必須夠久，讓使用中交易可以存取它。</span><span class="sxs-lookup"><span data-stu-id="6c498-1386">Row versions must be stored for as long as an active transaction needs to access it.</span></span> <span data-ttu-id="6c498-1387">每隔一分鐘，背景執行緒就會移除不再需要的資料列版本，並釋放 tempdb 中的版本空間。</span><span class="sxs-lookup"><span data-stu-id="6c498-1387">Once every minute, a background thread removes row versions that are no longer needed and frees up the version space in tempdb.</span></span> <span data-ttu-id="6c498-1388">長時間執行的交易如果符合下列任何條件，就可以阻止釋放版本存放區的空間。</span><span class="sxs-lookup"><span data-stu-id="6c498-1388">A long-running transaction prevents space in the version store from being released if it meets any of the following conditions:</span></span>  
  
-   <span data-ttu-id="6c498-1389">它使用資料列版本設定式的隔離。</span><span class="sxs-lookup"><span data-stu-id="6c498-1389">It uses row versioning-based isolation.</span></span>  
  
-   <span data-ttu-id="6c498-1390">它使用觸發程序、MARS 或線上索引組建作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1390">It uses triggers, MARS, or online index build operations.</span></span>  
  
-   <span data-ttu-id="6c498-1391">它產生資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1391">It generates row versions.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1392">在交易內叫用觸發程序時，會維護觸發程序建立的資料列版本，直到交易結束為止，即使在觸發程序完成之後不再需要資料列版本也一樣。</span><span class="sxs-lookup"><span data-stu-id="6c498-1392">When a trigger is invoked inside a transaction, the row versions created by the trigger are maintained until the end of the transaction, even though the row versions are no longer needed after the trigger completes.</span></span> <span data-ttu-id="6c498-1393">這也適用於使用資料列版本設定的讀取認可交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1393">This also applies to read-committed transactions that use row versioning.</span></span> <span data-ttu-id="6c498-1394">以此交易類型而言，只有在交易中的每一個陳述式才需要資料庫的交易一致檢視。</span><span class="sxs-lookup"><span data-stu-id="6c498-1394">With this type of transaction, a transactionally consistent view of the database is needed only for each statement in the transaction.</span></span> <span data-ttu-id="6c498-1395">這表示當交易中的陳述式完成之後，就不再需要為該陳述式建立的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1395">This means that the row versions created for a statement in the transaction are no longer needed after the statement completes.</span></span> <span data-ttu-id="6c498-1396">不過，仍會維護交易中每一個陳述式所建立的資料列版本，直到交易完成為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1396">However, row versions created by each statement in the transaction are maintained until the transaction completes.</span></span>  
  
 <span data-ttu-id="6c498-1397">當 tempdb 空間不夠時，[!INCLUDE[ssDE](../includes/ssde-md.md)] 會強制版本存放區壓縮。</span><span class="sxs-lookup"><span data-stu-id="6c498-1397">When tempdb runs out of space, the [!INCLUDE[ssDE](../includes/ssde-md.md)] forces the version stores to shrink.</span></span> <span data-ttu-id="6c498-1398">在壓縮處理期間，執行最久但尚未產生資料列版本的交易會標示為犧牲者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1398">During the shrink process, the longest running transactions that have not yet generated row versions are marked as victims.</span></span> <span data-ttu-id="6c498-1399">在錯誤記錄檔中會針對每一筆犧牲者交易產生訊息 3967。</span><span class="sxs-lookup"><span data-stu-id="6c498-1399">A message 3967 is generated in the error log for each victim transaction.</span></span> <span data-ttu-id="6c498-1400">如果交易已標示為犧牲者，它就不能再讀取版本存放區中的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1400">If a transaction is marked as a victim, it can no longer read the row versions in the version store.</span></span> <span data-ttu-id="6c498-1401">當它嘗試讀取資料列版本時，會產生訊息 3966 而且會回復交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1401">When it attempts to read row versions, message 3966 is generated and the transaction is rolled back.</span></span> <span data-ttu-id="6c498-1402">如果壓縮處理成功，tempdb 中的空間就會變成可用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1402">If the shrinking process succeeds, space becomes available in tempdb.</span></span> <span data-ttu-id="6c498-1403">否則，tempdb 的空間會不足，而且會發生下列情況：</span><span class="sxs-lookup"><span data-stu-id="6c498-1403">Otherwise, tempdb runs out of space and the following occurs:</span></span>  
  
-   <span data-ttu-id="6c498-1404">寫入作業繼續執行，但不產生版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1404">Write operations continue to execute but do not generate versions.</span></span> <span data-ttu-id="6c498-1405">在錯誤記錄檔中會出現資訊訊息 (3959)，但寫入資料的交易不受影響。</span><span class="sxs-lookup"><span data-stu-id="6c498-1405">An information message (3959) appears in the error log, but the transaction that writes data is not affected.</span></span>  
  
-   <span data-ttu-id="6c498-1406">交易嘗試存取的資料列版本若因為 tempdb 完全回復而未產生，則交易會終止，並出現錯誤 3958。</span><span class="sxs-lookup"><span data-stu-id="6c498-1406">Transactions that attempt to access row versions that were not generated because of a tempdb full rollback terminate with an error 3958.</span></span>  
  
#### <a name="space-used-in-data-rows"></a><span data-ttu-id="6c498-1407">資料列使用的空間</span><span class="sxs-lookup"><span data-stu-id="6c498-1407">Space Used in Data Rows</span></span>  

 <span data-ttu-id="6c498-1408">每個資料庫的資料列在資料列結尾可使用最多 14 個位元組，以存放資料列版本設定資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1408">Each database row may use up to 14 bytes at the end of the row for row versioning information.</span></span> <span data-ttu-id="6c498-1409">資料列版本設定資訊包含認可版本之交易的交易序號，以及版本化資料列的指標。</span><span class="sxs-lookup"><span data-stu-id="6c498-1409">The row versioning information contains the transaction sequence number of the transaction that committed the version and the pointer to the versioned row.</span></span> <span data-ttu-id="6c498-1410">這 14 個位元組會在第一次修改資料列或插入新的資料列時，而且符合下列任一情況時加入：</span><span class="sxs-lookup"><span data-stu-id="6c498-1410">These 14 bytes are added the first time the row is modified, or when a new row is inserted, under any of these conditions:</span></span>  
  
-   <span data-ttu-id="6c498-1411">READ_COMMITTED_SNAPSHOT 或 ALLOW_SNAPSHOT_ISOLATION 選項為 ON。</span><span class="sxs-lookup"><span data-stu-id="6c498-1411">READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION options are ON.</span></span>  
  
-   <span data-ttu-id="6c498-1412">資料表有觸發程序。</span><span class="sxs-lookup"><span data-stu-id="6c498-1412">The table has a trigger.</span></span>  
  
-   <span data-ttu-id="6c498-1413">使用 Multiple Active Result Set (MARS)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1413">Multiple Active Results Sets (MARS) is being used.</span></span>  
  
-   <span data-ttu-id="6c498-1414">目前正在資料表執行線上索引組建作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1414">Online index build operations are currently running on the table.</span></span>  
  
 <span data-ttu-id="6c498-1415">在下列這些情況下，第一次修改資料列時會從資料庫中移除這 14 個位元組：</span><span class="sxs-lookup"><span data-stu-id="6c498-1415">These 14 bytes are removed from the database row the first time the row is modified under all of these conditions:</span></span>  
  
-   <span data-ttu-id="6c498-1416">READ_COMMITTED_SNAPSHOT 和 ALLOW_SNAPSHOT_ISOLATION 選項為 OFF。</span><span class="sxs-lookup"><span data-stu-id="6c498-1416">READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION options are OFF.</span></span>  
  
-   <span data-ttu-id="6c498-1417">觸發程序已不在資料表上。</span><span class="sxs-lookup"><span data-stu-id="6c498-1417">The trigger no longer exists on the table.</span></span>  
  
-   <span data-ttu-id="6c498-1418">不使用 MARS。</span><span class="sxs-lookup"><span data-stu-id="6c498-1418">MARS is not being used.</span></span>  
  
-   <span data-ttu-id="6c498-1419">目前沒有執行中的線上索引建立作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1419">Online index build operations are not currently running.</span></span>  
  
 <span data-ttu-id="6c498-1420">如果您使用任何資料列版本設定功能，您可能需要配置額外的磁碟空間給資料庫，以容納每個資料庫資料列的 14 個位元組。</span><span class="sxs-lookup"><span data-stu-id="6c498-1420">If you use any of the row versioning features, you might need to allocate additional disk space for the database to accommodate the 14 bytes per database row.</span></span> <span data-ttu-id="6c498-1421">如果目前頁面沒有足夠的可用空間，則加入資料列版本設定資訊會造成索引頁面分割或需要配置新的資料頁。</span><span class="sxs-lookup"><span data-stu-id="6c498-1421">Adding the row versioning information can cause index page splits or the allocation of a new data page if there is not enough space available on the current page.</span></span> <span data-ttu-id="6c498-1422">例如，如果平均資料列長度是 100 個位元組，則額外的 14 個位元組會造成現有資料表成長高達百分之 14。</span><span class="sxs-lookup"><span data-stu-id="6c498-1422">For example, if the average row length is 100 bytes, the additional 14 bytes cause an existing table to grow up to 14 percent.</span></span>  
  
 <span data-ttu-id="6c498-1423">降低[填滿因數](../relational-databases/indexes/specify-fill-factor-for-an-index.md)可能有助於防止或減少索引頁片段。</span><span class="sxs-lookup"><span data-stu-id="6c498-1423">Decreasing the [fill factor](../relational-databases/indexes/specify-fill-factor-for-an-index.md) might help to prevent or decrease fragmentation of index pages.</span></span> <span data-ttu-id="6c498-1424">若要檢視資料表或檢視表之資料與索引的片段資訊，您可以使用 [DBCC SHOWCONTIG](/sql/t-sql/database-console-commands/dbcc-showcontig-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1424">To view fragmentation information for the data and indexes of a table or view, you can use [DBCC SHOWCONTIG](/sql/t-sql/database-console-commands/dbcc-showcontig-transact-sql).</span></span>  
  
#### <a name="space-used-in-large-objects"></a><span data-ttu-id="6c498-1425">大型物件使用的空間</span><span class="sxs-lookup"><span data-stu-id="6c498-1425">Space Used in Large Objects</span></span>  

 <span data-ttu-id="6c498-1426">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 支援 6 種資料類型，可保留長度多達 2 GB 的大型字串：`nvarchar(max)`、`varchar(max)`、`varbinary(max)`、`ntext`、`text` 和 `image`。</span><span class="sxs-lookup"><span data-stu-id="6c498-1426">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] supports six data types that can hold large strings up to 2 gigabytes (GB) in length: `nvarchar(max)`, `varchar(max)`, `varbinary(max)`, `ntext`, `text`, and `image`.</span></span> <span data-ttu-id="6c498-1427">使用這些資料類型儲存的大型字串是儲存在一系列資料片段中，而這些片段是連結到資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-1427">Large strings stored using these data types are stored in a series of data fragments that are linked to the data row.</span></span> <span data-ttu-id="6c498-1428">資料列版本設定資訊是儲存在用來儲存這些大型字串的每一個片段中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1428">Row versioning information is stored in each fragment used to store these large strings.</span></span> <span data-ttu-id="6c498-1429">資料片段是專供資料表中大型物件使用的頁面集合。</span><span class="sxs-lookup"><span data-stu-id="6c498-1429">Data fragments are a collection of pages dedicated to large objects in a table.</span></span>  
  
 <span data-ttu-id="6c498-1430">當新的大型值加入至資料庫時，會使用每個片段最多 8040 個位元組的資料來配置它們。</span><span class="sxs-lookup"><span data-stu-id="6c498-1430">As new large values are added to a database, they are allocated using a maximum of 8040 bytes of data per fragment.</span></span> <span data-ttu-id="6c498-1431">舊版的 [!INCLUDE[ssDE](../includes/ssde-md.md)] 中，每個片段儲存最多 8080 個位元組的 `ntext`、`text` 或 `image` 資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1431">Earlier versions of the [!INCLUDE[ssDE](../includes/ssde-md.md)] stored up to 8080 bytes of `ntext`, `text`, or `image` data per fragment.</span></span>  
  
 <span data-ttu-id="6c498-1432">當資料庫從舊版的 `ntext` 升級到 `text` 時，並不會更新現有的 `image`、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 和 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 大型物件 (LOB) 資料來提供存放資料列版本設定資訊的空間。</span><span class="sxs-lookup"><span data-stu-id="6c498-1432">Existing `ntext`, `text`, and `image` large object (LOB) data is not updated to make space for the row versioning information when a database is upgraded to [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] from an earlier version of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6c498-1433">不過，第一次修改 LOB 資料時，它會動態升級，以啟用版本控制資訊的儲存。</span><span class="sxs-lookup"><span data-stu-id="6c498-1433">However, the first time the LOB data is modified, it is dynamically upgraded to enable storage of versioning information.</span></span> <span data-ttu-id="6c498-1434">即使未產生資料列版本也會發生此情況。</span><span class="sxs-lookup"><span data-stu-id="6c498-1434">This will happen even if row versions are not generated.</span></span> <span data-ttu-id="6c498-1435">當 LOB 資料升級之後，每個片段儲存的最大位元組數會從 8080 個位元組降到 8040 個位元組。</span><span class="sxs-lookup"><span data-stu-id="6c498-1435">After the LOB data is upgraded, the maximum number of bytes stored per fragment is reduced from 8080 bytes to 8040 bytes.</span></span> <span data-ttu-id="6c498-1436">升級程序相當於刪除 LOB 值及重新插入相同值。</span><span class="sxs-lookup"><span data-stu-id="6c498-1436">The upgrade process is equivalent to deleting the LOB value and reinserting the same value.</span></span> <span data-ttu-id="6c498-1437">即使只修改一個位元組，也會升級 LOB 資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1437">The LOB data is upgraded even if only one byte is modified.</span></span> <span data-ttu-id="6c498-1438">每一個 `ntext`、`text` 或 `image` 資料行只有一次作業，但每一個作業可產生大量頁面配置和 I/O 活動，視 LOB 資料大小而定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1438">This is a one-time operation for each `ntext`, `text`, or `image` column, but each operation may generate a large amount of page allocations and I/O activity depending upon the size of the LOB data.</span></span> <span data-ttu-id="6c498-1439">如果有完整記錄各項修改，則它也可能產生大量記錄活動。</span><span class="sxs-lookup"><span data-stu-id="6c498-1439">It may also generate a large amount of logging activity if the modification is fully logged.</span></span> <span data-ttu-id="6c498-1440">如果資料庫復原模式未設為 FULL，則會為 WRITETEXT 和 UPDATETEXT 作業做最少的記錄。</span><span class="sxs-lookup"><span data-stu-id="6c498-1440">WRITETEXT and UPDATETEXT operations are minimally logged if database recovery mode is not set to FULL.</span></span>  
  
 <span data-ttu-id="6c498-1441">舊版的 `nvarchar(max)` 並沒有提供 `varchar(max)`、`varbinary(max)` 和 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 資料類型。</span><span class="sxs-lookup"><span data-stu-id="6c498-1441">The `nvarchar(max)`, `varchar(max)`, and `varbinary(max)` data types are not available in earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6c498-1442">因此，它們沒有升級問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-1442">Therefore, they have no upgrade issues.</span></span>  
  
 <span data-ttu-id="6c498-1443">應該配置足夠的磁碟空間來配合這項需求。</span><span class="sxs-lookup"><span data-stu-id="6c498-1443">Enough disk space should be allocated to accommodate this requirement.</span></span>  
  
#### <a name="monitoring-row-versioning-and-the-version-store"></a><span data-ttu-id="6c498-1444">監視資料列版本設定和版本存放區</span><span class="sxs-lookup"><span data-stu-id="6c498-1444">Monitoring Row Versioning and the Version Store</span></span>  

 <span data-ttu-id="6c498-1445">為了效能和問題而監視資料列版本設定、版本存放區和快照集隔離程序， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 以動態管理檢視 (DMV) 的形式提供工具，以及在 Windows 系統監視器中提供效能計數器。</span><span class="sxs-lookup"><span data-stu-id="6c498-1445">For monitoring row versioning, version store, and snapshot isolation processes for performance and problems, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] provides tools in the form of Dynamic Management Views (DMVs) and performance counters in Windows System Monitor.</span></span>  
  
##### <a name="dmvs"></a><span data-ttu-id="6c498-1446">DMV</span><span class="sxs-lookup"><span data-stu-id="6c498-1446">DMVs</span></span>  

 <span data-ttu-id="6c498-1447">下列 DMV 提供關於 tempdb 和版本存放區的目前系統狀態，以及使用資料版本控制的交易之資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1447">The following DMVs provide information about the current system state of tempdb and the version store, as well as transactions using row versioning.</span></span>  
  
 <span data-ttu-id="6c498-1448">sys.dm_db_file_space_usage。</span><span class="sxs-lookup"><span data-stu-id="6c498-1448">sys.dm_db_file_space_usage.</span></span> <span data-ttu-id="6c498-1449">傳回資料庫中每一個檔案的空間使用方式資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1449">Returns space usage information for each file in the database.</span></span> <span data-ttu-id="6c498-1450">如需詳細資訊，請參閱 [sys.dm_db_file_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-file-space-usage-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1450">For more information, see [sys.dm_db_file_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-file-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1451">sys.dm_db_session_space_usage。</span><span class="sxs-lookup"><span data-stu-id="6c498-1451">sys.dm_db_session_space_usage.</span></span> <span data-ttu-id="6c498-1452">由資料庫的工作階段傳回頁面配置和取消配置活動。</span><span class="sxs-lookup"><span data-stu-id="6c498-1452">Returns page allocation and deallocation activity by session for the database.</span></span> <span data-ttu-id="6c498-1453">如需詳細資訊，請參閱 [sys.dm_db_session_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-session-space-usage-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1453">For more information, see [sys.dm_db_session_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-session-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1454">sys.dm_db_task_space_usage。</span><span class="sxs-lookup"><span data-stu-id="6c498-1454">sys.dm_db_task_space_usage.</span></span> <span data-ttu-id="6c498-1455">傳回資料庫工作的頁面配置及取消配置活動。</span><span class="sxs-lookup"><span data-stu-id="6c498-1455">Returns page allocation and deallocation activity by task for the database.</span></span> <span data-ttu-id="6c498-1456">如需詳細資訊，請參閱 [sys.dm_db_task_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-task-space-usage-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1456">For more information, see [sys.dm_db_task_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-task-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1457">sys.dm_tran_top_version_generators。</span><span class="sxs-lookup"><span data-stu-id="6c498-1457">sys.dm_tran_top_version_generators.</span></span> <span data-ttu-id="6c498-1458">針對產生版本存放區中大部分版本的物件，傳回一份虛擬資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1458">Returns a virtual table for the objects producing the most versions in the version store.</span></span> <span data-ttu-id="6c498-1459">它按 database_id 和 rowset_id 來分組前 256 個彙總記錄長度。</span><span class="sxs-lookup"><span data-stu-id="6c498-1459">It groups the top 256 aggregated record lengths by database_id and rowset_id.</span></span> <span data-ttu-id="6c498-1460">使用此函數可尋找版本存放區的最大取用者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1460">Use this function to find the largest consumers of the version store.</span></span> <span data-ttu-id="6c498-1461">如需詳細資訊，請參閱 [sys.dm_tran_top_version_generators &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-top-version-generators-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1461">For more information, see [sys.dm_tran_top_version_generators &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-top-version-generators-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1462">sys.dm_tran_version_store。</span><span class="sxs-lookup"><span data-stu-id="6c498-1462">sys.dm_tran_version_store.</span></span> <span data-ttu-id="6c498-1463">傳回虛擬資料表來顯示一般版本存放區中的所有版本記錄。</span><span class="sxs-lookup"><span data-stu-id="6c498-1463">Returns a virtual table that displays all version records in the common version store.</span></span> <span data-ttu-id="6c498-1464">如需詳細資訊，請參閱 [sys.dm_tran_version_store &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-version-store-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1464">For more information, see [sys.dm_tran_version_store &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-version-store-transact-sql).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1465">sys.dm_tran_top_version_generators 和 sys.dm_tran_version_store 可能是執行代價很高的函數，因為兩者會查詢有可能是非常龐大的整個版本存放區。</span><span class="sxs-lookup"><span data-stu-id="6c498-1465">sys.dm_tran_top_version_generators and sys.dm_tran_version_store are potentially very expensive functions to run, since both query the entire version store, which could be very large.</span></span>  
  
 <span data-ttu-id="6c498-1466">sys.dm_tran_active_snapshot_database_transactions。</span><span class="sxs-lookup"><span data-stu-id="6c498-1466">sys.dm_tran_active_snapshot_database_transactions.</span></span> <span data-ttu-id="6c498-1467">在使用資料列版本設定的 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 執行個體內，傳回所有資料庫的所有使用中交易的虛擬資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1467">Returns a virtual table for all active transactions in all databases within the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] instance that use row versioning.</span></span> <span data-ttu-id="6c498-1468">系統交易不會出現在這個 DMV 中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1468">System transactions do not appear in this DMV.</span></span> <span data-ttu-id="6c498-1469">如需詳細資訊，請參閱 [sys.dm_tran_active_snapshot_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-active-snapshot-database-transactions-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1469">For more information, see [sys.dm_tran_active_snapshot_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-active-snapshot-database-transactions-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1470">sys.dm_tran_transactions_snapshot。</span><span class="sxs-lookup"><span data-stu-id="6c498-1470">sys.dm_tran_transactions_snapshot.</span></span> <span data-ttu-id="6c498-1471">傳回虛擬資料表，以顯示每一筆交易所產生的快照集。</span><span class="sxs-lookup"><span data-stu-id="6c498-1471">Returns a virtual table that displays snapshots taken by each transaction.</span></span> <span data-ttu-id="6c498-1472">快照集包含使用了資料列版本設定之使用中交易的序號。</span><span class="sxs-lookup"><span data-stu-id="6c498-1472">The snapshot contains the sequence number of the active transactions that use row versioning.</span></span> <span data-ttu-id="6c498-1473">如需詳細資訊，請參閱 [sys.dm_tran_transactions_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-transactions-snapshot-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1473">For more information, see [sys.dm_tran_transactions_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-transactions-snapshot-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1474">sys.dm_tran_current_transaction。</span><span class="sxs-lookup"><span data-stu-id="6c498-1474">sys.dm_tran_current_transaction.</span></span> <span data-ttu-id="6c498-1475">傳回單一資料列，顯示目前工作階段中交易的資料列版本設定相關之狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1475">Returns a single row that displays row versioning-related state information of the transaction in the current session.</span></span> <span data-ttu-id="6c498-1476">如需詳細資訊，請參閱 [sys.dm_tran_current_transaction &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-transaction-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1476">For more information, see [sys.dm_tran_current_transaction &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-transaction-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1477">sys.dm_tran_current_snapshot。</span><span class="sxs-lookup"><span data-stu-id="6c498-1477">sys.dm_tran_current_snapshot.</span></span> <span data-ttu-id="6c498-1478">傳回虛擬資料表，以顯示目前快照集隔離交易啟動時的所有使用中交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1478">Returns a virtual table that displays all active transactions at the time the current snapshot isolation transaction starts.</span></span> <span data-ttu-id="6c498-1479">如果目前的交易使用快照隔離，此函數不會傳回任何資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-1479">If the current transaction is using snapshot isolation, this function returns no rows.</span></span> <span data-ttu-id="6c498-1480">sys.dm_tran_current_snapshot 類似於 sys.dm_tran_transactions_snapshot，唯一差別在於它只會傳回目前快照集的作用中交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1480">sys.dm_tran_current_snapshot is similar to sys.dm_tran_transactions_snapshot, except that it returns only the active transactions for the current snapshot.</span></span> <span data-ttu-id="6c498-1481">如需詳細資訊，請參閱 [sys.dm_tran_current_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-snapshot-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1481">For more information, see [sys.dm_tran_current_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-snapshot-transact-sql).</span></span>  
  
##### <a name="performance-counters"></a><span data-ttu-id="6c498-1482">效能計數器</span><span class="sxs-lookup"><span data-stu-id="6c498-1482">Performance Counters</span></span>  

 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="6c498-1483">效能計數器可提供受到 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 程序影響的系統效能相關資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1483">performance counters provide information about the system performance impacted by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] processes.</span></span> <span data-ttu-id="6c498-1484">下列效能計數器會監視 tempdb、版本存放區以及使用資料列版本設定的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1484">The following performance counters monitor tempdb and the version store, as well as transactions using row versioning.</span></span> <span data-ttu-id="6c498-1485">效能計數器包含在 SQLServer:Transactions 效能物件中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1485">The performance counters are contained in the SQLServer:Transactions performance object.</span></span>  
  
 <span data-ttu-id="6c498-1486">**Free Space in tempdb (KB)** 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1486">**Free Space in tempdb (KB)**.</span></span> <span data-ttu-id="6c498-1487">監視 tempdb 資料庫的可用空間量，以 KB 為單位。</span><span class="sxs-lookup"><span data-stu-id="6c498-1487">Monitors the amount, in kilobytes (KB), of free space in the tempdb database.</span></span> <span data-ttu-id="6c498-1488">tempdb 要有足夠的可用空間，才能處理支援快照集隔離的版本存放區。</span><span class="sxs-lookup"><span data-stu-id="6c498-1488">There must be enough free space in tempdb to handle the version store that supports snapshot isolation.</span></span>  
  
 <span data-ttu-id="6c498-1489">下列公式提供版本存放區大小的概估。</span><span class="sxs-lookup"><span data-stu-id="6c498-1489">The following formula provides a rough estimate of the size of the version store.</span></span> <span data-ttu-id="6c498-1490">若為長時間執行的交易，則監視產生速率和清除速率以評估版本存放區的大小上限，可能會有幫助。</span><span class="sxs-lookup"><span data-stu-id="6c498-1490">For long-running transactions, it may be useful to monitor the generation and cleanup rate to estimate the maximum size of the version store.</span></span>  
  
 <span data-ttu-id="6c498-1491">[一般版本存放區的大小] = 2 \* [每分鐘產生的版本存放區資料] \* [交易的最長執行時間 (分鐘數)]</span><span class="sxs-lookup"><span data-stu-id="6c498-1491">[size of common version store] = 2 \* [version store data generated per minute] \* [longest running time (minutes) of the transaction]</span></span>  
  
 <span data-ttu-id="6c498-1492">交易的最長執行時間不應包括線上索引組建。</span><span class="sxs-lookup"><span data-stu-id="6c498-1492">The longest running time of transactions should not include online index builds.</span></span> <span data-ttu-id="6c498-1493">由於這些作業在非常大的資料表上會花很長的時間，線上索引組建會使用不同的版本存放區。</span><span class="sxs-lookup"><span data-stu-id="6c498-1493">Because these operations may take a long time on very large tables, online index builds use a separate version store.</span></span> <span data-ttu-id="6c498-1494">線上索引組建版本存放區的近似大小，等於啟動線上索引組建時資料表中修改的資料量，包括所有索引。</span><span class="sxs-lookup"><span data-stu-id="6c498-1494">The approximate size of the online index build version store equals the amount of data modified in the table, including all indexes, while the online index build is active.</span></span>  
  
 <span data-ttu-id="6c498-1495">**Version Store Size (KB)** 。</span><span class="sxs-lookup"><span data-stu-id="6c498-1495">**Version Store Size (KB)**.</span></span> <span data-ttu-id="6c498-1496">監視所有版本存放區的大小，以 KB 為單位。</span><span class="sxs-lookup"><span data-stu-id="6c498-1496">Monitors the size in KB of all version stores.</span></span> <span data-ttu-id="6c498-1497">此資訊有助於決定版本存放區的 tempdb 資料庫所需要的空間量。</span><span class="sxs-lookup"><span data-stu-id="6c498-1497">This information helps determine the amount of space needed in the tempdb database for the version store.</span></span> <span data-ttu-id="6c498-1498">持續監視這個計數器一段時間，可對 tempdb 所需的其他空間提供有用的評估。</span><span class="sxs-lookup"><span data-stu-id="6c498-1498">Monitoring this counter over a period of time provides a useful estimate of additional space needed for tempdb.</span></span>  
  
 <span data-ttu-id="6c498-1499">`Version Generation rate (KB/s)`.</span><span class="sxs-lookup"><span data-stu-id="6c498-1499">`Version Generation rate (KB/s)`.</span></span> <span data-ttu-id="6c498-1500">監視所有版本存放區的版本產生速率 (以每秒 KB 數為單位)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1500">Monitors the version generation rate in KB per second in all version stores.</span></span>  
  
 <span data-ttu-id="6c498-1501">`Version Cleanup rate (KB/s)`.</span><span class="sxs-lookup"><span data-stu-id="6c498-1501">`Version Cleanup rate (KB/s)`.</span></span> <span data-ttu-id="6c498-1502">監視所有版本存放區的版本清除速率 (以每秒 KB 數為單位)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1502">Monitors the version cleanup rate in KB per second in all version stores.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1503">Version Generation rate (KB/s) 和 Version Cleanup rate (KB/s) 的資訊可用來預測 tempdb 的空間需求。</span><span class="sxs-lookup"><span data-stu-id="6c498-1503">Information from Version Generation rate (KB/s) and Version Cleanup rate (KB/s) can be used to predict tempdb space requirements.</span></span>  
  
 <span data-ttu-id="6c498-1504">**Version Store unit count**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1504">**Version Store unit count**.</span></span> <span data-ttu-id="6c498-1505">監視版本存放區單元的計數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1505">Monitors the count of version store units.</span></span>  
  
 <span data-ttu-id="6c498-1506">**Version Store unit creation**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1506">**Version Store unit creation**.</span></span> <span data-ttu-id="6c498-1507">監視自執行個體啟動之後，為了儲存資料列版本而建立之版本存放區單元的總數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1507">Monitors the total number of version store units created to store row versions since the instance was started.</span></span>  
  
 <span data-ttu-id="6c498-1508">**Version Store unit truncation**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1508">**Version Store unit truncation**.</span></span> <span data-ttu-id="6c498-1509">監視自執行個體啟動之後，被截斷之版本存放區單元的總數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1509">Monitors the total number of version store units truncated since the instance was started.</span></span> <span data-ttu-id="6c498-1510">當 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 判斷執行使用中交易時不再需要版本存放區單元中所儲存的任何版本資料列時，就會截斷版本存放區單元。</span><span class="sxs-lookup"><span data-stu-id="6c498-1510">A version store unit is truncated when [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] determines that none of the version rows stored in the version store unit are needed to run active transactions.</span></span>  
  
 <span data-ttu-id="6c498-1511">**Update conflict ratio**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1511">**Update conflict ratio**.</span></span> <span data-ttu-id="6c498-1512">監視有更新衝突的更新快照集交易與更新快照集交易總數的比例。</span><span class="sxs-lookup"><span data-stu-id="6c498-1512">Monitors the ratio of update snapshot transaction that have update conflicts to the total number of update snapshot transactions.</span></span>  
  
 <span data-ttu-id="6c498-1513">**Longest Transaction Running Time**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1513">**Longest Transaction Running Time**.</span></span> <span data-ttu-id="6c498-1514">監視使用資料列版本設定的任何交易的最長執行時間，以秒數為單位。</span><span class="sxs-lookup"><span data-stu-id="6c498-1514">Monitors the longest running time in seconds of any transaction using row versioning.</span></span> <span data-ttu-id="6c498-1515">這可用來判斷是否有任何交易執行的時間量不合理。</span><span class="sxs-lookup"><span data-stu-id="6c498-1515">This can be used to determine if any transaction is running for an unreasonable amount of time.</span></span>  
  
 <span data-ttu-id="6c498-1516">**Transactions**。</span><span class="sxs-lookup"><span data-stu-id="6c498-1516">**Transactions**.</span></span> <span data-ttu-id="6c498-1517">監視使用中交易的總數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1517">Monitors the total number of active transactions.</span></span> <span data-ttu-id="6c498-1518">這不包括系統交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1518">This does not include system transactions.</span></span>  
  
 <span data-ttu-id="6c498-1519">`Snapshot Transactions`.</span><span class="sxs-lookup"><span data-stu-id="6c498-1519">`Snapshot Transactions`.</span></span> <span data-ttu-id="6c498-1520">監視使用中快照集交易的總數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1520">Monitors the total number of active snapshot transactions.</span></span>  
  
 <span data-ttu-id="6c498-1521">`Update Snapshot Transactions`.</span><span class="sxs-lookup"><span data-stu-id="6c498-1521">`Update Snapshot Transactions`.</span></span> <span data-ttu-id="6c498-1522">監視執行更新作業的使用中快照集交易的總數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1522">Monitors the total number of active snapshot transactions that perform update operations.</span></span>  
  
 <span data-ttu-id="6c498-1523">`NonSnapshot Version Transactions`.</span><span class="sxs-lookup"><span data-stu-id="6c498-1523">`NonSnapshot Version Transactions`.</span></span> <span data-ttu-id="6c498-1524">監視產生版本記錄的使用中非快照集交易的總數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1524">Monitors the total number of active non-snapshot transactions that generate version records.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1525">Update Snapshot Transactions 和 NonSnapshot Version Transactions 的總和代表參與版本產生的交易總數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1525">The sum of Update Snapshot Transactions and NonSnapshot Version Transactions represents the total number of transactions that participate in version generation.</span></span> <span data-ttu-id="6c498-1526">Snapshot Transactions 和 Update Snapshot Transactions 的差異可報告唯讀快照集交易的數目。</span><span class="sxs-lookup"><span data-stu-id="6c498-1526">The difference of Snapshot Transactions and Update Snapshot Transactions reports the number of read-only snapshot transactions.</span></span>  
  
### <a name="row-versioning-based-isolation-level-example"></a><span data-ttu-id="6c498-1527">資料列版本設定隔離等級範例</span><span class="sxs-lookup"><span data-stu-id="6c498-1527">Row Versioning-based Isolation Level Example</span></span>  

 <span data-ttu-id="6c498-1528">下列範例將示範快照隔離交易與使用資料列版本設定之讀取認可交易之間的行為差異。</span><span class="sxs-lookup"><span data-stu-id="6c498-1528">The following examples show the differences in behavior between snapshot isolation transactions and read-committed transactions that use row versioning.</span></span>  
  
#### <a name="a-working-with-snapshot-isolation"></a><span data-ttu-id="6c498-1529">A.</span><span class="sxs-lookup"><span data-stu-id="6c498-1529">A.</span></span> <span data-ttu-id="6c498-1530">示範快照隔離</span><span class="sxs-lookup"><span data-stu-id="6c498-1530">Working with snapshot isolation</span></span>  

 <span data-ttu-id="6c498-1531">此範例中，在快照隔離下執行的交易會讀取接著由另一個交易修改的資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1531">In this example, a transaction running under snapshot isolation reads data that is then modified by another transaction.</span></span> <span data-ttu-id="6c498-1532">快照交易不會封鎖另一個交易執行的更新作業，而會繼續從版本控制資料列中讀取資料，忽略資料的修改。</span><span class="sxs-lookup"><span data-stu-id="6c498-1532">The snapshot transaction does not block the update operation executed by the other transaction, and it continues to read data from the versioned row, ignoring the data modification.</span></span> <span data-ttu-id="6c498-1533">不過，當快照交易嘗試修改意見由另一個交易修改過的資料時，快照交易會產生錯誤且結束。</span><span class="sxs-lookup"><span data-stu-id="6c498-1533">However, when the snapshot transaction attempts to modify the data that has already been modified by the other transaction, the snapshot transaction generates an error and is terminated.</span></span>  
  
 <span data-ttu-id="6c498-1534">在工作階段 1 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1534">On session 1:</span></span>  
  
```sql  
USE AdventureWorks2012;  -- Or the 2008 or 2008R2 version of the AdventureWorks database.  
GO  
  
-- Enable snapshot isolation on the database.  
ALTER DATABASE AdventureWorks2012  
    SET ALLOW_SNAPSHOT_ISOLATION ON;  
GO  
  
-- Start a snapshot transaction  
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
GO  
  
BEGIN TRANSACTION;  
    -- This SELECT statement will return  
    -- 48 vacation hours for the employee.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="6c498-1535">在工作階段 2 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1535">On session 2:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
  
-- Start a transaction.  
BEGIN TRANSACTION;  
    -- Subtract a vacation day from employee 4.  
    -- Update is not blocked by session 1 since  
    -- under snapshot isolation shared locks are  
    -- not requested.  
    UPDATE HumanResources.Employee  
        SET VacationHours = VacationHours - 8  
        WHERE BusinessEntityID = 4;  
  
    -- Verify that the employee now has 40 vacation hours.  
    SELECT VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="6c498-1536">在工作階段 1 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1536">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this shows  
    -- the employee having 48 vacation hours.  The  
    -- snapshot transaction is still reading data from  
    -- the versioned row.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="6c498-1537">在工作階段 2 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1537">On session 2:</span></span>  
  
```sql  
-- Commit the transaction; this commits the data  
-- modification.  
COMMIT TRANSACTION;  
GO  
```  
  
 <span data-ttu-id="6c498-1538">在工作階段 1 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1538">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this still   
    -- shows the employee having 48 vacation hours  
    -- even after the other transaction has committed  
    -- the data modification.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
    -- Because the data has been modified outside of the  
    -- snapshot transaction, any further data changes to   
    -- that data by the snapshot transaction will cause   
    -- the snapshot transaction to fail. This statement   
    -- will generate a 3960 error and the transaction will   
    -- terminate.  
    UPDATE HumanResources.Employee  
        SET SickLeaveHours = SickLeaveHours - 8  
        WHERE BusinessEntityID = 4;  
  
-- Undo the changes to the database from session 1.   
-- This will not undo the change from session 2.  
ROLLBACK TRANSACTION  
GO  
```  
  
#### <a name="b-working-with-read-committed-using-row-versioning"></a><span data-ttu-id="6c498-1539">B.</span><span class="sxs-lookup"><span data-stu-id="6c498-1539">B.</span></span> <span data-ttu-id="6c498-1540">示範使用資料列版本設定的讀取認可</span><span class="sxs-lookup"><span data-stu-id="6c498-1540">Working with read-committed using row versioning</span></span>  

 <span data-ttu-id="6c498-1541">在此範例中，使用資料列版本設定的讀取認可交易與另一個交易同時執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1541">In this example, a read-committed transaction using row versioning runs concurrently with another transaction.</span></span> <span data-ttu-id="6c498-1542">讀取認可交易的運作方式和快照交易不同。</span><span class="sxs-lookup"><span data-stu-id="6c498-1542">The read-committed transaction behaves differently than a snapshot transaction.</span></span> <span data-ttu-id="6c498-1543">與快照交易類似的是，讀取認可交易即使在其他交易修改資料後還是會讀取版本控制資料列。</span><span class="sxs-lookup"><span data-stu-id="6c498-1543">Like a snapshot transaction, the read-committed transaction will read versioned rows even after the other transaction has modified data.</span></span> <span data-ttu-id="6c498-1544">不過，與快照交易不同的是，讀取認可交易將會：</span><span class="sxs-lookup"><span data-stu-id="6c498-1544">However, unlike a snapshot transaction, the read-committed transaction will:</span></span>  
  
-   <span data-ttu-id="6c498-1545">在其他交易認可資料變更後，會讀取已修改的資料</span><span class="sxs-lookup"><span data-stu-id="6c498-1545">Read the modified data after the other transaction commits the data changes.</span></span>  
  
-   <span data-ttu-id="6c498-1546">可以更新由其他交易修改的資料，但是快照交易無法做到。</span><span class="sxs-lookup"><span data-stu-id="6c498-1546">Be able to update the data modified by the other transaction where the snapshot transaction could not.</span></span>  
  
 <span data-ttu-id="6c498-1547">在工作階段 1 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1547">On session 1:</span></span>  
  
```sql  
USE AdventureWorks2012;  -- Or any earlier version of the AdventureWorks database.  
GO  
  
-- Enable READ_COMMITTED_SNAPSHOT on the database.  
-- For this statement to succeed, this session  
-- must be the only connection to the AdventureWorks2012  
-- database.  
ALTER DATABASE AdventureWorks2012  
    SET READ_COMMITTED_SNAPSHOT ON;  
GO  
  
-- Start a read-committed transaction  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
  
BEGIN TRANSACTION;  
    -- This SELECT statement will return  
    -- 48 vacation hours for the employee.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="6c498-1548">在工作階段 2 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1548">On session 2:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
  
-- Start a transaction.  
BEGIN TRANSACTION;  
    -- Subtract a vacation day from employee 4.  
    -- Update is not blocked by session 1 since  
    -- under read-committed using row versioning shared locks are  
    -- not requested.  
    UPDATE HumanResources.Employee  
        SET VacationHours = VacationHours - 8  
        WHERE BusinessEntityID = 4;  
  
    -- Verify that the employee now has 40 vacation hours.  
    SELECT VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="6c498-1549">在工作階段 1 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1549">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this still shows  
    -- the employee having 48 vacation hours.  The  
    -- read-committed transaction is still reading data   
    -- from the versioned row and the other transaction   
    -- has not committed the data changes yet.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="6c498-1550">在工作階段 2 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1550">On session 2:</span></span>  
  
```sql  
-- Commit the transaction.  
COMMIT TRANSACTION;  
GO  
  
```  
  
 <span data-ttu-id="6c498-1551">在工作階段 1 上：</span><span class="sxs-lookup"><span data-stu-id="6c498-1551">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement which now shows the   
    -- employee having 40 vacation hours.  Being   
    -- read-committed, this transaction is reading the   
    -- committed data. This is different from snapshot  
    -- isolation which reads from the versioned row.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
    -- This statement, which caused the snapshot transaction   
    -- to fail, will succeed with read-committed using row versioning.  
    UPDATE HumanResources.Employee  
        SET SickLeaveHours = SickLeaveHours - 8  
        WHERE BusinessEntityID = 4;  
  
-- Undo the changes to the database from session 1.   
-- This will not undo the change from session 2.  
ROLLBACK TRANSACTION;  
GO  
```  
  
### <a name="enabling-row-versioning-based-isolation-levels"></a><span data-ttu-id="6c498-1552">啟用資料列版本設定式的隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1552">Enabling Row Versioning-Based Isolation Levels</span></span>  

 <span data-ttu-id="6c498-1553">資料管理員可使用 ALTER DATABASE 陳述式中的 READ_COMMITTED_SNAPSHOT 與 ALLOW_SNAPSHOT_ISOLATION 資料庫選項，來控制資料列版本設定的資料庫層級設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1553">Database administrators control the database-level settings for row versioning by using the READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION database options in the ALTER DATABASE statement.</span></span>  
  
 <span data-ttu-id="6c498-1554">當 READ_COMMITTED_SNAPSHOT 資料庫選項設為 ON 時，就會立即啟動用來支援此選項的機制。</span><span class="sxs-lookup"><span data-stu-id="6c498-1554">When the READ_COMMITTED_SNAPSHOT database option is set ON, the mechanisms used to support the option are activated immediately.</span></span> <span data-ttu-id="6c498-1555">設定 READ_COMMITTED_SNAPSHOT 選項時，資料庫中只允許使用執行 ALTER DATABASE 命令的連接。</span><span class="sxs-lookup"><span data-stu-id="6c498-1555">When setting the READ_COMMITTED_SNAPSHOT option, only the connection executing the ALTER DATABASE command is allowed in the database.</span></span> <span data-ttu-id="6c498-1556">在 ALTER DATABASE 完成以前，資料庫中不可以有其他開啟的連接。</span><span class="sxs-lookup"><span data-stu-id="6c498-1556">There must be no other open connection in the database until ALTER DATABASE is complete.</span></span> <span data-ttu-id="6c498-1557">資料庫不一定要處於單一使用者模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1557">The database does not have to be in single-user mode.</span></span>  
  
 <span data-ttu-id="6c498-1558">下列 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式可啟用 READ_COMMITTED_SNAPSHOT：</span><span class="sxs-lookup"><span data-stu-id="6c498-1558">The following [!INCLUDE[tsql](../includes/tsql-md.md)] statement enables READ_COMMITTED_SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE AdventureWorks2012  
    SET READ_COMMITTED_SNAPSHOT ON;  
```  
  
 <span data-ttu-id="6c498-1559">當 ALLOW_SNAPSHOT_ISOLATION 資料庫選項設為 ON 時，在所有已於資料庫中修改資料的使用中交易完成之前， [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 的執行個體不會為已修改的資料產生資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1559">When the ALLOW_SNAPSHOT_ISOLATION database option is set ON, the instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] does not generate row versions for modified data until all active transactions that have modified data in the database complete.</span></span> <span data-ttu-id="6c498-1560">如果有使用中的修改交易， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 會將選項的狀態設為 PENDING_ON。</span><span class="sxs-lookup"><span data-stu-id="6c498-1560">If there are active modification transactions, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] sets the state of the option to PENDING_ON.</span></span> <span data-ttu-id="6c498-1561">在所有修改交易完成之後，選項的狀態會變更為 ON。</span><span class="sxs-lookup"><span data-stu-id="6c498-1561">After all of the modification transactions complete, the state of the option is changed to ON.</span></span> <span data-ttu-id="6c498-1562">在選項完全成為 ON 之前，使用者無法啟動該資料庫中的快照集交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1562">Users cannot start a snapshot transaction in that database until the option is fully ON.</span></span> <span data-ttu-id="6c498-1563">當資料庫管理員將 ALLOW_SNAPSHOT_ISOLATION 選項設為 OFF 時，資料庫會透過 PENDING_OFF 狀態傳送。</span><span class="sxs-lookup"><span data-stu-id="6c498-1563">The database passes through a PENDING_OFF state when the database administrator sets the ALLOW_SNAPSHOT_ISOLATION option to OFF.</span></span>  
  
 <span data-ttu-id="6c498-1564">下列 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式可啟用 ALLOW_SNAPSHOT_ISOLATION：</span><span class="sxs-lookup"><span data-stu-id="6c498-1564">The following [!INCLUDE[tsql](../includes/tsql-md.md)] statement will enable ALLOW_SNAPSHOT_ISOLATION:</span></span>  
  
```sql  
ALTER DATABASE AdventureWorks2012  
    SET ALLOW_SNAPSHOT_ISOLATION ON;  
```  
  
 <span data-ttu-id="6c498-1565">下表列出並說明 ALLOW_SNAPSHOT_ISOLATION 選項的狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-1565">The following table lists and describes the states of the ALLOW_SNAPSHOT_ISOLATION option.</span></span> <span data-ttu-id="6c498-1566">將 ALTER DATABASE 與 ALLOW_SNAPSHOT_ISOLATION 選項搭配使用，不會影響到目前存取資料庫資料的使用者。</span><span class="sxs-lookup"><span data-stu-id="6c498-1566">Using ALTER DATABASE with the ALLOW_SNAPSHOT_ISOLATION option does not block users who are currently accessing the database data.</span></span>  
  
|<span data-ttu-id="6c498-1567">現行資料庫的快照隔離架構狀態</span><span class="sxs-lookup"><span data-stu-id="6c498-1567">State of snapshot isolation framework for current database</span></span>|<span data-ttu-id="6c498-1568">描述</span><span class="sxs-lookup"><span data-stu-id="6c498-1568">Description</span></span>|  
|----------------------------------------------------------------|-----------------|  
|<span data-ttu-id="6c498-1569">OFF</span><span class="sxs-lookup"><span data-stu-id="6c498-1569">OFF</span></span>|<span data-ttu-id="6c498-1570">未啟動快照隔離交易的支援。</span><span class="sxs-lookup"><span data-stu-id="6c498-1570">The support for snapshot isolation transactions is not activated.</span></span> <span data-ttu-id="6c498-1571">不允許任何快照隔離交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1571">No snapshot isolation transactions are allowed.</span></span>|  
|<span data-ttu-id="6c498-1572">PENDING_ON</span><span class="sxs-lookup"><span data-stu-id="6c498-1572">PENDING_ON</span></span>|<span data-ttu-id="6c498-1573">快照隔離交易的支援處於轉換狀態 (從 OFF 到 ON)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1573">The support for snapshot isolation transactions is in transition state (from OFF to ON).</span></span> <span data-ttu-id="6c498-1574">開啟的交易必須完成。</span><span class="sxs-lookup"><span data-stu-id="6c498-1574">Open transactions must complete.</span></span><br /><br /> <span data-ttu-id="6c498-1575">不允許任何快照隔離交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1575">No snapshot isolation transactions are allowed.</span></span>|  
|<span data-ttu-id="6c498-1576">開啟</span><span class="sxs-lookup"><span data-stu-id="6c498-1576">ON</span></span>|<span data-ttu-id="6c498-1577">已啟動快照隔離交易的支援。</span><span class="sxs-lookup"><span data-stu-id="6c498-1577">The support for snapshot isolation transactions is activated.</span></span><br /><br /> <span data-ttu-id="6c498-1578">允許快照集交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1578">Snapshot transactions are allowed.</span></span>|  
|<span data-ttu-id="6c498-1579">PENDING_OFF</span><span class="sxs-lookup"><span data-stu-id="6c498-1579">PENDING_OFF</span></span>|<span data-ttu-id="6c498-1580">快照隔離交易的支援處於轉換狀態 (從 ON 到 OFF)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1580">The support for snapshot isolation transactions is in transition state (from ON to OFF).</span></span><br /><br /> <span data-ttu-id="6c498-1581">在此時間之後所啟動的快照集交易，無法存取此資料庫。</span><span class="sxs-lookup"><span data-stu-id="6c498-1581">Snapshot transactions started after this time cannot access this database.</span></span> <span data-ttu-id="6c498-1582">更新交易仍需花費成本進行此資料庫中的版本控制。</span><span class="sxs-lookup"><span data-stu-id="6c498-1582">Update transactions still pay the cost of versioning in this database.</span></span> <span data-ttu-id="6c498-1583">現有的快照集交易仍可存取此資料庫，而不會產生任何問題。</span><span class="sxs-lookup"><span data-stu-id="6c498-1583">Existing snapshot transactions can still access this database without a problem.</span></span> <span data-ttu-id="6c498-1584">必須等到所有在資料庫快照隔離狀態為 ON 時，且處於使用中的快照集交易完成之後，PENDING_OFF 狀態才會變成 OFF。</span><span class="sxs-lookup"><span data-stu-id="6c498-1584">The state PENDING_OFF does not become OFF until all snapshot transactions that were active when the database snapshot isolation state was ON finish.</span></span>|  
  
 <span data-ttu-id="6c498-1585">使用 sys.databases 目錄檢視，可判定兩個資料列版本設定資料庫選項的狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-1585">Use the sys.databases catalog view to determine the state of both row versioning database options.</span></span>  
  
 <span data-ttu-id="6c498-1586">對使用者資料表的所有更新，以及儲存在 master 與 msdb 中的一些系統資料表，都會產生資料列版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1586">All updates to user tables and some system tables stored in master and msdb generate row versions.</span></span>  
  
 <span data-ttu-id="6c498-1587">在 master 與 msdb 資料庫中會自動將 ALLOW_SNAPSHOT_ISOLATION 選項設為 ON，且無法停用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1587">The ALLOW_SNAPSHOT_ISOLATION option is automatically set ON in the master and msdb databases, and cannot be disabled.</span></span>  
  
 <span data-ttu-id="6c498-1588">使用者無法在 master、tempdb 或 msdb 中將 READ_COMMITTED_SNAPSHOT 選項設為 ON。</span><span class="sxs-lookup"><span data-stu-id="6c498-1588">Users cannot set the READ_COMMITTED_SNAPSHOT option ON in master, tempdb, or msdb.</span></span>  
  
### <a name="using-row-versioning-based-isolation-levels"></a><span data-ttu-id="6c498-1589">使用資料列版本設定式的隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1589">Using Row Versioning-based Isolation Levels</span></span>  

 <span data-ttu-id="6c498-1590">在 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中永遠會啟用資料列版本設定架構，並且有多個功能會使用此架構。</span><span class="sxs-lookup"><span data-stu-id="6c498-1590">The row versioning framework is always enabled in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], and is used by multiple features.</span></span> <span data-ttu-id="6c498-1591">除了提供資料列版本設定式的隔離等級之外，它也用來支援觸發程序中所做的修改以及 Multiple Active Result Set (MARS) 工作階段中所做的修改，還支援 ONLINE 索引作業的資料讀取。</span><span class="sxs-lookup"><span data-stu-id="6c498-1591">Besides providing row versioning-based isolation levels, it is used to support modifications made in triggers and multiple active result sets (MARS) sessions, and to support data reads for ONLINE index operations.</span></span>  
  
 <span data-ttu-id="6c498-1592">資料列版本設定式的隔離等級是在資料庫層級啟用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1592">Row versioning-based isolation levels are enabled at the database level.</span></span> <span data-ttu-id="6c498-1593">從已啟用之資料庫存取物件的應用程式，可以使用下列隔離等級執行查詢：</span><span class="sxs-lookup"><span data-stu-id="6c498-1593">Any application accessing objects from enabled databases can run queries using the following isolation levels:</span></span>  
  
-   <span data-ttu-id="6c498-1594">透過將 `READ_COMMITTED_SNAPSHOT` 資料庫選項設為 `ON` ，進而使用資料列版本設定的讀取認可，如下列程式碼範例所示：</span><span class="sxs-lookup"><span data-stu-id="6c498-1594">Read-committed that uses row versioning by setting the `READ_COMMITTED_SNAPSHOT` database option to `ON` as shown in the following code example:</span></span>  
  
    ```sql  
    ALTER DATABASE AdventureWorks2012  
        SET READ_COMMITTED_SNAPSHOT ON;  
    ```  
  
     <span data-ttu-id="6c498-1595">針對 READ_COMMITTED_SNAPSHOT 啟用資料庫時，在讀取認可隔離等級下執行的所有查詢都會使用資料列版本設定，這表示讀取作業不會封鎖更新作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1595">When the database is enabled for READ_COMMITTED_SNAPSHOT, all queries running under the read committed isolation level use row versioning, which means that read operations do not block update operations.</span></span>  
  
-   <span data-ttu-id="6c498-1596">將 `ALLOW_SNAPSHOT_ISOLATION` 資料庫選項設定為 `ON` 來隔離快照集，如下列程式碼範例所示：</span><span class="sxs-lookup"><span data-stu-id="6c498-1596">Snapshot isolation by setting the `ALLOW_SNAPSHOT_ISOLATION` database option to `ON` as shown in the following code example:</span></span>  
  
    ```sql  
    ALTER DATABASE AdventureWorks2012  
        SET ALLOW_SNAPSHOT_ISOLATION ON;  
    ```  
  
     <span data-ttu-id="6c498-1597">在快照隔離下執行的交易可以存取在資料庫中已針對快照啟用的資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1597">A transaction running under snapshot isolation can access tables in the database that have been enabled for snapshot.</span></span> <span data-ttu-id="6c498-1598">若要存取尚未針對快照啟用的資料表，您必須變更隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1598">To access tables that have not been enabled for snapshot, the isolation level must be changed.</span></span> <span data-ttu-id="6c498-1599">例如，下列程式碼範例會顯示 `SELECT` 陳述式，該陳述式會在執行快照集交易的同時聯結兩個資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1599">For example, the following code example shows a `SELECT` statement that joins two tables while running under a snapshot transaction.</span></span> <span data-ttu-id="6c498-1600">其中一個資料表屬於未啟用快照隔離的資料庫。</span><span class="sxs-lookup"><span data-stu-id="6c498-1600">One table belongs to a database in which snapshot isolation is not enabled.</span></span> <span data-ttu-id="6c498-1601">當 `SELECT` 陳述式在快照隔離下執行時，將無法順利執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1601">When the `SELECT` statement runs under snapshot isolation, it fails to execute successfully.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
    BEGIN TRAN  
        SELECT t1.col5, t2.col5  
            FROM Table1 as t1  
            INNER JOIN SecondDB.dbo.Table2 as t2  
                ON t1.col1 = t2.col2;  
    ```  
  
     <span data-ttu-id="6c498-1602">下列程式碼範例所示的是經過修改的同一個 `SELECT` 陳述式，可將交易隔離等級變更為讀取認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-1602">The following code example shows the same `SELECT` statement that has been modified to change the transaction isolation level to read-committed.</span></span> <span data-ttu-id="6c498-1603">由於此項變更，就可以順利執行 `SELECT` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1603">Because of this change, the `SELECT` statement executes successfully.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
    BEGIN TRAN  
        SELECT t1.col5, t2.col5  
            FROM Table1 as t1  
            WITH (READCOMMITTED)  
            INNER JOIN SecondDB.dbo.Table2 as t2  
                ON t1.col1 = t2.col2;  
    ```  
  
#### <a name="limitations-of-transactions-using-row-versioning-based-isolation-levels"></a><span data-ttu-id="6c498-1604">使用資料列版本設定式的隔離等級的交易限制</span><span class="sxs-lookup"><span data-stu-id="6c498-1604">Limitations of Transactions Using Row Versioning-based Isolation Levels</span></span>  

 <span data-ttu-id="6c498-1605">使用資料列版本設定式的隔離等級時，請考慮下列限制：</span><span class="sxs-lookup"><span data-stu-id="6c498-1605">Consider the following limitations when working with row versioning-based isolation levels:</span></span>  
  
-   <span data-ttu-id="6c498-1606">無法在 tempdb、msdb 或 master 中啟用 READ_COMMITTED_SNAPSHOT。</span><span class="sxs-lookup"><span data-stu-id="6c498-1606">READ_COMMITTED_SNAPSHOT cannot be enabled in tempdb, msdb, or master.</span></span>  
  
-   <span data-ttu-id="6c498-1607">全域暫存資料表會儲存在 tempdb 中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1607">Global temp tables are stored in tempdb.</span></span> <span data-ttu-id="6c498-1608">存取快照集交易內的全域暫存資料表時，必須符合下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="6c498-1608">When accessing global temp tables inside a snapshot transaction, one of the following must happen:</span></span>  
  
    -   <span data-ttu-id="6c498-1609">在 tempdb 中，將 ALLOW_SNAPSHOT_ISOLATION 資料庫選項設為 ON。</span><span class="sxs-lookup"><span data-stu-id="6c498-1609">Set the ALLOW_SNAPSHOT_ISOLATION database option ON in tempdb.</span></span>  
  
    -   <span data-ttu-id="6c498-1610">使用隔離提示來變更陳述式的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1610">Use an isolation hint to change the isolation level for the statement.</span></span>  
  
-   <span data-ttu-id="6c498-1611">發生下列情形時，快照集交易會失敗：</span><span class="sxs-lookup"><span data-stu-id="6c498-1611">Snapshot transactions fail when:</span></span>  
  
    -   <span data-ttu-id="6c498-1612">啟動快照集交易之後，且於快照集交易存取資料庫之前，資料庫都是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="6c498-1612">A database is made read-only after the snapshot transaction starts, but before the snapshot transaction accesses the database.</span></span>  
  
    -   <span data-ttu-id="6c498-1613">如果從多重資料庫存取物件，在快照集交易啟動之後，但在快照集交易存取資料庫之前，會以發生資料庫復原的方式變更資料庫狀態。</span><span class="sxs-lookup"><span data-stu-id="6c498-1613">If accessing objects from multiple databases, a database state was changed in such a way that database recovery occurred after a snapshot transaction starts, but before the snapshot transaction accesses the database.</span></span> <span data-ttu-id="6c498-1614">例如：資料庫設為 OFFLINE 然後設為 ONLINE、自動關閉及開啟資料庫，或者卸離和附加資料庫。</span><span class="sxs-lookup"><span data-stu-id="6c498-1614">For example: the database was set to OFFLINE and then to ONLINE, database autoclose and open, or database detach and attach.</span></span>  
  
-   <span data-ttu-id="6c498-1615">快照隔離中不支援分散式交易，包括在分散式資料分割資料庫中的查詢。</span><span class="sxs-lookup"><span data-stu-id="6c498-1615">Distributed transactions, including queries in distributed partitioned databases, are not supported under snapshot isolation.</span></span>  
  
-   [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="6c498-1616">不會保留多個版本的系統中繼資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1616">does not keep multiple versions of system metadata.</span></span> <span data-ttu-id="6c498-1617">資料表上的資料定義語言 (DDL) 陳述式和其他資料庫物件 (索引、檢視、資料類型、預存程序和 Common Language Runtime 函數) 會變更中繼資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1617">Data definition language (DDL) statements on tables and other database objects (indexes, views, data types, stored procedures, and common language runtime functions) change metadata.</span></span> <span data-ttu-id="6c498-1618">如果 DDL 陳述式修改了物件，則對快照隔離下的物件進行任何並行參考都會導致快照集交易失敗。</span><span class="sxs-lookup"><span data-stu-id="6c498-1618">If a DDL statement modifies an object, any concurrent reference to the object under snapshot isolation causes the snapshot transaction to fail.</span></span> <span data-ttu-id="6c498-1619">當 READ_COMMITTED_SNAPSHOT 資料庫選項為 ON 時，讀取認可交易就沒有這項限制。</span><span class="sxs-lookup"><span data-stu-id="6c498-1619">Read-committed transactions do not have this limitation when the READ_COMMITTED_SNAPSHOT database option is ON.</span></span>  
  
     <span data-ttu-id="6c498-1620">例如，資料庫管理員會執行下列 `ALTER INDEX` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1620">For example, a database administrator executes the following `ALTER INDEX` statement.</span></span>  
  
    ```sql  
    USE AdventureWorks2012;  
    GO  
    ALTER INDEX AK_Employee_LoginID  
        ON HumanResources.Employee REBUILD;  
    GO  
    ```  
  
     <span data-ttu-id="6c498-1621">執行 `ALTER INDEX` 陳述式時，任何使用中的快照集交易都會出現錯誤 (如果快照集交易嘗試在執行 `HumanResources.Employee` 陳述式之後參考 `ALTER INDEX` 資料表)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1621">Any snapshot transaction that is active when the `ALTER INDEX` statement is executed receives an error if it attempts to reference the `HumanResources.Employee` table after the `ALTER INDEX` statement is executed.</span></span> <span data-ttu-id="6c498-1622">使用資料列版本設定的讀取認可交易將不受影響。</span><span class="sxs-lookup"><span data-stu-id="6c498-1622">Read-committed transactions using row versioning are not affected.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="6c498-1623">BULK INSERT 作業可能會造成變更目標資料表中繼資料 (例如，停用條件約束檢查時)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1623">BULK INSERT operations may cause changes to target table metadata (for example, when disabling constraint checks).</span></span> <span data-ttu-id="6c498-1624">如果發生這種狀況，存取大量插入資料表的並行快照隔離交易會失敗。</span><span class="sxs-lookup"><span data-stu-id="6c498-1624">When this happens, concurrent snapshot isolation transactions accessing bulk inserted tables fail.</span></span>  
  
 <span data-ttu-id="6c498-1625">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="6c498-1625">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
## <a name="customizing-locking-and-row-versioning"></a><span data-ttu-id="6c498-1626">自訂鎖定及資料列版本設定</span><span class="sxs-lookup"><span data-stu-id="6c498-1626">Customizing Locking and Row Versioning</span></span>  
  
### <a name="customizing-the-lock-time-out"></a><span data-ttu-id="6c498-1627">自訂鎖定逾時</span><span class="sxs-lookup"><span data-stu-id="6c498-1627">Customizing the Lock Time-Out</span></span>  

 <span data-ttu-id="6c498-1628">如果當另一個交易已經擁有該資源的衝突鎖定使得 [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 執行個體無法將鎖定授與一個交易時，系統就會封鎖第一個交易，以等待現有的鎖定釋出。</span><span class="sxs-lookup"><span data-stu-id="6c498-1628">When an instance of the [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] cannot grant a lock to a transaction because another transaction already owns a conflicting lock on the resource, the first transaction becomes blocked waiting for the existing lock to be released.</span></span> <span data-ttu-id="6c498-1629">依預設，除非嘗試存取資料 (且可能會永遠被封鎖)，否則並沒有強制的逾時期限，且無法在鎖定資源之前測試資源是否已經鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1629">By default, there is no mandatory time-out period and no way to test whether a resource is locked before locking it, except to attempt to access the data (and potentially get blocked indefinitely).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1630">在 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 中，請使用 **sys.dm_os_waiting_tasks** 動態管理檢視來判斷處理序是否已被封鎖，以及其封鎖者是誰。</span><span class="sxs-lookup"><span data-stu-id="6c498-1630">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], use the **sys.dm_os_waiting_tasks** dynamic management view to determine whether a process is being blocked and who is blocking it.</span></span> <span data-ttu-id="6c498-1631">在舊版 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 中，請使用 **sp_who** 系統預存程序。</span><span class="sxs-lookup"><span data-stu-id="6c498-1631">In earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], use the **sp_who** system stored procedure.</span></span>  
  
 <span data-ttu-id="6c498-1632">LOCK_TIMEOUT 設定值可讓應用程式設定陳述式等待封鎖資源的時間上限。</span><span class="sxs-lookup"><span data-stu-id="6c498-1632">The LOCK_TIMEOUT setting allows an application to set a maximum time that a statement waits on a blocked resource.</span></span> <span data-ttu-id="6c498-1633">當陳述式等待的時間超過 LOCK_TIMEOUT 設定值時，會自動取消封鎖的陳述式，然後將錯誤訊息 1222 (`Lock request time-out period exceeded`) 傳回應用程式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1633">When a statement has waited longer than the LOCK_TIMEOUT setting, the blocked statement is canceled automatically, and error message 1222 (`Lock request time-out period exceeded`) is returned to the application.</span></span> <span data-ttu-id="6c498-1634">但 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]不會回復或取消包含此陳述式的任何交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1634">Any transaction containing the statement, however, is not rolled back or canceled by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6c498-1635">因此，應用程式必須具有能捕捉錯誤訊息 1222 的錯誤處理常式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1635">Therefore, the application must have an error handler that can trap error message 1222.</span></span> <span data-ttu-id="6c498-1636">如果應用程式沒有捕捉此錯誤，就會繼續進行而不知道交易中的個別陳述式已取消了，並且因為交易中後面的陳述式可能相依於這個從未執行過的陳述式，此時就會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="6c498-1636">If an application does not trap the error, the application can proceed unaware that an individual statement within a transaction has been canceled, and errors can occur because statements later in the transaction might depend on the statement that was never executed.</span></span>  
  
 <span data-ttu-id="6c498-1637">實作會捕捉錯誤訊息 1222 的錯誤處理常式，可讓應用程式處理逾時狀況並採取補救措施，例如自動重新送出先前被封鎖的陳述式，或是回復整筆交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1637">Implementing an error handler that traps error message 1222 allows an application to handle the time-out situation and take remedial action, such as: automatically resubmitting the statement that was blocked or rolling back the entire transaction.</span></span>  
  
 <span data-ttu-id="6c498-1638">若要判斷目前的 LOCK_TIMEOUT 設定，請執行 @ @LOCK_TIMEOUT function：</span><span class="sxs-lookup"><span data-stu-id="6c498-1638">To determine the current LOCK_TIMEOUT setting, execute the @@LOCK_TIMEOUT function:</span></span>  
  
```sql  
SELECT @@lock_timeout;  
GO  
```  
  
### <a name="customizing-transaction-isolation-level"></a><span data-ttu-id="6c498-1639">自訂交易隔離等級</span><span class="sxs-lookup"><span data-stu-id="6c498-1639">Customizing Transaction Isolation Level</span></span>  

 <span data-ttu-id="6c498-1640">READ COMMITTED 是 [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 的預設隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1640">READ COMMITTED is the default isolation level for the [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)].</span></span> <span data-ttu-id="6c498-1641">如果應用程式必須在不同隔離等級操作，可以使用下列方法來設定隔離等級：</span><span class="sxs-lookup"><span data-stu-id="6c498-1641">If an application must operate at a different isolation level, it can use the following methods to set the isolation level:</span></span>  
  
-   <span data-ttu-id="6c498-1642">執行 [SET TRANSACTION ISOLATION LEVEL](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql) 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1642">Run the [SET TRANSACTION ISOLATION LEVEL](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql) statement.</span></span>  
  
-   <span data-ttu-id="6c498-1643">使用 System.Data.SqlClient 受控命名空間的 ADO.NET 應用程式可以使用 SqlConnection.BeginTransaction 方法來指定 *IsolationLevel* 選項。</span><span class="sxs-lookup"><span data-stu-id="6c498-1643">ADO.NET applications that use the System.Data.SqlClient managed namespace can specify an *IsolationLevel* option by using the SqlConnection.BeginTransaction method.</span></span>  
  
-   <span data-ttu-id="6c498-1644">使用 ADO 的應用程式可以設定`Autocommit Isolation Levels`屬性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1644">Applications that use ADO can set the `Autocommit Isolation Levels` property.</span></span>  
  
-   <span data-ttu-id="6c498-1645">啟動交易時，使用 OLE DB 的應用程式可以將 *isoLevel* 設定為所需的交易隔離等級來呼叫 ITransactionLocal::StartTransaction。</span><span class="sxs-lookup"><span data-stu-id="6c498-1645">When starting a transaction, applications using OLE DB can call ITransactionLocal::StartTransaction with *isoLevel* set to the desired transaction isolation level.</span></span> <span data-ttu-id="6c498-1646">當在自動認可模式中指定隔離等級時，使用 OLE DB 的應用程式可以將 DBPROPSET_SESSION 屬性 DBPROP_SESS_AUTOCOMMITISOLEVELS 設為所要的交易隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1646">When specifying the isolation level in autocommit mode, applications that use OLE DB can set the DBPROPSET_SESSION property DBPROP_SESS_AUTOCOMMITISOLEVELS to the desired transaction isolation level.</span></span>  
  
-   <span data-ttu-id="6c498-1647">使用 ODBC 的應用程式可以使用 SQLSetConnectAttr 來設定 SQL_COPT_SS_TXN_ISOLATION 屬性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1647">Applications that use ODBC can set the SQL_COPT_SS_TXN_ISOLATION attribute by using SQLSetConnectAttr.</span></span>  
  
 <span data-ttu-id="6c498-1648">已指定隔離等級時，在 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 工作階段中，所有查詢和資料操作語言 (DML) 陳述式的鎖定行為都會在此隔離等級運作。</span><span class="sxs-lookup"><span data-stu-id="6c498-1648">When the isolation level is specified, the locking behavior for all queries and data manipulation language (DML) statements in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] session operates at that isolation level.</span></span> <span data-ttu-id="6c498-1649">此隔離等級會維持有效，直到工作階段結束或隔離等級設為另一個等級為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1649">The isolation level remains in effect until the session terminates or until the isolation level is set to another level.</span></span>  
  
 <span data-ttu-id="6c498-1650">下列範例會設定 `SERIALIZABLE` 隔離等級：</span><span class="sxs-lookup"><span data-stu-id="6c498-1650">The following example sets the `SERIALIZABLE` isolation level:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;  
GO  
BEGIN TRANSACTION;  
SELECT BusinessEntityID  
    FROM HumanResources.Employee;  
GO  
```  
  
 <span data-ttu-id="6c498-1651">如果有必要，藉由指定資料表層級的提示，可以覆寫個別查詢或 DML 陳述式的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1651">The isolation level can be overridden for individual query or DML statements, if necessary, by specifying a table-level hint.</span></span> <span data-ttu-id="6c498-1652">指定資料表層級的提示不會影響到工作階段的其他陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1652">Specifying a table-level hint does not affect other statements in the session.</span></span> <span data-ttu-id="6c498-1653">建議您只有在絕對必要時，才使用資料表層級的提示來變更預設的行為。</span><span class="sxs-lookup"><span data-stu-id="6c498-1653">We recommend that table-level hints be used to change the default behavior only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="6c498-1654">[!INCLUDE[ssDE](../includes/ssde-md.md)] 讀取中繼資料時可能必須取得鎖定，即使隔離等級設為讀取資料時不要求共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1654">The [!INCLUDE[ssDE](../includes/ssde-md.md)] might have to acquire locks when reading metadata even when the isolation level is set to a level where share locks are not requested when reading data.</span></span> <span data-ttu-id="6c498-1655">例如，在讀取未認可之隔離等級執行的交易，讀取資料時不會取得共用鎖定，但在讀取系統目錄檢視時，有時可能會要求鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1655">For example, a transaction running at the read-uncommitted isolation level does not acquire share locks when reading data, but might sometime request locks when reading a system catalog view.</span></span> <span data-ttu-id="6c498-1656">這表示，當並行交易正在修改資料表的中繼資料，而讀取未認可的交易同時查詢此資料表時，可能會造成鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1656">This means it is possible for a read uncommitted transaction to cause blocking when querying a table when a concurrent transaction is modifying the metadata of that table.</span></span>  
  
 <span data-ttu-id="6c498-1657">若要判斷目前設定的交易隔離等級，可使用下例所示的 `DBCC USEROPTIONS` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1657">To determine the transaction isolation level currently set, use the `DBCC USEROPTIONS` statement as shown in the following example.</span></span> <span data-ttu-id="6c498-1658">結果集和您系統上的結果集可能不盡相同。</span><span class="sxs-lookup"><span data-stu-id="6c498-1658">The result set may vary from the result set on your system.</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;  
GO  
DBCC USEROPTIONS;  
GO  
```  
  
 [!INCLUDE[ssResult](../includes/ssresult-md.md)]  
  
 `Set Option                   Value`  
  
 `---------------------------- -------------------------------------------`  
  
 `textsize                     2147483647`  
  
 `language                     us_english`  
  
 `dateformat                   mdy`  
  
 `datefirst                    7`  
  
 `...                          ...`  
  
 `Isolation level              repeatable read`  
  
 ``  
  
 `(14 row(s) affected)`  
  
 ``  
  
 `DBCC execution completed. If DBCC printed error messages, contact your system administrator.`  
  
### <a name="locking-hints"></a><span data-ttu-id="6c498-1659">鎖定提示</span><span class="sxs-lookup"><span data-stu-id="6c498-1659">Locking Hints</span></span>  

 <span data-ttu-id="6c498-1660">在 SELECT、INSERT、UPDATE 以及 DELETE 陳述式中的個別資料表參考可以指定鎖定提示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1660">Locking hints can be specified for individual table references in the SELECT, INSERT, UPDATE, and DELETE statements.</span></span> <span data-ttu-id="6c498-1661">此提示可指定鎖定的類型或是資料表資料所使用之 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 執行個體的資料列版本設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1661">The hints specify the type of locking or row versioning the instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses for the table data.</span></span> <span data-ttu-id="6c498-1662">需要取得物件的較細緻鎖定類型的控制時可以使用資料表層級的鎖定提示。</span><span class="sxs-lookup"><span data-stu-id="6c498-1662">Table-level locking hints can be used when a finer control of the types of locks acquired on an object is required.</span></span> <span data-ttu-id="6c498-1663">這些鎖定提示覆寫 (Override) 工作階段目前的交易隔離等級 (Isolation Level)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1663">These locking hints override the current transaction isolation level for the session.</span></span>  
  
 <span data-ttu-id="6c498-1664">如需有關特定鎖定提示及其行為的詳細資訊，請參閱[資料表提示 &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1664">For more information about the specific locking hints and their behaviors, see [Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1665">[!INCLUDE[ssDE](../includes/ssde-md.md)] 查詢最佳化工具幾乎永遠都會選擇正確的鎖定層級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1665">The [!INCLUDE[ssDE](../includes/ssde-md.md)] query optimizer almost always chooses the correct locking level.</span></span> <span data-ttu-id="6c498-1666">建議您只有在必要時才使用資料表層級的鎖定提示來變更預設的鎖定行為。</span><span class="sxs-lookup"><span data-stu-id="6c498-1666">We recommend that table-level locking hints be used to change the default locking behavior only when necessary.</span></span> <span data-ttu-id="6c498-1667">不允許鎖定層級可能會嚴重影響並行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1667">Disallowing a locking level can adversely affect concurrency.</span></span>  
  
 <span data-ttu-id="6c498-1668">[!INCLUDE[ssDE](../includes/ssde-md.md)] 在讀取中繼資料時可能必須取得鎖定，即使在處理具有鎖定提示的選取，而該鎖定是防止讀取資料時要求共用鎖定時也是如此。</span><span class="sxs-lookup"><span data-stu-id="6c498-1668">The [!INCLUDE[ssDE](../includes/ssde-md.md)] might have to acquire locks when reading metadata, even when processing a select with a locking hint that prevents requests for share locks when reading data.</span></span> <span data-ttu-id="6c498-1669">例如，使用 NOLOCK 提示的 SELECT 在讀取資料時並不會取得共用鎖定，但有時在讀取系統目錄檢視時會要求鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1669">For example, a SELECT using the NOLOCK hint does not acquire share locks when reading data, but might sometime request locks when reading a system catalog view.</span></span> <span data-ttu-id="6c498-1670">這表示使用 NOLOCK 的 SELECT 陳述式有可能遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="6c498-1670">This means it is possible for a SELECT statement using NOLOCK to be blocked.</span></span>  
  
 <span data-ttu-id="6c498-1671">如下列範例所顯示，如果交易隔離等級設定為 `SERIALIZABLE`，並使用 `NOLOCK` 陳述式來指定資料表層級的鎖定提示 `SELECT` ，則就不採用通常用來維護序列化交易的索引鍵範圍鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1671">As shown in the following example, if the transaction isolation level is set to `SERIALIZABLE`, and the table-level locking hint `NOLOCK` is used with the `SELECT` statement, key-range locks typically used to maintain serializable transactions are not taken.</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;  
GO  
BEGIN TRANSACTION;  
GO  
SELECT JobTitle  
    FROM HumanResources.Employee WITH (NOLOCK);  
GO  
  
-- Get information about the locks held by   
-- the transaction.  
SELECT    
        resource_type,   
        resource_subtype,   
        request_mode  
    FROM sys.dm_tran_locks  
    WHERE request_session_id = @@spid;  
  
-- End the transaction.  
ROLLBACK;  
GO  
```  
  
 <span data-ttu-id="6c498-1672">所採用的鎖定中，唯一參考 `HumanResources.Employee` 的鎖定為結構描述穩定性 (Sch-S) 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1672">The only lock taken that references `HumanResources.Employee` is a schema stability (Sch-S) lock.</span></span> <span data-ttu-id="6c498-1673">這種情況下不保證有序列化能力。</span><span class="sxs-lookup"><span data-stu-id="6c498-1673">In this case, serializability is no longer guaranteed.</span></span>  
  
 <span data-ttu-id="6c498-1674">在 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]中，ALTER TABLE 的 LOCK_ESCALATION 選項可能會不喜歡資料表鎖定，並啟用資料分割資料表上的 HoBT 鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1674">In [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)], the LOCK_ESCALATION option of ALTER TABLE can disfavor table locks, and enable HoBT locks on partitioned tables.</span></span> <span data-ttu-id="6c498-1675">這個選項不是鎖定提示，但是可用來減少鎖定擴大。</span><span class="sxs-lookup"><span data-stu-id="6c498-1675">This option is not a locking hint, but can but used to reduce lock escalation.</span></span> <span data-ttu-id="6c498-1676">如需詳細資訊，請參閱 [ALTER TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1676">For more information, see [ALTER TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
###  <a name="customizing-locking-for-an-index"></a><a name="Customize"></a> <span data-ttu-id="6c498-1677">自訂索引的鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-1677">Customizing Locking for an Index</span></span>  

 <span data-ttu-id="6c498-1678">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 的動態鎖定策略在大部分的情況下都會自動為查詢選擇最佳的鎖定資料粒度。</span><span class="sxs-lookup"><span data-stu-id="6c498-1678">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses a dynamic locking strategy that automatically chooses the best locking granularity for queries in most cases.</span></span> <span data-ttu-id="6c498-1679">除非資料表或索引存取模式都容易理解且維持一致，而且存在待解決的資源競爭問題，否則我們建議您不要覆寫預設鎖定層級 (開啟頁面和資料列鎖定)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1679">We recommend that you do not override the default locking levels, which have page and row locking on, unless table or index access patterns are well understood and consistent, and there is a resource contention problem to solve.</span></span> <span data-ttu-id="6c498-1680">覆寫鎖定層級可能會嚴重妨礙資料表或索引的並行存取。</span><span class="sxs-lookup"><span data-stu-id="6c498-1680">Overriding a locking level can significantly impede concurrent access to a table or index.</span></span> <span data-ttu-id="6c498-1681">例如，針對使用者經常存取的大型資料表指定僅限資料表層級鎖定可能會導致效能瓶頸，因為使用者必須等候資料表層級鎖定釋放，才能存取資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1681">For example, specifying only table-level locks on a large table that users access heavily can cause bottlenecks because users must wait for the table-level lock to be released before accessing the table.</span></span>  
  
 <span data-ttu-id="6c498-1682">如果存取模式容易理解且維持一致，在少數情況下，不允許頁面或資料列鎖定可能會很有用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1682">There are a few cases where disallowing page or row locking can be beneficial, if the access patterns are well understood and consistent.</span></span> <span data-ttu-id="6c498-1683">例如，資料庫應用程式使用的查閱資料表以批次處理序每週更新一次。</span><span class="sxs-lookup"><span data-stu-id="6c498-1683">For example, a database application uses a lookup table that is updated weekly in a batch process.</span></span> <span data-ttu-id="6c498-1684">並行讀取器會存取具有共用 (S) 鎖定的資料表，而且每週批次更新會存取具有獨佔 (X) 鎖定的資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1684">Concurrent readers access the table with a shared (S) lock and the weekly batch update accesses the table with an exclusive (X) lock.</span></span> <span data-ttu-id="6c498-1685">針對資料表關閉頁面和資料列鎖定會允許讀取器透過共用資料表鎖定以並行方式存取資料表，藉以減少整週的鎖定額外負荷。</span><span class="sxs-lookup"><span data-stu-id="6c498-1685">Turning off page and row locking on the table reduces the locking overhead throughout the week by allowing readers to concurrently access the table through shared table locks.</span></span> <span data-ttu-id="6c498-1686">當批次作業執行時，它就可以有效率地完成更新，因為它會取得獨佔資料表鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1686">When the batch job runs, it can complete the update efficiently because it obtains an exclusive table lock.</span></span>  
  
 <span data-ttu-id="6c498-1687">關閉頁面和資料列鎖定不一定是可接受的作法，因為每週批次更新將會封鎖並行讀取器，使其無法在更新執行時存取資料表。</span><span class="sxs-lookup"><span data-stu-id="6c498-1687">Turning off page and row locking might or might not be acceptable because the weekly batch update will block the concurrent readers from accessing the table while the update runs.</span></span> <span data-ttu-id="6c498-1688">如果批次作業只變更少數資料列或頁面，您就可以變更鎖定層級來允許資料列或頁面層級鎖定，進而讓其他工作階段讀取資料表而不封鎖。</span><span class="sxs-lookup"><span data-stu-id="6c498-1688">If the batch job only changes a few rows or pages, you can change the locking level to allow row or page level locking, which will enable other sessions to read from the table without blocking.</span></span> <span data-ttu-id="6c498-1689">如果批次作業具有大量更新，取得資料表的獨佔鎖定可能是確保批次作業有效完成的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1689">If the batch job has a large number of updates, obtaining an exclusive lock on the table may be the best way to ensure the batch job finishes efficiently.</span></span>  
  
 <span data-ttu-id="6c498-1690">有時候，當兩個並行作業取得同一份資料表的資料列鎖定，然後封鎖時，就會發生死結，因為它們都需要鎖定頁面。</span><span class="sxs-lookup"><span data-stu-id="6c498-1690">Occasionally a deadlock occurs when two concurrent operations acquire row locks on the same table and then block because they both need to lock the page.</span></span> <span data-ttu-id="6c498-1691">不允許資料列鎖定會強制其中一項作業等候，避免發生死結。</span><span class="sxs-lookup"><span data-stu-id="6c498-1691">Disallowing row locks forces one of the operations to wait, avoiding the deadlock.</span></span>  
  
 <span data-ttu-id="6c498-1692">用於索引的鎖定資料粒度可以使用 CREATE INDEX 和 ALTER INDEX 陳述式來設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1692">The granularity of locking used on an index can be set using the CREATE INDEX and ALTER INDEX statements.</span></span> <span data-ttu-id="6c498-1693">這個鎖定設定會同時套用至索引頁面和資料表頁面。</span><span class="sxs-lookup"><span data-stu-id="6c498-1693">The lock settings apply to both the index pages and the table pages.</span></span> <span data-ttu-id="6c498-1694">此外，您可以使用 CREATE TABLE 和 ALTER TABLE 陳述式來設定 PRIMARY KEY 和 UNIQUE 條件約束的鎖定資料粒度。</span><span class="sxs-lookup"><span data-stu-id="6c498-1694">In addition, the CREATE TABLE and ALTER TABLE statements can be used to set locking granularity on PRIMARY KEY and UNIQUE constraints.</span></span> <span data-ttu-id="6c498-1695">基於回溯相容性， **sp_indexoption** 系統預存程序也可以設定資料粒度。</span><span class="sxs-lookup"><span data-stu-id="6c498-1695">For backwards compatibility, the **sp_indexoption** system stored procedure can also set the granularity.</span></span> <span data-ttu-id="6c498-1696">若要顯示針對給定索引目前鎖定的選項，請使用 INDEXPROPERTY 函數。</span><span class="sxs-lookup"><span data-stu-id="6c498-1696">To display the current locking option for a given index, use the INDEXPROPERTY function.</span></span> <span data-ttu-id="6c498-1697">分頁層級鎖定、資料列層級鎖定、或是分頁層級與資料列層級鎖定的組合可不允許特定索引採用。</span><span class="sxs-lookup"><span data-stu-id="6c498-1697">Page-level locks, row-level locks, or a combination of page-level and row-level locks can be disallowed for a given index.</span></span>  
  
|<span data-ttu-id="6c498-1698">不允許的鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-1698">Disallowed locks</span></span>|<span data-ttu-id="6c498-1699">存取索引者</span><span class="sxs-lookup"><span data-stu-id="6c498-1699">Index accessed by</span></span>|  
|----------------------|-----------------------|  
|<span data-ttu-id="6c498-1700">分頁層級</span><span class="sxs-lookup"><span data-stu-id="6c498-1700">Page level</span></span>|<span data-ttu-id="6c498-1701">資料列層級與資料表層級鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-1701">Row-level and table-level locks</span></span>|  
|<span data-ttu-id="6c498-1702">資料列層級</span><span class="sxs-lookup"><span data-stu-id="6c498-1702">Row level</span></span>|<span data-ttu-id="6c498-1703">分頁層級與資料表層級鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-1703">Page-level and table-level locks</span></span>|  
|<span data-ttu-id="6c498-1704">分頁層級與資料列層級</span><span class="sxs-lookup"><span data-stu-id="6c498-1704">Page level and row level</span></span>|<span data-ttu-id="6c498-1705">資料表層級鎖定</span><span class="sxs-lookup"><span data-stu-id="6c498-1705">Table-level locks</span></span>|  
  
 <span data-ttu-id="6c498-1706">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="6c498-1706">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="advanced-transaction-information"></a><a name="Advanced"></a> <span data-ttu-id="6c498-1707">進階交易資訊</span><span class="sxs-lookup"><span data-stu-id="6c498-1707">Advanced Transaction Information</span></span>  
  
### <a name="nesting-transactions"></a><span data-ttu-id="6c498-1708">巢狀交易</span><span class="sxs-lookup"><span data-stu-id="6c498-1708">Nesting Transactions</span></span>  

 <span data-ttu-id="6c498-1709">外顯交易可以是巢狀的。</span><span class="sxs-lookup"><span data-stu-id="6c498-1709">Explicit transactions can be nested.</span></span> <span data-ttu-id="6c498-1710">其主要目的是要支援預存程序中的交易，讓交易可以被已經在交易中的處理序呼叫，或沒有動作的交易內的處理序呼叫。</span><span class="sxs-lookup"><span data-stu-id="6c498-1710">This is primarily intended to support transactions in stored procedures that can be called either from a process already in a transaction or from processes that have no active transaction.</span></span>  
  
 <span data-ttu-id="6c498-1711">下列範例顯示巢狀交易的使用意圖。</span><span class="sxs-lookup"><span data-stu-id="6c498-1711">The following example shows the intended use of nested transactions.</span></span> <span data-ttu-id="6c498-1712">`TransProc` 程序會強制執行其交易，而不論執行此程序之處理序的交易模式為何。</span><span class="sxs-lookup"><span data-stu-id="6c498-1712">The procedure `TransProc` enforces its transaction regardless of the transaction mode of any process that executes it.</span></span> <span data-ttu-id="6c498-1713">如果是在交易使用中時呼叫 `TransProc` ，在 `TransProc` 中的巢狀交易大部份會被忽略，並且依照外部交易最後執行的動作，來認可或回復其中的 INSERT 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1713">If `TransProc` is called when a transaction is active, the nested transaction in `TransProc` is largely ignored, and its INSERT statements are committed or rolled back based on the final action taken for the outer transaction.</span></span> <span data-ttu-id="6c498-1714">如果執行 `TransProc` 的處理序沒有尚未處理的交易，在程序結尾的 COMMIT TRANSACTION 便會有效地認可 INSERT 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1714">If `TransProc` is executed by a process that does not have an outstanding transaction, the COMMIT TRANSACTION at the end of the procedure effectively commits the INSERT statements.</span></span>  
  
```sql  
SET QUOTED_IDENTIFIER OFF;  
GO  
SET NOCOUNT OFF;  
GO  
CREATE TABLE TestTrans(Cola INT PRIMARY KEY,  
               Colb CHAR(3) NOT NULL);  
GO  
CREATE PROCEDURE TransProc @PriKey INT, @CharCol CHAR(3) AS  
BEGIN TRANSACTION InProc  
INSERT INTO TestTrans VALUES (@PriKey, @CharCol)  
INSERT INTO TestTrans VALUES (@PriKey + 1, @CharCol)  
COMMIT TRANSACTION InProc;  
GO  
/* Start a transaction and execute TransProc. */  
BEGIN TRANSACTION OutOfProc;  
GO  
EXEC TransProc 1, 'aaa';  
GO  
/* Roll back the outer transaction, this will  
   roll back TransProc's nested transaction. */  
ROLLBACK TRANSACTION OutOfProc;  
GO  
EXECUTE TransProc 3,'bbb';  
GO  
/* The following SELECT statement shows only rows 3 and 4 are   
   still in the table. This indicates that the commit  
   of the inner transaction from the first EXECUTE statement of  
   TransProc was overridden by the subsequent rollback. */  
SELECT * FROM TestTrans;  
GO  
```  
  
 <span data-ttu-id="6c498-1715">「 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]」會忽略認可內部交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1715">Committing inner transactions is ignored by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)].</span></span> <span data-ttu-id="6c498-1716">交易的認可或復原是依照最外層的交易在最後所執行的動作而定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1716">The transaction is either committed or rolled back based on the action taken at the end of the outermost transaction.</span></span> <span data-ttu-id="6c498-1717">若是認可外部交易，則內部的巢狀交易也會被認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-1717">If the outer transaction is committed, the inner nested transactions are also committed.</span></span> <span data-ttu-id="6c498-1718">若是復原外部交易，便會復原所有的內部交易，而不論內部交易是否個別被認可。</span><span class="sxs-lookup"><span data-stu-id="6c498-1718">If the outer transaction is rolled back, then all inner transactions are also rolled back, regardless of whether or not the inner transactions were individually committed.</span></span>  
  
 <span data-ttu-id="6c498-1719">每個對於 COMMIT TRANSACTION 或 COMMIT WORK 的呼叫，皆套用於最後執行的 BEGIN TRANSACTION。</span><span class="sxs-lookup"><span data-stu-id="6c498-1719">Each call to COMMIT TRANSACTION or COMMIT WORK applies to the last executed BEGIN TRANSACTION.</span></span> <span data-ttu-id="6c498-1720">如果 BEGIN TRANSACTION 陳述式是巢狀的，COMMIT 陳述式便僅套用於最後的巢狀交易，亦即最內層的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1720">If the BEGIN TRANSACTION statements are nested, then a COMMIT statement applies only to the last nested transaction, which is the innermost transaction.</span></span> <span data-ttu-id="6c498-1721">即使位於巢狀交易中的 COMMIT TRANSACTION *transaction_name* 陳述式參考的是外部交易的交易名稱，還是只會認可最內層的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1721">Even if a COMMIT TRANSACTION *transaction_name* statement within a nested transaction refers to the transaction name of the outer transaction, the commit applies only to the innermost transaction.</span></span>  
  
 <span data-ttu-id="6c498-1722">ROLLBACK TRANSACTION 陳述式的 *transaction_name* 參數參考一組具名巢狀交易的內部交易是不合法的。</span><span class="sxs-lookup"><span data-stu-id="6c498-1722">It is not legal for the *transaction_name* parameter of a ROLLBACK TRANSACTION statement to refer to the inner transactions of a set of named nested transactions.</span></span> <span data-ttu-id="6c498-1723">*transaction_name* 只能參考最外層交易的交易名稱。</span><span class="sxs-lookup"><span data-stu-id="6c498-1723">*transaction_name* can refer only to the transaction name of the outermost transaction.</span></span> <span data-ttu-id="6c498-1724">如果使用外部交易名稱的 ROLLBACK TRANSACTION *transaction_name* 陳述式，是在一組巢狀交易的任何層級執行，將會回復所有的巢狀交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1724">If a ROLLBACK TRANSACTION *transaction_name* statement using the name of the outer transaction is executed at any level of a set of nested transactions, all of the nested transactions are rolled back.</span></span> <span data-ttu-id="6c498-1725">如果在一組巢狀交易的任何層級執行不包含 *transaction_name* 參數的 ROLLBACK WORK 或 ROLLBACK TRANSACTION 陳述式，它會回復所有巢狀交易，包括最外層的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1725">If a ROLLBACK WORK or ROLLBACK TRANSACTION statement without a *transaction_name* parameter is executed at any level of a set of nested transaction, it rolls back all of the nested transactions, including the outermost transaction.</span></span>  
  
 <span data-ttu-id="6c498-1726">@ @TRANCOUNT 函數會記錄目前的交易嵌套層級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1726">The @@TRANCOUNT function records the current transaction nesting level.</span></span> <span data-ttu-id="6c498-1727">每個 BEGIN TRANSACTION 語句會遞增 @ @TRANCOUNT 一。</span><span class="sxs-lookup"><span data-stu-id="6c498-1727">Each BEGIN TRANSACTION statement increments @@TRANCOUNT by one.</span></span> <span data-ttu-id="6c498-1728">每個 COMMIT TRANSACTION 或 COMMIT WORK 語句會將 @ 減 @TRANCOUNT 一。</span><span class="sxs-lookup"><span data-stu-id="6c498-1728">Each COMMIT TRANSACTION or COMMIT WORK statement decrements @@TRANCOUNT by one.</span></span> <span data-ttu-id="6c498-1729">沒有交易名稱的 ROLLBACK WORK 或 ROLLBACK TRANSACTION 語句會回復所有的嵌套交易，並將 @ 遞減 @TRANCOUNT 為0。</span><span class="sxs-lookup"><span data-stu-id="6c498-1729">A ROLLBACK WORK or a ROLLBACK TRANSACTION statement that does not have a transaction name rolls back all nested transactions and decrements @@TRANCOUNT to 0.</span></span> <span data-ttu-id="6c498-1730">在一組嵌套交易中使用最外層交易的交易名稱的 ROLLBACK TRANSACTION 會回復所有的嵌套交易，並將 @ 遞減 @TRANCOUNT 為0。</span><span class="sxs-lookup"><span data-stu-id="6c498-1730">A ROLLBACK TRANSACTION that uses the transaction name of the outermost transaction in a set of nested transactions rolls back all of the nested transactions and decrements @@TRANCOUNT to 0.</span></span> <span data-ttu-id="6c498-1731">當您不確定是否已經在交易中時，請選取 @ @TRANCOUNT 來判斷它是1或多個。</span><span class="sxs-lookup"><span data-stu-id="6c498-1731">When you are unsure if you are already in a transaction, SELECT @@TRANCOUNT to determine if it is 1 or more.</span></span> <span data-ttu-id="6c498-1732">如果 @ @TRANCOUNT 為0，您就不在交易中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1732">If @@TRANCOUNT is 0, you are not in a transaction.</span></span>  
  
### <a name="using-bound-sessions"></a><span data-ttu-id="6c498-1733">使用繫結工作階段</span><span class="sxs-lookup"><span data-stu-id="6c498-1733">Using Bound Sessions</span></span>  

 <span data-ttu-id="6c498-1734">繫結工作階段可簡化相同伺服器上多個工作階段之間動作的協調作業。</span><span class="sxs-lookup"><span data-stu-id="6c498-1734">Bound sessions ease the coordination of actions across multiple sessions on the same server.</span></span> <span data-ttu-id="6c498-1735">繫結工作階段允許兩個以上的工作階段共用相同的交易和鎖定，並且可以使用相同的資料，而不會發生鎖定衝突。</span><span class="sxs-lookup"><span data-stu-id="6c498-1735">Bound sessions allow two or more sessions to share the same transaction and locks, and can work on the same data without lock conflicts.</span></span> <span data-ttu-id="6c498-1736">繫結工作階段可以從同一個應用程式中的多個工作階段來建立，也可以從擁有個別工作階段的多個應用程式來建立。</span><span class="sxs-lookup"><span data-stu-id="6c498-1736">Bound sessions can be created from multiple sessions within the same application or from multiple applications with separate sessions.</span></span>  
  
 <span data-ttu-id="6c498-1737">若要參與繫結工作階段，工作階段需呼叫 **sp_getbindtoken** 或 **srv_getbindtoken** (透過「開放式資料服務」) 來取得繫結 Token。</span><span class="sxs-lookup"><span data-stu-id="6c498-1737">To participate in a bound session, a session calls **sp_getbindtoken** or **srv_getbindtoken** (through Open Data Services) to get a bind token.</span></span> <span data-ttu-id="6c498-1738">繫結 Token 是唯一識別每筆繫結交易的字元字串。</span><span class="sxs-lookup"><span data-stu-id="6c498-1738">A bind token is a character string that uniquely identifies each bound transaction.</span></span> <span data-ttu-id="6c498-1739">然後再將繫結 Token 傳送給其他工作階段，以便與目前的工作階段繫結。</span><span class="sxs-lookup"><span data-stu-id="6c498-1739">The bind token is then sent to the other sessions to be bound with the current session.</span></span> <span data-ttu-id="6c498-1740">其他工作階段藉由呼叫 **sp_bindsession**，並使用從第一個工作階段接收到的繫結 Token，來繫結到交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1740">The other sessions bind to the transaction by calling **sp_bindsession**, using the bind token received from the first session.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c498-1741">工作階段必須有使用中的使用者交易， **sp_getbindtoken** 或 **srv_getbindtoken** 才會成功。</span><span class="sxs-lookup"><span data-stu-id="6c498-1741">A session must have an active user transaction in order for **sp_getbindtoken** or **srv_getbindtoken** to succeed.</span></span>  
  
 <span data-ttu-id="6c498-1742">繫結 Token 必須從建立第一個工作階段的應用程式程式碼，傳送給其他應用程式程式碼，以供後續的應用程式將其工作階段繫結至第一個工作階段。</span><span class="sxs-lookup"><span data-stu-id="6c498-1742">Bind tokens must be transmitted from the application code that makes the first session to the application code that subsequently binds their sessions to the first session.</span></span> <span data-ttu-id="6c498-1743">應用程式無法使用 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式或 API 函數，來取得另一個處理序所啟動之交易的繫結 Token。</span><span class="sxs-lookup"><span data-stu-id="6c498-1743">There is no [!INCLUDE[tsql](../includes/tsql-md.md)] statement or API function that an application can use to get the bind token for a transaction started by another process.</span></span> <span data-ttu-id="6c498-1744">可用來傳送繫結 Token 的部分方法如下：</span><span class="sxs-lookup"><span data-stu-id="6c498-1744">Some of the methods that can be used to transmit a bind token include the following:</span></span>  
  
-   <span data-ttu-id="6c498-1745">如果工作階段全部都是由相同的應用程式處理序來初始化，則繫結 Token 可以儲存在全域記憶體，或是作為參數傳遞至函數中。</span><span class="sxs-lookup"><span data-stu-id="6c498-1745">If the sessions are all initiated from the same application process, bind tokens can be stored in global memory or passed into functions as a parameter.</span></span>  
  
-   <span data-ttu-id="6c498-1746">如果工作階段是由個別的應用程式處理序建立，則可使用處理序間通訊 (IPC) 來傳送繫結 Token，例如遠端程序呼叫 (RPC) 或動態資料交換 (DDE)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1746">If the sessions are made from separate application processes, bind tokens can be transmitted using interprocess communication (IPC), such as a remote procedure call (RPC) or dynamic data exchange (DDE).</span></span>  
  
-   <span data-ttu-id="6c498-1747">繫結 Token 可以儲存在 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 執行個體的資料表中，而這個資料表可由要繫結至第一個工作階段的處理序所讀取。</span><span class="sxs-lookup"><span data-stu-id="6c498-1747">Bind tokens can be stored in a table in an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] that can be read by processes wanting to bind to the first session.</span></span>  
  
 <span data-ttu-id="6c498-1748">在一組繫結工作階段中，任何時間只能有一個使用中的工作階段。</span><span class="sxs-lookup"><span data-stu-id="6c498-1748">Only one session in a set of bound sessions can be active at any time.</span></span> <span data-ttu-id="6c498-1749">如果某個工作階段正在執行個體上執行陳述式或等待執行個體的暫止結果，則繫結至此工作階段的其他工作階段都無法存取執行個體，直到目前工作階段完成處理或取消目前陳述式為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1749">If one session is executing a statement on the instance or has results pending from the instance, no other session bound to it can access the instance until the current session finishes processing or cancels the current statement.</span></span> <span data-ttu-id="6c498-1750">如果執行個體忙著處理來自另一個繫結工作階段的陳述式，則會發生錯誤，指出交易空間正在使用中，工作階段應稍後重試。</span><span class="sxs-lookup"><span data-stu-id="6c498-1750">If the instance is busy processing a statement from another of the bound sessions, an error occurs indicating that the transaction space is in use and the session should retry later.</span></span>  
  
 <span data-ttu-id="6c498-1751">當您繫結工作階段時，每個工作階段都會保留其隔離等級設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1751">When you bind sessions, each session retains its isolation level setting.</span></span> <span data-ttu-id="6c498-1752">使用 SET TRANSACTION ISOLATION LEVEL 來變更一個工作階段的隔離等級設定，並不會影響與它繫結的任何其他工作階段的設定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1752">Using SET TRANSACTION ISOLATION LEVEL to change the isolation level setting of one session does not affect the setting of any other session bound to it.</span></span>  
  
#### <a name="types-of-bound-sessions"></a><span data-ttu-id="6c498-1753">繫結工作階段的類型</span><span class="sxs-lookup"><span data-stu-id="6c498-1753">Types of Bound Sessions</span></span>  

 <span data-ttu-id="6c498-1754">繫結工作階段有兩種類型：本機與分散式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1754">The two types of bound sessions are local and distributed.</span></span>  
  
-   <span data-ttu-id="6c498-1755">本機繫結工作階段</span><span class="sxs-lookup"><span data-stu-id="6c498-1755">Local bound session</span></span>  
  
     <span data-ttu-id="6c498-1756">允許繫結工作階段共用 [!INCLUDE[ssDE](../includes/ssde-md.md)]單一執行個體中單一交易的交易空間。</span><span class="sxs-lookup"><span data-stu-id="6c498-1756">Allows bound sessions to share the transaction space of a single transaction in a single instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span>  
  
-   <span data-ttu-id="6c498-1757">分散式繫結工作階段</span><span class="sxs-lookup"><span data-stu-id="6c498-1757">Distributed bound session</span></span>  
  
     <span data-ttu-id="6c498-1758">允許繫結工作階段跨二或多個執行個體共用同一筆交易，直到使用 [!INCLUDE[msCoName](../includes/msconame-md.md)] 分散式交易協調器 (MS DTC) 認可或回復整筆交易為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1758">Allows bound sessions to share the same transaction across two or more instances until the entire transaction is either committed or rolled back by using [!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator (MS DTC).</span></span>  
  
 <span data-ttu-id="6c498-1759">分散式繫結工作階段不是由字元字串的繫結 Token 識別，而是由分散式交易識別碼來識別。</span><span class="sxs-lookup"><span data-stu-id="6c498-1759">Distributed bound sessions are not identified by a character string bind token; they are identified by distributed transaction identification numbers.</span></span> <span data-ttu-id="6c498-1760">如果繫結工作階段包含於本機交易中，並使用 SET REMOTE_PROC_TRANSACTIONS ON 在遠端伺服器上執行 RPC，本機繫結交易就可透過 MS DTC 自動升級為分散式繫結交易，並啟動 MS DTC 工作階段。</span><span class="sxs-lookup"><span data-stu-id="6c498-1760">If a bound session is involved in a local transaction and executes an RPC on a remote server with SET REMOTE_PROC_TRANSACTIONS ON, the local bound transaction is automatically promoted to a distributed bound transaction by MS DTC and an MS DTC session is started.</span></span>  
  
#### <a name="when-to-use-bound-sessions"></a><span data-ttu-id="6c498-1761">使用繫結工作階段的時機</span><span class="sxs-lookup"><span data-stu-id="6c498-1761">When to Use Bound Sessions</span></span>  

 <span data-ttu-id="6c498-1762">在舊版 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中，繫結工作階段主要用於開發擴充預存程序，而這些擴充預存程序必須代表呼叫它們的處理序來執行 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1762">In earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], bound sessions were primarily used in developing extended stored procedures that must execute [!INCLUDE[tsql](../includes/tsql-md.md)] statements on behalf of the process that calls them.</span></span> <span data-ttu-id="6c498-1763">讓呼叫處理序傳入繫結 Token 作為擴充預存程序的一個參數，以允許程序加入呼叫處理序的交易空間之中，因此可整合擴充預存程序與呼叫處理序。</span><span class="sxs-lookup"><span data-stu-id="6c498-1763">Having the calling process pass in a bind token as one parameter of the extended stored procedure allows the procedure to join the transaction space of the calling process, thereby integrating the extended stored procedure with the calling process.</span></span>  
  
 <span data-ttu-id="6c498-1764">在 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]中，使用 CLR 撰寫的預存程序比起擴充預存程序，更安全、更具擴充性也更穩定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1764">In the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)], stored procedures written using CLR are more secure, scalable, and stable than extended stored procedures.</span></span> <span data-ttu-id="6c498-1765">CLR 預存程序使用 **SqlContext** 物件，而不是 **sp_bindsession**，來聯結呼叫工作階段的內容。</span><span class="sxs-lookup"><span data-stu-id="6c498-1765">CLR-stored procedures use the **SqlContext** object to join the context of the calling session, not **sp_bindsession**.</span></span>  
  
 <span data-ttu-id="6c498-1766">繫結工作階段可以用來開發三層式應用程式，其中商務邏輯可加入個別程式，而這些程式可協同處理單筆商務交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1766">Bound sessions can be used to develop three-tier applications in which business logic is incorporated into separate programs that work cooperatively on a single business transaction.</span></span> <span data-ttu-id="6c498-1767">這些程式必須予以編碼，以便能謹慎協調它們對資料庫的存取。</span><span class="sxs-lookup"><span data-stu-id="6c498-1767">These programs must be coded to carefully coordinate their access to a database.</span></span> <span data-ttu-id="6c498-1768">因為兩個工作階段共用相同的鎖定，所以這兩個程式絕不能同時嘗試修改相同的資料。</span><span class="sxs-lookup"><span data-stu-id="6c498-1768">Because the two sessions share the same locks, the two programs must not try to modify the same data at the same time.</span></span> <span data-ttu-id="6c498-1769">在交易過程的任何時候，只能有一個工作階段執行工作，不允許平行執行。</span><span class="sxs-lookup"><span data-stu-id="6c498-1769">At any point in time, only one session can be doing work as part of the transaction; there can be no parallel execution.</span></span> <span data-ttu-id="6c498-1770">只有在妥善定義的產生點 (例如所有 DML 陳述式都已完成，且也已擷取結果時)，才能於工作階段之間切換交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1770">The transaction can only be switched between sessions at well-defined yield points, such as when all DML statements have completed and their results have been retrieved.</span></span>  
  
### <a name="coding-efficient-transactions"></a><span data-ttu-id="6c498-1771">撰寫有效率的交易</span><span class="sxs-lookup"><span data-stu-id="6c498-1771">Coding Efficient Transactions</span></span>  

 <span data-ttu-id="6c498-1772">儘可能讓交易越短越好相當重要。</span><span class="sxs-lookup"><span data-stu-id="6c498-1772">It is important to keep transactions as short as possible.</span></span> <span data-ttu-id="6c498-1773">開始交易時，資料庫管理系統 (DBMS) 在交易結束之前必須保存許多資源，以保護交易的不可部份完成特性、一致性、隔離和持久性 (ACID) 屬性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1773">When a transaction is started, a database management system (DBMS) must hold many resources until the end of the transaction to protect the atomicity, consistency, isolation, and durability (ACID) properties of the transaction.</span></span> <span data-ttu-id="6c498-1774">如果已修改資料，必須以獨佔鎖定 (防止其他交易讀取資料列) 保護修改的資料列，並且在認可或回復交易之前必須保持獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1774">If data is modified, the modified rows must be protected with exclusive locks that prevent any other transaction from reading the rows, and exclusive locks must be held until the transaction is committed or rolled back.</span></span> <span data-ttu-id="6c498-1775">視交易隔離等級的設定而定，SELECT 陳述式可能會取得在認可或回復交易之前必須保持的鎖定。</span><span class="sxs-lookup"><span data-stu-id="6c498-1775">Depending on transaction isolation level settings, SELECT statements may acquire locks that must be held until the transaction is committed or rolled back.</span></span> <span data-ttu-id="6c498-1776">尤其是在擁有許多使用者的系統上，必須盡可能讓交易越短越好，以降低鎖定競爭並行連接之間的資源。</span><span class="sxs-lookup"><span data-stu-id="6c498-1776">Especially in systems with many users, transactions must be kept as short as possible to reduce locking contention for resources between concurrent connections.</span></span> <span data-ttu-id="6c498-1777">在少數使用者的情況下，沒有效率的長時間執行交易不會造成問題，但在擁有上千個使用者的系統中則無法忍受這種交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1777">Long-running, inefficient transactions may not be a problem with small numbers of users, but they are intolerable in a system with thousands of users.</span></span> <span data-ttu-id="6c498-1778">從 [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] 開始，[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 即可支援延遲的持久交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1778">Beginning with [!INCLUDE[ssSQL14](../includes/sssql14-md.md)][!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] supports delayed durable transactions.</span></span> <span data-ttu-id="6c498-1779">延遲的持久交易不保證持久性。</span><span class="sxs-lookup"><span data-stu-id="6c498-1779">Delayed durable transactions do not guarantee durability.</span></span> <span data-ttu-id="6c498-1780">如需詳細資訊，請參閱[交易持久性](../relational-databases/logs/control-transaction-durability.md)主題。</span><span class="sxs-lookup"><span data-stu-id="6c498-1780">See the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md) for more information.</span></span>  
  
#### <a name="coding-guidelines"></a><span data-ttu-id="6c498-1781">撰寫指引</span><span class="sxs-lookup"><span data-stu-id="6c498-1781">Coding Guidelines</span></span>  

 <span data-ttu-id="6c498-1782">以下為撰寫有效交易的指引：</span><span class="sxs-lookup"><span data-stu-id="6c498-1782">These are guidelines for coding efficient transactions:</span></span>  
  
-   <span data-ttu-id="6c498-1783">交易期間毋需使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="6c498-1783">Do not require input from users during a transaction.</span></span>  
  
     <span data-ttu-id="6c498-1784">啟動交易前，先取得必要的使用者所有輸入內容。</span><span class="sxs-lookup"><span data-stu-id="6c498-1784">Get all required input from users before a transaction is started.</span></span> <span data-ttu-id="6c498-1785">如果交易期間需要額外的使用者輸入，則復原目前的交易，並於使用者提供輸入之後重新啟動交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1785">If additional user input is required during a transaction, roll back the current transaction and restart the transaction after the user input is supplied.</span></span> <span data-ttu-id="6c498-1786">即使使用者立即回應，人類的反應時間還是比電腦的速度慢很多。</span><span class="sxs-lookup"><span data-stu-id="6c498-1786">Even if users respond immediately, human reaction times are vastly slower than computer speeds.</span></span> <span data-ttu-id="6c498-1787">交易佔用所有資源的時間非常久，這是造成封鎖問題的潛在因素。</span><span class="sxs-lookup"><span data-stu-id="6c498-1787">All resources held by the transaction are held for an extremely long time, which has the potential to cause blocking problems.</span></span> <span data-ttu-id="6c498-1788">如果使用者並未回應，交易便維持作用中，並鎖定重要的資源直到使用者回應為止，這種情形可能會維持數分鐘，或甚至幾小時。</span><span class="sxs-lookup"><span data-stu-id="6c498-1788">If users do not respond, the transaction remains active, locking critical resources until they respond, which may not happen for several minutes or even hours.</span></span>  
  
-   <span data-ttu-id="6c498-1789">如果位在全部皆可行，不要在瀏覽資料時開啟交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1789">Do not open a transaction while browsing through data, if at all possible.</span></span>  
  
     <span data-ttu-id="6c498-1790">交易應該等到所有的初步資料分析完成之後再啟動。</span><span class="sxs-lookup"><span data-stu-id="6c498-1790">Transactions should not be started until all preliminary data analysis has been completed.</span></span>  
  
-   <span data-ttu-id="6c498-1791">盡可能讓交易越短越好。</span><span class="sxs-lookup"><span data-stu-id="6c498-1791">Keep the transaction as short as possible.</span></span>  
  
     <span data-ttu-id="6c498-1792">在您知道必須進行的修改之後，請啟動交易、執行修改陳述式，然後立即進行認可或回復。</span><span class="sxs-lookup"><span data-stu-id="6c498-1792">After you know the modifications that have to be made, start a transaction, execute the modification statements, and then immediately commit or roll back.</span></span> <span data-ttu-id="6c498-1793">除非必要，否則請勿開啟交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1793">Do not open the transaction before it is required.</span></span>  
  
-   <span data-ttu-id="6c498-1794">若要減少封鎖問題，請考慮使用以資料列版本設定為基礎的隔離層級來進行唯讀查詢。</span><span class="sxs-lookup"><span data-stu-id="6c498-1794">To reduce blocking, consider using a row versioning-based isolation level for read-only queries.</span></span>  
  
-   <span data-ttu-id="6c498-1795">善用較低的交易隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1795">Make intelligent use of lower transaction isolation levels.</span></span>  
  
     <span data-ttu-id="6c498-1796">許多應用程式可輕易地撰寫成使用讀取 - 認可式的交易隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1796">Many applications can be readily coded to use a read-committed transaction isolation level.</span></span> <span data-ttu-id="6c498-1797">並非所有交易都需要可序列化的交易隔離等級。</span><span class="sxs-lookup"><span data-stu-id="6c498-1797">Not all transactions require the serializable transaction isolation level.</span></span>  
  
-   <span data-ttu-id="6c498-1798">善用較低的資料指標並行選項，例如樂觀並行 (Optimistic Concurrency) 選項。</span><span class="sxs-lookup"><span data-stu-id="6c498-1798">Make intelligent use of lower cursor concurrency options, such as optimistic concurrency options.</span></span>  
  
     <span data-ttu-id="6c498-1799">在並行更新的可能性較低的系統中，處理偶發的「有人在您讀取資料之後變更過資料」錯誤的額外負荷，可能比讀取時一直鎖定資料列的額外負荷更低。</span><span class="sxs-lookup"><span data-stu-id="6c498-1799">In a system with a low probability of concurrent updates, the overhead of dealing with an occasional "somebody else changed your data after you read it" error can be much lower than the overhead of always locking rows as they are read.</span></span>  
  
-   <span data-ttu-id="6c498-1800">在交易中儘可能存取最少的資料量。</span><span class="sxs-lookup"><span data-stu-id="6c498-1800">Access the least amount of data possible while in a transaction.</span></span>  
  
     <span data-ttu-id="6c498-1801">這會減少鎖定的資料列數量，因而降低了交易之間的競爭。</span><span class="sxs-lookup"><span data-stu-id="6c498-1801">This lessens the number of locked rows, thereby reducing contention between transactions.</span></span>  
  
#### <a name="avoiding-concurrency-and-resource-problems"></a><span data-ttu-id="6c498-1802">避免並行與資源問題</span><span class="sxs-lookup"><span data-stu-id="6c498-1802">Avoiding Concurrency and Resource Problems</span></span>  

 <span data-ttu-id="6c498-1803">若要避免並行與資源的問題，請小心管理隱含交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1803">To prevent concurrency and resource problems, manage implicit transactions carefully.</span></span> <span data-ttu-id="6c498-1804">使用隱含交易時，COMMIT 或 ROLLBACK 之後的下一個 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式會自動啟動一筆新的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1804">When using implicit transactions, the next [!INCLUDE[tsql](../includes/tsql-md.md)] statement after COMMIT or ROLLBACK automatically starts a new transaction.</span></span> <span data-ttu-id="6c498-1805">這可能造成交易在應用程式瀏覽資料時，或甚至在需要使用者輸入時被開啟。</span><span class="sxs-lookup"><span data-stu-id="6c498-1805">This can cause a new transaction to be opened while the application browses through data, or even when it requires input from the user.</span></span> <span data-ttu-id="6c498-1806">保護資料修改所需的最後一筆交易完成之後，請關閉隱含交易，直到交易再度需要保護資料修改為止。</span><span class="sxs-lookup"><span data-stu-id="6c498-1806">After completing the last transaction required to protect data modifications, turn off implicit transactions until a transaction is once again required to protect data modifications.</span></span> <span data-ttu-id="6c498-1807">這個程序讓「 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 」在應用程式瀏覽資料及取得使用者輸入時使用自動認可模式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1807">This process lets the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] use autocommit mode while the application is browsing data and getting input from the user.</span></span>  
  
 <span data-ttu-id="6c498-1808">此外，啟用快照隔離等級時，雖然新交易不會佔用鎖定，但長時間執行的交易仍然會阻礙從 `tempdb`移除舊版本。</span><span class="sxs-lookup"><span data-stu-id="6c498-1808">In addition, when the snapshot isolation level is enabled, although a new transaction will not hold locks, a long-running transaction will prevent the old versions from being removed from `tempdb`.</span></span>  
  
### <a name="managing-long-running-transactions"></a><span data-ttu-id="6c498-1809">管理長時間執行的交易</span><span class="sxs-lookup"><span data-stu-id="6c498-1809">Managing Long-Running Transactions</span></span>  

 <span data-ttu-id="6c498-1810">*「長時間執行的交易」* (Long-Running Transaction) 是指未及時認可的使用中交易或未及時回復的交易。</span><span class="sxs-lookup"><span data-stu-id="6c498-1810">A *long-running transaction* is an active transaction that has not been committed or roll backed the transaction in a timely manner.</span></span> <span data-ttu-id="6c498-1811">例如，如果交易的開始和結束是由使用者控制，長時間執行之交易的常見原因就是使用者開始進行交易，然後在交易等候使用者回應時離開。</span><span class="sxs-lookup"><span data-stu-id="6c498-1811">For example, if the beginning and end of a transaction is controlled by the user, a typical cause of a long-running transaction is a user starting a transaction and then leaving while the transaction waits for a response from the user.</span></span>  
  
 <span data-ttu-id="6c498-1812">長時間執行的交易可能會對資料庫造成以下幾個嚴重的問題：</span><span class="sxs-lookup"><span data-stu-id="6c498-1812">A long running transaction can cause serious problems for a database, as follows:</span></span>  
  
-   <span data-ttu-id="6c498-1813">如果在使用中交易已執行許多未認可的修改之後，伺服器實例已關閉，後續重新開機的復原階段可能需要比**recovery interval**伺服器設定選項所指定的時間更長，或是由 ALTER DATABASE .。。設定 TARGET_RECOVERY_TIME 選項。</span><span class="sxs-lookup"><span data-stu-id="6c498-1813">If a server instance is shut down after an active transaction has performed many uncommitted modifications, the recovery phase of the subsequent restart can take much longer than the time specified by the **recovery interval** server configuration option or by the ALTER DATABASE... SET TARGET_RECOVERY_TIME option.</span></span> <span data-ttu-id="6c498-1814">這些選項分別控制著使用中檢查點與間接檢查點的頻率。</span><span class="sxs-lookup"><span data-stu-id="6c498-1814">These options control the frequency of active and indirect checkpoints, respectively.</span></span> <span data-ttu-id="6c498-1815">如需有關檢查點類型的詳細資訊，請參閱[資料庫檢查點 &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1815">For more information about the types of checkpoints, see [Database Checkpoints &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md).</span></span>  
  
-   <span data-ttu-id="6c498-1816">更重要的是，等候中交易儘管產生的記錄可能很少，卻會永久阻礙記錄截斷動作，而導致交易記錄逐漸增大乃至填滿。</span><span class="sxs-lookup"><span data-stu-id="6c498-1816">More importantly, although a waiting transaction might generate very little log, it holds up log truncation indefinitely, causing the transaction log to grow and possibly fill up.</span></span> <span data-ttu-id="6c498-1817">一旦交易記錄填滿，資料庫就不再能夠執行任何更新。</span><span class="sxs-lookup"><span data-stu-id="6c498-1817">If the transaction log fills up, the database cannot perform any more updates.</span></span> <span data-ttu-id="6c498-1818">如需詳細資訊，請參閱針對[完整交易記錄進行疑難排解 &#40;SQL Server 錯誤 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md)，以及[&#40;SQL Server&#41;的事務](../relational-databases/logs/the-transaction-log-sql-server.md)歷史記錄檔。</span><span class="sxs-lookup"><span data-stu-id="6c498-1818">For more information, see [Troubleshoot a Full Transaction Log &#40;SQL Server Error 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md), and [The Transaction Log &#40;SQL Server&#41;](../relational-databases/logs/the-transaction-log-sql-server.md).</span></span>  
  
#### <a name="discovering-long-running-transactions"></a><span data-ttu-id="6c498-1819">探索長時間執行的交易</span><span class="sxs-lookup"><span data-stu-id="6c498-1819">Discovering Long-Running Transactions</span></span>  

 <span data-ttu-id="6c498-1820">若要尋找長時間執行的交易，請使用下列其中一種方式：</span><span class="sxs-lookup"><span data-stu-id="6c498-1820">To look for long-running transactions, use one of the following:</span></span>  
  
-   <span data-ttu-id="6c498-1821">**sys.dm_tran_database_transactions**</span><span class="sxs-lookup"><span data-stu-id="6c498-1821">**sys.dm_tran_database_transactions**</span></span>  
  
     <span data-ttu-id="6c498-1822">這個動態管理檢視傳回有關資料庫層級之交易的資訊。</span><span class="sxs-lookup"><span data-stu-id="6c498-1822">This dynamic management view returns information about transactions at the database level.</span></span> <span data-ttu-id="6c498-1823">對於長時間執行的交易，較重要的資料行包括第一筆記錄檔記錄的時間 (**database_transaction_begin_time**)、交易的目前狀態 (**database_transaction_state**) 和交易記錄之開始記錄的記錄序號 (LSN) (**database_transaction_begin_lsn**)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1823">For a long-running transaction, columns of particular interest include the time of the first log record (**database_transaction_begin_time**), the current state of the transaction (**database_transaction_state**), and the log sequence number (LSN) of the begin record in the transaction log (**database_transaction_begin_lsn**).</span></span>  
  
     <span data-ttu-id="6c498-1824">如需詳細資訊，請參閱 [sys.dm_tran_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1824">For more information, see [sys.dm_tran_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql).</span></span>  
  
-   <span data-ttu-id="6c498-1825">DBCC OPENTRAN</span><span class="sxs-lookup"><span data-stu-id="6c498-1825">DBCC OPENTRAN</span></span>  
  
     <span data-ttu-id="6c498-1826">此陳述式可讓您識別交易擁有者的使用者識別碼，如此就可以追蹤交易來源，以便更有條理地終止交易 (進行認可而非回復)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1826">This statement lets you identify the user ID of the owner of the transaction, so you can potentially track down the source of the transaction for a more orderly termination (committing it rather than rolling it back).</span></span> <span data-ttu-id="6c498-1827">如需詳細資訊，請參閱 [DBCC OPENTRAN &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-opentran-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1827">For more information, see [DBCC OPENTRAN &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-opentran-transact-sql).</span></span>  
  
#### <a name="stopping-a-transaction"></a><span data-ttu-id="6c498-1828">停止交易</span><span class="sxs-lookup"><span data-stu-id="6c498-1828">Stopping a Transaction</span></span>  

 <span data-ttu-id="6c498-1829">您可能必須使用 KILL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="6c498-1829">You may have to use the KILL statement.</span></span> <span data-ttu-id="6c498-1830">但是，請小心使用此陳述式，尤其是執行重要處理序時。</span><span class="sxs-lookup"><span data-stu-id="6c498-1830">Use this statement very carefully, however, especially when critical processes are running.</span></span> <span data-ttu-id="6c498-1831">如需詳細資訊，請參閱 [KILL &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/kill-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6c498-1831">For more information, see [KILL &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/kill-transact-sql).</span></span>  
  
 <span data-ttu-id="6c498-1832">[本指南中](#Top)![的 [回到頁首] 連結使用的箭號圖示](media/uparrow16x16.gif "與 [回到頁首] 連結搭配使用的箭頭圖示")</span><span class="sxs-lookup"><span data-stu-id="6c498-1832">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6c498-1833">另請參閱</span><span class="sxs-lookup"><span data-stu-id="6c498-1833">See Also</span></span>  

 <span data-ttu-id="6c498-1834">[SQL Server 2005 以資料列版本設定為基礎的交易隔離](https://msdn.microsoft.com/library/ms345124(v=sql.90).aspx) </span><span class="sxs-lookup"><span data-stu-id="6c498-1834">[SQL Server 2005 Row Versioning-Based Transaction Isolation](https://msdn.microsoft.com/library/ms345124(v=sql.90).aspx) </span></span>  
 <span data-ttu-id="6c498-1835">[資料列版本設定的額外負荷](https://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/03/30/overhead-of-row-versioning.aspx) </span><span class="sxs-lookup"><span data-stu-id="6c498-1835">[Overhead of Row Versioning](https://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/03/30/overhead-of-row-versioning.aspx) </span></span>  
 [<span data-ttu-id="6c498-1836">如何在 SQL Server 2008 中建立自發交易</span><span class="sxs-lookup"><span data-stu-id="6c498-1836">How to create an autonomous transaction in SQL Server 2008</span></span>](https://blogs.msdn.com/b/sqlprogrammability/archive/2008/08/22/how-to-create-an-autonomous-transaction-in-sql-server-2008.aspx)  
  
  
