---
title: SQL Server 2014 交易記錄架構和管理 |Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: 4d1a4f97-3fe4-44af-9d4f-f884a6eaa457
author: rothja
ms.author: jroth
ms.openlocfilehash: 8d32950d94bff22d6549c468e8fe8db3f30fd09a
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87592356"
---
# <a name="sql-server-2014-transaction-log-architecture-and-management"></a><span data-ttu-id="36e4a-102">SQL Server 2014 交易記錄架構與管理</span><span class="sxs-lookup"><span data-stu-id="36e4a-102">SQL Server 2014 Transaction Log Architecture and Management</span></span>

<span data-ttu-id="36e4a-103">**適用物件：** 從2008開始 SQL Server () </span><span class="sxs-lookup"><span data-stu-id="36e4a-103">**Applies to:** SQL Server (starting with 2008)</span></span>

  <span data-ttu-id="36e4a-104">每個 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 資料庫都有交易記錄檔，這個記錄檔會記錄所有交易，以及個別交易在資料庫中所做的修改。</span><span class="sxs-lookup"><span data-stu-id="36e4a-104">Every [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] database has a transaction log that records all transactions and the database modifications that are made by each transaction.</span></span> <span data-ttu-id="36e4a-105">交易記錄是資料庫的重要元件，而且如果系統故障，就可能需要交易記錄讓資料庫返回一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="36e4a-105">The transaction log is a critical component of the database and, if there is a system failure, the transaction log might be required to bring your database back to a consistent state.</span></span> <span data-ttu-id="36e4a-106">本指南提供有關交易記錄實體及邏輯架構的資訊。</span><span class="sxs-lookup"><span data-stu-id="36e4a-106">This guide provides information about the physical and logical architecture of the transaction log.</span></span> <span data-ttu-id="36e4a-107">了解此架構可提升交易記錄管理的效能。</span><span class="sxs-lookup"><span data-stu-id="36e4a-107">Understanding the architecture can improve your effectiveness in managing transaction logs.</span></span>  

  
##  <a name="transaction-log-logical-architecture"></a><a name="Logical_Arch"></a><span data-ttu-id="36e4a-108">交易記錄邏輯架構</span><span class="sxs-lookup"><span data-stu-id="36e4a-108">Transaction Log Logical Architecture</span></span>  

 <span data-ttu-id="36e4a-109">在邏輯上， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 交易記錄檔會以記錄檔記錄字串的形式進行運作。</span><span class="sxs-lookup"><span data-stu-id="36e4a-109">The [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] transaction log operates logically as if the transaction log is a string of log records.</span></span> <span data-ttu-id="36e4a-110">每個記錄檔記錄均由記錄序號 (LSN) 來識別。</span><span class="sxs-lookup"><span data-stu-id="36e4a-110">Each log record is identified by a log sequence number (LSN).</span></span> <span data-ttu-id="36e4a-111">每筆新記錄檔記錄都會寫入記錄檔的邏輯結尾處，並且其 LSN 比它前一個記錄的 LSN 來得大。</span><span class="sxs-lookup"><span data-stu-id="36e4a-111">Each new log record is written to the logical end of the log with an LSN that is higher than the LSN of the record before it.</span></span> <span data-ttu-id="36e4a-112">記錄檔記錄將在它們建立時依序儲存。</span><span class="sxs-lookup"><span data-stu-id="36e4a-112">Log records are stored in a serial sequence as they are created.</span></span> <span data-ttu-id="36e4a-113">每筆記錄檔記錄都包含所屬交易的識別碼。</span><span class="sxs-lookup"><span data-stu-id="36e4a-113">Each log record contains the ID of the transaction that it belongs to.</span></span> <span data-ttu-id="36e4a-114">對於每筆交易，所有與交易關聯的記錄檔記錄將使用反向指標個別地連結於鏈結之中，以加速交易的回復。</span><span class="sxs-lookup"><span data-stu-id="36e4a-114">For each transaction, all log records associated with the transaction are individually linked in a chain using backward pointers that speed the rollback of the transaction.</span></span>  
  
 <span data-ttu-id="36e4a-115">資料修改的記錄檔記錄可記錄所執行的邏輯作業，或是已修改資料的前置與後置資料影像。</span><span class="sxs-lookup"><span data-stu-id="36e4a-115">Log records for data modifications record either the logical operation performed or they record the before and after images of the modified data.</span></span> <span data-ttu-id="36e4a-116">前置資料影像為執行作業之前的資料副本；後置資料影像為執行作業之後的資料副本。</span><span class="sxs-lookup"><span data-stu-id="36e4a-116">The before image is a copy of the data before the operation is performed; the after image is a copy of the data after the operation has been performed.</span></span>  
  
 <span data-ttu-id="36e4a-117">復原作業的步驟取決於記錄檔記錄的類型：</span><span class="sxs-lookup"><span data-stu-id="36e4a-117">The steps to recover an operation depend on the type of log record:</span></span>  
  
-   <span data-ttu-id="36e4a-118">記錄的邏輯作業</span><span class="sxs-lookup"><span data-stu-id="36e4a-118">Logical operation logged</span></span>  
  
    -   <span data-ttu-id="36e4a-119">若要向前復原邏輯作業，必須再次執行作業。</span><span class="sxs-lookup"><span data-stu-id="36e4a-119">To roll the logical operation forward, the operation is performed again.</span></span>  
  
    -   <span data-ttu-id="36e4a-120">若要回復邏輯作業，則執行反向的邏輯作業。</span><span class="sxs-lookup"><span data-stu-id="36e4a-120">To roll the logical operation back, the reverse logical operation is performed.</span></span>  
  
-   <span data-ttu-id="36e4a-121">記錄的前置與後置資料影像</span><span class="sxs-lookup"><span data-stu-id="36e4a-121">Before and after image logged</span></span>  
  
    -   <span data-ttu-id="36e4a-122">若要向前復原作業，將套用後置資料影像。</span><span class="sxs-lookup"><span data-stu-id="36e4a-122">To roll the operation forward, the after image is applied.</span></span>  
  
    -   <span data-ttu-id="36e4a-123">若要回復作業，將套用前置資料影像。</span><span class="sxs-lookup"><span data-stu-id="36e4a-123">To roll the operation back, the before image is applied.</span></span>  
  
 <span data-ttu-id="36e4a-124">交易記錄檔中記錄了許多類型的作業。</span><span class="sxs-lookup"><span data-stu-id="36e4a-124">Many types of operations are recorded in the transaction log.</span></span> <span data-ttu-id="36e4a-125">這些作業包括：</span><span class="sxs-lookup"><span data-stu-id="36e4a-125">These operations include:</span></span>  
  
-   <span data-ttu-id="36e4a-126">每筆交易的開始與結束。</span><span class="sxs-lookup"><span data-stu-id="36e4a-126">The start and end of each transaction.</span></span>  
  
-   <span data-ttu-id="36e4a-127">每個資料修改 (插入、更新或刪除)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-127">Every data modification (insert, update, or delete).</span></span> <span data-ttu-id="36e4a-128">這包括系統預存程序或資料定義語言 (DDL) 陳述式對任何資料表 (包括系統資料表) 所做的變更。</span><span class="sxs-lookup"><span data-stu-id="36e4a-128">This includes changes by system stored procedures or data definition language (DDL) statements to any table, including system tables.</span></span>  
  
-   <span data-ttu-id="36e4a-129">每個範圍與分頁的配置或取消配置。</span><span class="sxs-lookup"><span data-stu-id="36e4a-129">Every extent and page allocation or deallocation.</span></span>  
  
-   <span data-ttu-id="36e4a-130">建立或卸除資料表或索引。</span><span class="sxs-lookup"><span data-stu-id="36e4a-130">Creating or dropping a table or index.</span></span>  
  
 <span data-ttu-id="36e4a-131">回復作業也會留下記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-131">Rollback operations are also logged.</span></span> <span data-ttu-id="36e4a-132">每筆交易都會在交易記錄檔中保留空間，以確保有足夠的記錄檔空間可支援由明確回復陳述式所造成的回復，或因發生錯誤而造成的回復。</span><span class="sxs-lookup"><span data-stu-id="36e4a-132">Each transaction reserves space on the transaction log to make sure that enough log space exists to support a rollback that is caused by either an explicit rollback statement or if an error is encountered.</span></span> <span data-ttu-id="36e4a-133">保留的空間大小須視交易中執行的作業而定，但通常會等於用來記錄每個作業的空間大小。</span><span class="sxs-lookup"><span data-stu-id="36e4a-133">The amount of space reserved depends on the operations performed in the transaction, but generally it is equal to the amount of space used to log each operation.</span></span> <span data-ttu-id="36e4a-134">當交易完成後就會釋放這個保留空間。</span><span class="sxs-lookup"><span data-stu-id="36e4a-134">This reserved space is freed when the transaction is completed.</span></span>  
  
 <span data-ttu-id="36e4a-135"> 在記錄檔中，從對成功回復全資料庫而言不可或缺的第一筆記錄檔記錄，一直到最後寫入的記錄檔記錄的這個區段，稱為記錄檔的使用中部分，或「使用中的記錄\」\**。</span><span class="sxs-lookup"><span data-stu-id="36e4a-135">The section of the log file from the first log record that must be present for a successful database-wide rollback to the last-written log record is called the active part of the log, or the *active log*.</span></span> <span data-ttu-id="36e4a-136">這是需要進行完整資料庫復原的記錄區段。</span><span class="sxs-lookup"><span data-stu-id="36e4a-136">This is the section of the log required to a full recovery of the database.</span></span> <span data-ttu-id="36e4a-137">沒有任何使用中的記錄部分可被截斷。</span><span class="sxs-lookup"><span data-stu-id="36e4a-137">No part of the active log can ever be truncated.</span></span> <span data-ttu-id="36e4a-138">此第一個記錄檔記錄的記錄序號 (LSN) 就稱為最小復原 LSN (*MinLSN*)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-138">The log sequence number (LSN) of this first log record is known as the minimum recovery LSN (*MinLSN*).</span></span>  
  
##  <a name="transaction-log-physical-architecture"></a><a name="physical_arch"></a> <span data-ttu-id="36e4a-139">交易記錄實體架構</span><span class="sxs-lookup"><span data-stu-id="36e4a-139">Transaction Log Physical Architecture</span></span>  

 <span data-ttu-id="36e4a-140">資料庫中的交易記錄會對應到一個或多個實體檔案。</span><span class="sxs-lookup"><span data-stu-id="36e4a-140">The transaction log in a database maps over one or more physical files.</span></span> <span data-ttu-id="36e4a-141">從概念上來說，記錄檔是記錄的字串。</span><span class="sxs-lookup"><span data-stu-id="36e4a-141">Conceptually, the log file is a string of log records.</span></span> <span data-ttu-id="36e4a-142">就實際上來說，記錄的順序必須有效地儲存在實作交易記錄的一組實體檔案中。</span><span class="sxs-lookup"><span data-stu-id="36e4a-142">Physically, the sequence of log records is stored efficiently in the set of physical files that implement the transaction log.</span></span> <span data-ttu-id="36e4a-143">每個資料庫至少要有一個記錄檔。</span><span class="sxs-lookup"><span data-stu-id="36e4a-143">There must be at least one log file for each database.</span></span>  
  
 <span data-ttu-id="36e4a-144">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 會在內部將每個實體記錄檔分成數個虛擬記錄檔。</span><span class="sxs-lookup"><span data-stu-id="36e4a-144">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] divides each physical log file internally into a number of virtual log files.</span></span> <span data-ttu-id="36e4a-145">虛擬記錄檔沒有固定的大小，一個實體記錄檔也沒有固定的虛擬記錄檔數目。</span><span class="sxs-lookup"><span data-stu-id="36e4a-145">Virtual log files have no fixed size, and there is no fixed number of virtual log files for a physical log file.</span></span> <span data-ttu-id="36e4a-146">[!INCLUDE[ssDE](../includes/ssde-md.md)] 在建立或擴充記錄檔時，會動態選擇虛擬記錄檔的大小。</span><span class="sxs-lookup"><span data-stu-id="36e4a-146">The [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses the size of the virtual log files dynamically while it is creating or extending log files.</span></span> <span data-ttu-id="36e4a-147">[!INCLUDE[ssDE](../includes/ssde-md.md)] 會盡量維持少量的虛擬檔。</span><span class="sxs-lookup"><span data-stu-id="36e4a-147">The [!INCLUDE[ssDE](../includes/ssde-md.md)] tries to maintain a small number of virtual files.</span></span> <span data-ttu-id="36e4a-148">記錄檔擴充之後的虛擬檔大小，是現有記錄檔大小以及新檔案所增加的大小總和。</span><span class="sxs-lookup"><span data-stu-id="36e4a-148">The size of the virtual files after a log file has been extended is the sum of the size of the existing log and the size of the new file increment.</span></span> <span data-ttu-id="36e4a-149">系統管理員無法設定虛擬記錄檔的大小或數目。</span><span class="sxs-lookup"><span data-stu-id="36e4a-149">The size or number of virtual log files cannot be configured or set by administrators.</span></span>  
  
 <span data-ttu-id="36e4a-150">只有當實體記錄檔是以較小的 *size* 和 *growth_increment* 值來定義時，虛擬記錄檔才會影響到系統效能。</span><span class="sxs-lookup"><span data-stu-id="36e4a-150">The only time virtual log files affect system performance is if the physical log files are defined by small *size* and *growth_increment* values.</span></span> <span data-ttu-id="36e4a-151">*size* 值是記錄檔的初始大小，而 *growth_increment* 值則是每次需要新空間時加入檔案的空間量。</span><span class="sxs-lookup"><span data-stu-id="36e4a-151">The *size* value is the initial size for the log file and the *growth_increment* value is the amount of space added to the file every time new space is required.</span></span> <span data-ttu-id="36e4a-152">如果記錄檔因為許多少量增加而變得很龐大，將會產生許多虛擬記錄檔。</span><span class="sxs-lookup"><span data-stu-id="36e4a-152">If the log files grow to a large size because of many small increments, they will have many virtual log files.</span></span> <span data-ttu-id="36e4a-153">這樣會減慢資料庫啟動的速度，也會降低記錄備份和還原作業的執行速度。</span><span class="sxs-lookup"><span data-stu-id="36e4a-153">This can slow down database startup and also log backup and restore operations.</span></span> <span data-ttu-id="36e4a-154">建議您使用接近最後所需大小的 *size* 值來指派記錄檔，並使用相對較大的 *growth_increment* 值。</span><span class="sxs-lookup"><span data-stu-id="36e4a-154">We recommend that you assign log files a *size* value close to the final size required, and also have a relatively large *growth_increment* value.</span></span> <span data-ttu-id="36e4a-155">如需這些參數的詳細資訊，請參閱 [ALTER DATABASE 檔案及檔案群組選項 &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-155">For more information about these parameters, see [ALTER DATABASE File and Filegroup Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options).</span></span>  
  
 <span data-ttu-id="36e4a-156">交易記錄是循環使用的檔案。</span><span class="sxs-lookup"><span data-stu-id="36e4a-156">The transaction log is a wrap-around file.</span></span> <span data-ttu-id="36e4a-157">例如，假設資料庫的一個實體記錄檔分成四個虛擬記錄檔。</span><span class="sxs-lookup"><span data-stu-id="36e4a-157">For example, consider a database with one physical log file divided into four virtual log files.</span></span> <span data-ttu-id="36e4a-158">資料庫建立時，邏輯記錄檔從實體記錄檔的最前面開始。</span><span class="sxs-lookup"><span data-stu-id="36e4a-158">When the database is created, the logical log file begins at the start of the physical log file.</span></span> <span data-ttu-id="36e4a-159">新的記錄會加在邏輯記錄檔的最後，並朝向實體記錄檔的結尾處擴充。</span><span class="sxs-lookup"><span data-stu-id="36e4a-159">New log records are added at the end of the logical log and expand toward the end of the physical log.</span></span> <span data-ttu-id="36e4a-160">記錄截斷會釋出記錄出現在最小復原記錄序號 (MinLSN) 前面的所有虛擬記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-160">Log truncation frees any virtual logs whose records all appear in front of the minimum recovery log sequence number (MinLSN).</span></span> <span data-ttu-id="36e4a-161">*MinLSN* 是成功回復全資料庫所需之最舊記錄檔記錄的記錄序號。</span><span class="sxs-lookup"><span data-stu-id="36e4a-161">The *MinLSN* is the log sequence number of the oldest log record that is required for a successful database-wide rollback.</span></span> <span data-ttu-id="36e4a-162">範例資料庫中的交易記錄看起來如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="36e4a-162">The transaction log in the example database would look similar to the one in the following illustration.</span></span>  
  
 <span data-ttu-id="36e4a-163">![分為四個虛擬記錄檔的記錄檔](media/tranlog3.gif "分為四個虛擬記錄檔的記錄檔")</span><span class="sxs-lookup"><span data-stu-id="36e4a-163">![Log file divided into four virtual log files](media/tranlog3.gif "Log file divided into four virtual log files")</span></span>  
  
 <span data-ttu-id="36e4a-164">當邏輯記錄檔的結尾到達實體記錄檔的結尾時，新的記錄資料將寫回實體記錄檔的開頭處。</span><span class="sxs-lookup"><span data-stu-id="36e4a-164">When the end of the logical log reaches the end of the physical log file, the new log records wrap around to the start of the physical log file.</span></span>  
  
 <span data-ttu-id="36e4a-165">![記錄檔記錄寫回到記錄檔的開頭](media/tranlog4.gif "記錄檔記錄寫回到記錄檔的開頭")</span><span class="sxs-lookup"><span data-stu-id="36e4a-165">![Log records wrap around to start of log file](media/tranlog4.gif "Log records wrap around to start of log file")</span></span>  
  
 <span data-ttu-id="36e4a-166">只要邏輯記錄檔的結尾永遠不碰到邏輯記錄檔的開頭，此週期就會不斷地重複。</span><span class="sxs-lookup"><span data-stu-id="36e4a-166">This cycle repeats endlessly, as long as the end of the logical log never reaches the beginning of the logical log.</span></span> <span data-ttu-id="36e4a-167">如果經常截斷舊的記錄，以便讓目前到下個檢查點之間建立的所有新記錄一定會有足夠的空間可以使用，記錄檔就永遠不會填滿。</span><span class="sxs-lookup"><span data-stu-id="36e4a-167">If the old log records are truncated frequently enough to always leave sufficient room for all the new log records created through the next checkpoint, the log never fills.</span></span> <span data-ttu-id="36e4a-168">不過，如果邏輯記錄檔的結尾已到達邏輯記錄檔的開頭，會發生下列其中一種狀況：</span><span class="sxs-lookup"><span data-stu-id="36e4a-168">However, if the end of the logical log does reach the start of the logical log, one of two things occurs:</span></span>  
  
-   <span data-ttu-id="36e4a-169">如果記錄檔啟用 FILEGROWTH 設定，而且磁碟也有可用的空間，則檔案會以 *growth_increment* 參數所指定的數量擴大，並將新的記錄新增到擴充部分。</span><span class="sxs-lookup"><span data-stu-id="36e4a-169">If the FILEGROWTH setting is enabled for the log and space is available on the disk, the file is extended by the amount specified in the *growth_increment* parameter and the new log records are added to the extension.</span></span> <span data-ttu-id="36e4a-170">如需 FILEGROWTH 設定的詳細資訊，請參閱 [ALTER DATABASE 檔案及檔案群組選項 &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-170">For more information about the FILEGROWTH setting, see [ALTER DATABASE File and Filegroup Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options).</span></span>  
  
-   <span data-ttu-id="36e4a-171">如果未啟用 FILEGROWTH，或保存記錄檔的磁碟可用空間少於 *growth_increment* 所指定的數量，則會產生 9002 錯誤。</span><span class="sxs-lookup"><span data-stu-id="36e4a-171">If the FILEGROWTH setting is not enabled, or the disk that is holding the log file has less free space than the amount specified in *growth_increment*, an 9002 error is generated.</span></span>  
  
 <span data-ttu-id="36e4a-172">如果記錄檔包含多個實體記錄檔，邏輯記錄檔會從頭到尾在所有的實體記錄檔移動之後，才繞回第一個實體記錄檔的起點。</span><span class="sxs-lookup"><span data-stu-id="36e4a-172">If the log contains multiple physical log files, the logical log will move through all the physical log files before it wraps back to the start of the first physical log file.</span></span>  
  
### <a name="log-truncation"></a><span data-ttu-id="36e4a-173">記錄截斷</span><span class="sxs-lookup"><span data-stu-id="36e4a-173">Log Truncation</span></span>  

 <span data-ttu-id="36e4a-174">為了避免記錄被填滿，必須截斷記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-174">Log truncation is essential to keep the log from filling.</span></span> <span data-ttu-id="36e4a-175">記錄截斷會從 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 資料庫的邏輯交易記錄中刪除非使用中的虛擬記錄檔，釋出邏輯記錄中的空間以供實體交易記錄重複使用。</span><span class="sxs-lookup"><span data-stu-id="36e4a-175">Log truncation deletes inactive virtual log files from the logical transaction log of a [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] database, freeing space in the logical log for reuse by the physical transaction log.</span></span> <span data-ttu-id="36e4a-176">如果永遠都不截斷交易記錄，最終將會填滿配置給其實體記錄檔的所有磁碟空間。</span><span class="sxs-lookup"><span data-stu-id="36e4a-176">If a transaction log were never truncated, it would eventually fill all the disk space that is allocated to its physical log files.</span></span> <span data-ttu-id="36e4a-177">不過，必須先進行檢查點作業，才能截斷記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-177">However, before the log can be truncated, a checkpoint operation must occur.</span></span> <span data-ttu-id="36e4a-178">檢查點會將目前記憶體中已修改的頁面 (稱為中途分頁) 和交易記錄資訊從記憶體寫入磁碟。</span><span class="sxs-lookup"><span data-stu-id="36e4a-178">A checkpoint writes the current in-memory modified pages (known as dirty pages) and transaction log information from memory to disk.</span></span> <span data-ttu-id="36e4a-179">執行檢查點時，交易記錄的非使用中部分會標示成可重複使用。</span><span class="sxs-lookup"><span data-stu-id="36e4a-179">When the checkpoint is performed, the inactive portion of the transaction log is marked as reusable.</span></span> <span data-ttu-id="36e4a-180">之後，記錄截斷就可以釋出非使用中的部分。</span><span class="sxs-lookup"><span data-stu-id="36e4a-180">Thereafter, the inactive portion can be freed by log truncation.</span></span> <span data-ttu-id="36e4a-181">如需檢查點的詳細資訊，請參閱[資料庫檢查點 &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-181">For more information about checkpoints, see [Database Checkpoints &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md).</span></span>  
  
 <span data-ttu-id="36e4a-182">下圖將顯示截斷前後的交易記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-182">The following illustrations show a transaction log before and after truncation.</span></span> <span data-ttu-id="36e4a-183">第一張圖是顯示從未進行截斷的交易記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-183">The first illustration shows a transaction log that has never been truncated.</span></span> <span data-ttu-id="36e4a-184">目前，邏輯記錄正使用四個虛擬記錄檔。</span><span class="sxs-lookup"><span data-stu-id="36e4a-184">Currently, four virtual log files are in use by the logical log.</span></span> <span data-ttu-id="36e4a-185">邏輯記錄檔是從第一個虛擬記錄檔的前面開始，並於虛擬記錄檔 4 結束。</span><span class="sxs-lookup"><span data-stu-id="36e4a-185">The logical log starts at the front of the first virtual log file and ends at virtual log 4.</span></span> <span data-ttu-id="36e4a-186">MinLSN 記錄位於虛擬記錄檔 3 中。</span><span class="sxs-lookup"><span data-stu-id="36e4a-186">The MinLSN record is in virtual log 3.</span></span> <span data-ttu-id="36e4a-187">虛擬記錄檔 1 和虛擬記錄檔 2 僅包含非使用中的記錄檔記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-187">Virtual log 1 and virtual log 2 contain only inactive log records.</span></span> <span data-ttu-id="36e4a-188">這些記錄都可以截斷。</span><span class="sxs-lookup"><span data-stu-id="36e4a-188">These records can be truncated.</span></span> <span data-ttu-id="36e4a-189">虛擬記錄 5 仍未使用而且不屬於目前邏輯記錄的一部分。</span><span class="sxs-lookup"><span data-stu-id="36e4a-189">Virtual log 5 is still unused and is not part of the current logical log.</span></span>  
  
 <span data-ttu-id="36e4a-190">![具有四個虛擬記錄檔的交易記錄檔](media/tranlog2.gif "具有四個虛擬記錄檔的交易記錄檔")</span><span class="sxs-lookup"><span data-stu-id="36e4a-190">![Transaction log with four virtual logs](media/tranlog2.gif "Transaction log with four virtual logs")</span></span>  
  
 <span data-ttu-id="36e4a-191">第二張圖是顯示記錄截斷之後的內容。</span><span class="sxs-lookup"><span data-stu-id="36e4a-191">The second illustration shows how the log appears after being truncated.</span></span> <span data-ttu-id="36e4a-192">虛擬記錄 1 和虛擬記錄 2 已經釋出以便重複使用。</span><span class="sxs-lookup"><span data-stu-id="36e4a-192">Virtual log 1 and virtual log 2 have been freed for reuse.</span></span> <span data-ttu-id="36e4a-193">現在邏輯記錄檔是從虛擬記錄檔 3 的前面開始。</span><span class="sxs-lookup"><span data-stu-id="36e4a-193">The logical log now starts at the beginning of virtual log 3.</span></span> <span data-ttu-id="36e4a-194">虛擬記錄檔 5 仍未使用，而且不屬於目前邏輯記錄檔的一部分。</span><span class="sxs-lookup"><span data-stu-id="36e4a-194">Virtual log 5 is still unused, and it is not part of the current logical log.</span></span>  
  
 <span data-ttu-id="36e4a-195">![分為四個虛擬記錄檔的記錄檔](media/tranlog3.gif "分為四個虛擬記錄檔的記錄檔")</span><span class="sxs-lookup"><span data-stu-id="36e4a-195">![Log file divided into four virtual log files](media/tranlog3.gif "Log file divided into four virtual log files")</span></span>  
  
 <span data-ttu-id="36e4a-196">除了因為某種原因而延遲以外，記錄截斷會在發生下列事件之後自動進行：</span><span class="sxs-lookup"><span data-stu-id="36e4a-196">Log truncation occurs automatically after the following events, except when delayed for some reason:</span></span>  
  
-   <span data-ttu-id="36e4a-197">在簡單復原模式下，發生在檢查點之後。</span><span class="sxs-lookup"><span data-stu-id="36e4a-197">Under the simple recovery model, after a checkpoint.</span></span>  
  
-   <span data-ttu-id="36e4a-198">在完整復原模式或大量記錄復原模式下，上一次備份以來發生檢查點時的記錄備份之後。</span><span class="sxs-lookup"><span data-stu-id="36e4a-198">Under the full recovery model or bulk-logged recovery model, after a log backup, if a checkpoint has occurred since the previous backup.</span></span>  
  
 <span data-ttu-id="36e4a-199">記錄截斷可能會因為各種因素而延遲。</span><span class="sxs-lookup"><span data-stu-id="36e4a-199">Log truncation can be delayed by a variety of factors.</span></span> <span data-ttu-id="36e4a-200">如果在記錄截斷中發生長時間的延遲，交易記錄可能會填滿。</span><span class="sxs-lookup"><span data-stu-id="36e4a-200">In the event of a long delay in log truncation, the transaction log can fill up.</span></span> <span data-ttu-id="36e4a-201">如需相關資訊，請參閱[可能會延遲記錄截斷](../relational-databases/logs/the-transaction-log-sql-server.md#FactorsThatDelayTruncation)和[疑難排解完整交易記錄檔的因素 &#40;SQL Server 錯誤 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-201">For information, see [Factors That Can Delay Log Truncation](../relational-databases/logs/the-transaction-log-sql-server.md#FactorsThatDelayTruncation) and [Troubleshoot a Full Transaction Log &#40;SQL Server Error 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md).</span></span>  
  
##  <a name="write-ahead-transaction-log"></a><a name="WAL"></a><span data-ttu-id="36e4a-202">預先寫入交易記錄</span><span class="sxs-lookup"><span data-stu-id="36e4a-202">Write-Ahead Transaction Log</span></span>  

 <span data-ttu-id="36e4a-203">本章節說明預先寫入交易記錄在將資料修改記錄至磁碟時所扮演的角色。</span><span class="sxs-lookup"><span data-stu-id="36e4a-203">This section describes the role of the write-ahead transaction log in recording data modifications to disk.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="36e4a-204">會使用預先寫入記錄 (WAL)，而這項功能可確保在關聯的記錄檔記錄寫入磁碟之前，不會有任何資料修改寫入磁碟。</span><span class="sxs-lookup"><span data-stu-id="36e4a-204">uses a write-ahead log (WAL), which guarantees that no data modifications are written to disk before the associated log record is written to disk.</span></span> <span data-ttu-id="36e4a-205">如此可保留交易的 ACID 屬性。</span><span class="sxs-lookup"><span data-stu-id="36e4a-205">This maintains the ACID properties for a transaction.</span></span>  
  
 <span data-ttu-id="36e4a-206">若要了解預寫記錄檔的運作方式，您一定要知道如何將修改的資料寫入磁碟。</span><span class="sxs-lookup"><span data-stu-id="36e4a-206">To understand how the write-ahead log works, it is important for you to know how modified data is written to disk.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="36e4a-207">會維護緩衝快取，當需要擷取資料時，就可以將資料頁讀取到其中。</span><span class="sxs-lookup"><span data-stu-id="36e4a-207">maintains a buffer cache into which it reads data pages when data must be retrieved.</span></span> <span data-ttu-id="36e4a-208">在緩衝區快取中修改頁面時，不會立即將它寫回磁片。而是將頁面標示為「中途 *」。*</span><span class="sxs-lookup"><span data-stu-id="36e4a-208">When a page is modified in the buffer cache, it is not immediately written back to disk; instead, the page is marked as *dirty*.</span></span> <span data-ttu-id="36e4a-209">在實際將資料頁寫入磁碟之前，可以進行多次邏輯寫入。</span><span class="sxs-lookup"><span data-stu-id="36e4a-209">A data page can have more than one logical write made before it is physically written to disk.</span></span> <span data-ttu-id="36e4a-210">每次邏輯寫入時，都會有交易記錄插入至記載修改的記錄快取中。</span><span class="sxs-lookup"><span data-stu-id="36e4a-210">For each logical write, a transaction log record is inserted in the log cache that records the modification.</span></span> <span data-ttu-id="36e4a-211">記錄檔記錄必須在關聯的中途分頁從緩衝區快取移除而寫入至磁碟之前，先寫入磁碟中。</span><span class="sxs-lookup"><span data-stu-id="36e4a-211">The log records must be written to disk before the associated dirty page is removed from the buffer cache and written to disk.</span></span> <span data-ttu-id="36e4a-212">檢查點處理序會定期掃描緩衝快取，檢查是否有內含來自指定資料庫之頁面的緩衝區，並將所有中途分頁寫入磁碟。</span><span class="sxs-lookup"><span data-stu-id="36e4a-212">The checkpoint process periodically scans the buffer cache for buffers with pages from a specified database and writes all dirty pages to disk.</span></span> <span data-ttu-id="36e4a-213">藉由建立一個點來確保所有中途分頁都已寫入磁碟中，檢查點可讓稍後的復原節省時間。</span><span class="sxs-lookup"><span data-stu-id="36e4a-213">Checkpoints save time during a later recovery by creating a point at which all dirty pages are guaranteed to have been written to disk.</span></span>  
  
 <span data-ttu-id="36e4a-214">將緩衝區快取中之修改資料頁面寫入磁碟中的動作稱為清除頁面。</span><span class="sxs-lookup"><span data-stu-id="36e4a-214">Writing a modified data page from the buffer cache to disk is called flushing the page.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="36e4a-215">含有防止中途分頁在寫入相關聯記錄檔記錄之前遭到清除的邏輯。</span><span class="sxs-lookup"><span data-stu-id="36e4a-215">has logic that prevents a dirty page from being flushed before the associated log record is written.</span></span> <span data-ttu-id="36e4a-216">記錄會在交易被認可後寫入磁碟中。</span><span class="sxs-lookup"><span data-stu-id="36e4a-216">Log records are written to disk when the transactions are committed.</span></span>  
  
##  <a name="transaction-log-backups"></a><a name="Backups"></a><span data-ttu-id="36e4a-217">交易記錄備份</span><span class="sxs-lookup"><span data-stu-id="36e4a-217">Transaction Log Backups</span></span>  

 <span data-ttu-id="36e4a-218">本章節提出有關如何備份和還原 (套用) 交易記錄的概念。</span><span class="sxs-lookup"><span data-stu-id="36e4a-218">This section presents concepts about how to back up and restore (apply) transaction logs.</span></span> <span data-ttu-id="36e4a-219">在完整和大量記錄復原模式下，進行交易記錄 (「記錄備份」\*\*) 的例行備份，對復原資料而言是必要的。</span><span class="sxs-lookup"><span data-stu-id="36e4a-219">Under the full and bulk-logged recovery models, taking routine backups of transaction logs (*log backups*) is necessary for recovering data.</span></span> <span data-ttu-id="36e4a-220">您可以在任何完整備份正在執行的同時備份記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-220">You can back up the log while any full backup is running.</span></span> <span data-ttu-id="36e4a-221">如需復原模型的詳細資訊，請參閱 [SQL Server 資料庫的備份與還原](../relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases.md)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-221">For more information about recovery models, see [Back Up and Restore of SQL Server Databases](../relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases.md).</span></span>  
  
 <span data-ttu-id="36e4a-222">在建立第一個記錄備份之前，您必須建立完整備份，例如資料庫備份或檔案備份組中的第一個備份。</span><span class="sxs-lookup"><span data-stu-id="36e4a-222">Before you can create the first log backup, you must create a full backup, such as a database backup or the first in a set of file backups.</span></span> <span data-ttu-id="36e4a-223">僅使用檔案備份來還原資料庫，可能會讓情況變得很複雜。</span><span class="sxs-lookup"><span data-stu-id="36e4a-223">Restoring a database by using only file backups can become complex.</span></span> <span data-ttu-id="36e4a-224">因此，我們建議您盡可能先從完整資料庫備份開始。</span><span class="sxs-lookup"><span data-stu-id="36e4a-224">Therefore, we recommend that you start with a full database backup when you can.</span></span> <span data-ttu-id="36e4a-225">之後，則需要定期備份交易記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-225">Thereafter, backing up the transaction log regularly is necessary.</span></span> <span data-ttu-id="36e4a-226">這不僅是要降低工作損失的風險，也是為了在必要時可以截斷交易記錄。</span><span class="sxs-lookup"><span data-stu-id="36e4a-226">This not only minimizes work-loss exposure but also enables truncation of the transaction log.</span></span> <span data-ttu-id="36e4a-227">交易記錄通常在每個傳統記錄備份之後截斷。</span><span class="sxs-lookup"><span data-stu-id="36e4a-227">Typically, the transaction log is truncated after every conventional log backup.</span></span>  
  
 <span data-ttu-id="36e4a-228">我們建議您經常進行充分的記錄備份來支援商務需求，特別是您對工作損失 (例如可能因損壞的記錄磁碟機而引起) 的耐受性。</span><span class="sxs-lookup"><span data-stu-id="36e4a-228">We recommend taking frequent enough log backups to support your business requirements, specifically your tolerance for work loss such as might be caused by a damaged log drive.</span></span> <span data-ttu-id="36e4a-229">進行記錄備份的頻率如何才適當，視您在工作損失風險的耐受性，與儲存、管理及可能還原記錄備份的容量之間所做的取捨而定。</span><span class="sxs-lookup"><span data-stu-id="36e4a-229">The appropriate frequency for taking log backups depends on your tolerance for work-loss exposure balanced by how many log backups you can store, manage, and, potentially, restore.</span></span> <span data-ttu-id="36e4a-230">每 15 到 30 分鐘進行一次記錄備份可能就足夠了。</span><span class="sxs-lookup"><span data-stu-id="36e4a-230">Taking a log backup every 15 to 30 minutes might be enough.</span></span> <span data-ttu-id="36e4a-231">如果您的業務需要將工作損失風險減至最低，請考慮更頻繁地進行記錄備份。</span><span class="sxs-lookup"><span data-stu-id="36e4a-231">If your business requires that you minimize work-loss exposure, consider taking log backups more frequently.</span></span> <span data-ttu-id="36e4a-232">較頻繁的記錄備份還會帶來另一優點，就是增加記錄截斷的頻率，從而產生較小的記錄檔。</span><span class="sxs-lookup"><span data-stu-id="36e4a-232">More frequent log backups have the added advantage of increasing the frequency of log truncation, resulting in smaller log files.</span></span>  
  
 <span data-ttu-id="36e4a-233">若要限制您需要還原的記錄備份數目，定期備份資料是基本作業。</span><span class="sxs-lookup"><span data-stu-id="36e4a-233">To limit the number of log backups that you need to restore, it is essential to routinely back up your data.</span></span> <span data-ttu-id="36e4a-234">例如，您可能會排程每週的完整資料庫備份和每日的差異資料庫備份。</span><span class="sxs-lookup"><span data-stu-id="36e4a-234">For example, you might schedule a weekly full database backup and daily differential database backups.</span></span>  
  
### <a name="the-log-chain"></a><span data-ttu-id="36e4a-235">記錄鏈結</span><span class="sxs-lookup"><span data-stu-id="36e4a-235">The Log Chain</span></span>  

 <span data-ttu-id="36e4a-236">連續的記錄備份順序稱為「記錄檔*鏈*」。</span><span class="sxs-lookup"><span data-stu-id="36e4a-236">A continuous sequence of log backups is called a *log chain*.</span></span> <span data-ttu-id="36e4a-237">記錄鏈結以資料庫的完整備份開始。</span><span class="sxs-lookup"><span data-stu-id="36e4a-237">A log chain starts with a full backup of the database.</span></span> <span data-ttu-id="36e4a-238">通常，只有在首次備份資料庫，或將簡單復原模式切換為完整或大量記錄復原模式之後，才會開始新的記錄鏈結。</span><span class="sxs-lookup"><span data-stu-id="36e4a-238">Usually, a new log chain is only started when the database is backed up for the first time or after the recovery model is switched from simple recovery to full or bulk-logged recovery.</span></span> <span data-ttu-id="36e4a-239">除非您在建立完整資料庫備份時選擇覆寫現有的備份組，否則現有的記錄鏈結會維持不變。</span><span class="sxs-lookup"><span data-stu-id="36e4a-239">Unless you choose to overwrite existing backup sets when creating a full database backup, the existing log chain remains intact.</span></span> <span data-ttu-id="36e4a-240">透過維持不變的記錄鏈結，您可以從媒體集中的任何完整資料庫備份還原資料庫，後面接著所有後續的記錄備份，直到復原點為止。</span><span class="sxs-lookup"><span data-stu-id="36e4a-240">With the log chain intact, you can restore your database from any full database backup in the media set, followed by all subsequent log backups up through your recovery point.</span></span> <span data-ttu-id="36e4a-241">復原點可能是上一個記錄備份的結尾，或是任何記錄備份中的特定復原點。</span><span class="sxs-lookup"><span data-stu-id="36e4a-241">The recovery point could be the end of the last log backup or a specific recovery point in any of the log backups.</span></span> <span data-ttu-id="36e4a-242">如需詳細資訊，請參閱[套用交易記錄備份 &#40;SQL Server&#41;](../relational-databases/backup-restore/transaction-log-backups-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-242">For more information, see [Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/transaction-log-backups-sql-server.md).</span></span>  
  
 <span data-ttu-id="36e4a-243">若要將資料庫還原到失敗點，必須有完整的記錄鏈結。</span><span class="sxs-lookup"><span data-stu-id="36e4a-243">To restore a database up to the point of failure, the log chain must be intact.</span></span> <span data-ttu-id="36e4a-244">也就是說，必須將交易記錄備份的順序不間斷地延伸到失敗點。</span><span class="sxs-lookup"><span data-stu-id="36e4a-244">That is, an unbroken sequence of transaction log backups must extend up to the point of failure.</span></span> <span data-ttu-id="36e4a-245">這個記錄順序必須從何處開始視您要還原的資料備份類型而定：資料庫、部分或檔案。</span><span class="sxs-lookup"><span data-stu-id="36e4a-245">Where this sequence of log must start depends on the type of data backups you are restoring: database, partial, or file.</span></span> <span data-ttu-id="36e4a-246">如果是資料庫或部分備份，記錄備份的順序必須從資料庫或部分備份的結尾延伸。</span><span class="sxs-lookup"><span data-stu-id="36e4a-246">For a database or partial backup, the sequence of log backups must extend from the end of a database or partial backup.</span></span> <span data-ttu-id="36e4a-247">如果是檔案備份組，記錄備份的順序則必須從完整檔案備份組的起始來延伸。</span><span class="sxs-lookup"><span data-stu-id="36e4a-247">For a set of file backups, the sequence of log backups must extend from the start of a full set of file backups.</span></span> <span data-ttu-id="36e4a-248">如需詳細資訊，請參閱[套用交易記錄備份 &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-248">For more information, see [Apply Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md).</span></span>  
  
### <a name="restore-log-backups"></a><span data-ttu-id="36e4a-249">還原記錄備份</span><span class="sxs-lookup"><span data-stu-id="36e4a-249">Restore Log Backups</span></span>  

 <span data-ttu-id="36e4a-250">還原記錄備份會向前復原交易記錄中所記錄的變更，以重新建立開始進行記錄備份作業時的正確資料庫狀態。</span><span class="sxs-lookup"><span data-stu-id="36e4a-250">Restoring a log backup rolls forward the changes that were recorded in the transaction log to re-create the exact state of the database at the time the log backup operation started.</span></span> <span data-ttu-id="36e4a-251">還原資料庫時，您必須還原在所要的完整資料庫備份之後建立的記錄備份，或者必須從您所還原之第一個檔案備份的起始開始還原記錄備份。</span><span class="sxs-lookup"><span data-stu-id="36e4a-251">When you restore a database, you will have to restore the log backups that were created after the full database backup that you restore, or from the start of the first file backup that you restore.</span></span> <span data-ttu-id="36e4a-252">一般而言，還原最近的資料或差異備份之後，您必須還原一連串的記錄備份，直到復原點為止。</span><span class="sxs-lookup"><span data-stu-id="36e4a-252">Typically, after you restore the most recent data or differential backup, you must restore a series of log backups until you reach your recovery point.</span></span> <span data-ttu-id="36e4a-253">然後再復原資料庫。</span><span class="sxs-lookup"><span data-stu-id="36e4a-253">Then, you recover the database.</span></span> <span data-ttu-id="36e4a-254">這樣會回復所有在復原啟動時未完成的交易，並使資料庫回到線上。</span><span class="sxs-lookup"><span data-stu-id="36e4a-254">This rolls back all transactions that were incomplete when the recovery started and brings the database online.</span></span> <span data-ttu-id="36e4a-255">復原資料庫之後，您不能再還原其他備份。</span><span class="sxs-lookup"><span data-stu-id="36e4a-255">After the database has been recovered, you cannot restore any more backups.</span></span> <span data-ttu-id="36e4a-256">如需詳細資訊，請參閱[套用交易記錄備份 &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="36e4a-256">For more information, see [Apply Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md).</span></span>  
  
## <a name="additional-reading"></a><span data-ttu-id="36e4a-257">其他閱讀資料</span><span class="sxs-lookup"><span data-stu-id="36e4a-257">Additional Reading</span></span>  

 <span data-ttu-id="36e4a-258">建議您閱覽下列文章和書籍，了解交易記錄的其他相關資訊。</span><span class="sxs-lookup"><span data-stu-id="36e4a-258">We recommend the following articles and books for additional information about the transaction log.</span></span>  
  
 [<span data-ttu-id="36e4a-259">＜了解 SQL Server 中的記錄和復原＞，作者 Paul Randall</span><span class="sxs-lookup"><span data-stu-id="36e4a-259">Understanding Logging and Recovery in SQL Server by Paul Randall</span></span>](https://technet.microsoft.com/magazine/2009.02.logging.aspx)  
  
 [<span data-ttu-id="36e4a-260">《SQL Server Transaction Log Management》，作者 Tony Davis 和 Gail Shaw</span><span class="sxs-lookup"><span data-stu-id="36e4a-260">SQL Server Transaction Log Management by Tony Davis and Gail Shaw</span></span>](http://www.simple-talk.com/books/sql-books/sql-server-transaction-log-management-by-tony-davis-and-gail-shaw/)  
  
  
