---
title: 記憶體優化資料表中的交易 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 2cd07d26-a1f1-4034-8d6f-f196eed1b763
author: stevestein
ms.author: sstein
ms.openlocfilehash: bc9109c7243e609e5ddd820b61386183761167bf
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87709833"
---
# <a name="transactions-in-memory-optimized-tables"></a><span data-ttu-id="74c8d-102">記憶體最佳化的資料表中的交易</span><span class="sxs-lookup"><span data-stu-id="74c8d-102">Transactions in Memory-Optimized Tables</span></span>
  <span data-ttu-id="74c8d-103">以磁碟為基礎之資料表的資料列版本設定 (使用 SNAPSHOT 隔離或 READ_COMMITTED_SNAPSHOT) 會提供某種形式的開放式並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="74c8d-103">Row versioning on disk-based tables (using SNAPSHOT isolation or READ_COMMITTED_SNAPSHOT) provides a form of optimistic concurrency control.</span></span> <span data-ttu-id="74c8d-104">讀取器和寫入器不會封鎖彼此。</span><span class="sxs-lookup"><span data-stu-id="74c8d-104">Readers and writers do not block each other.</span></span> <span data-ttu-id="74c8d-105">在記憶體最佳化的資料表中，寫入器不會封鎖寫入器。</span><span class="sxs-lookup"><span data-stu-id="74c8d-105">With memory-optimized tables, writers do not block writers.</span></span> <span data-ttu-id="74c8d-106">如果在磁碟資料表上使用資料列版本設定，一筆交易會鎖定資料列，而嘗試更新此資料列的並行交易會遭封鎖。</span><span class="sxs-lookup"><span data-stu-id="74c8d-106">With row versioning on disk-based tables, one transaction locks the row and concurrent transactions attempting to update the row are blocked.</span></span> <span data-ttu-id="74c8d-107">在記憶體最佳化資料表中，不會有任何鎖定。</span><span class="sxs-lookup"><span data-stu-id="74c8d-107">There is no locking with memory-optimized tables.</span></span> <span data-ttu-id="74c8d-108">而是當有兩筆交易嘗試更新相同資料列時，將會發生寫入/寫入衝突 (錯誤 41302)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-108">Instead, if two transactions attempt to update the same row, a write/write conflict (error 41302) will occur.</span></span>

 <span data-ttu-id="74c8d-109">記憶體最佳化的資料表允許較高隔離等級 (REPEATABLE READ 和 SERIALIZABLE) 的開放式並行存取控制，這點不同於以磁碟為基礎的資料表。</span><span class="sxs-lookup"><span data-stu-id="74c8d-109">Unlike disk-based tables, memory-optimized tables allow optimistic concurrency control with the higher isolation levels, REPEATABLE READ and SERIALIZABLE.</span></span> <span data-ttu-id="74c8d-110">系統不會鎖定以強制執行隔離等級。</span><span class="sxs-lookup"><span data-stu-id="74c8d-110">Locks are not taken to enforce the isolation levels.</span></span> <span data-ttu-id="74c8d-111">不過，交易結束時將會進行驗證，以確保可重複的讀取或序列化能力假設。</span><span class="sxs-lookup"><span data-stu-id="74c8d-111">Instead, at the end of the transaction validation ensures the repeatable read or serializability assumptions.</span></span> <span data-ttu-id="74c8d-112">如果違反假設，就會終止交易。</span><span class="sxs-lookup"><span data-stu-id="74c8d-112">If the assumptions are violated, the transaction is terminated.</span></span> <span data-ttu-id="74c8d-113">如需詳細資訊，請參閱 [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-113">For more information, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>

 <span data-ttu-id="74c8d-114">記憶體最佳化資料表的重要交易語意為：</span><span class="sxs-lookup"><span data-stu-id="74c8d-114">The important transaction semantics for memory-optimized tables are:</span></span>

-   <span data-ttu-id="74c8d-115">多重版本設定</span><span class="sxs-lookup"><span data-stu-id="74c8d-115">Multi-versioning</span></span>

-   <span data-ttu-id="74c8d-116">以快照集為基礎的交易隔離</span><span class="sxs-lookup"><span data-stu-id="74c8d-116">Snapshot-based transaction isolation</span></span>

-   <span data-ttu-id="74c8d-117">開放式</span><span class="sxs-lookup"><span data-stu-id="74c8d-117">Optimistic</span></span>

-   <span data-ttu-id="74c8d-118">衝突偵測</span><span class="sxs-lookup"><span data-stu-id="74c8d-118">Conflict detection</span></span>

 <span data-ttu-id="74c8d-119">以下章節將說明每個語意。</span><span class="sxs-lookup"><span data-stu-id="74c8d-119">Each of these semantics is explained in the following sections.</span></span>

## <a name="multi-versioning-in-memory-optimized-tables"></a><span data-ttu-id="74c8d-120">記憶體最佳化的資料表中的多重版本設定</span><span class="sxs-lookup"><span data-stu-id="74c8d-120">Multi-Versioning in Memory-Optimized Tables</span></span>
 <span data-ttu-id="74c8d-121">記憶體最佳化的資料表中的資料列可以有不同的版本。</span><span class="sxs-lookup"><span data-stu-id="74c8d-121">Rows in memory-optimized tables can have different versions.</span></span> <span data-ttu-id="74c8d-122">並行交易可能會存取相同資料列的不同版本。</span><span class="sxs-lookup"><span data-stu-id="74c8d-122">Concurrent transactions access potentially different versions of the same row.</span></span>

 <span data-ttu-id="74c8d-123">記憶體最佳化資料表資料是以版本為基礎。</span><span class="sxs-lookup"><span data-stu-id="74c8d-123">Memory-optimized table data is version-based.</span></span> <span data-ttu-id="74c8d-124">對於任何資料列，可能會有不同的資料列版本在不同的時間點有效。</span><span class="sxs-lookup"><span data-stu-id="74c8d-124">For any row there may be different row versions that are valid at different points in time.</span></span> <span data-ttu-id="74c8d-125">當 READ_COMMITTED_SNAPSHOT 或 ALLOW_SNAPSHOT_ISOLATION 設為 ON 時，磁碟資料表會維護不同的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="74c8d-125">Disk-based tables maintain different row versions when READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION is ON.</span></span> <span data-ttu-id="74c8d-126">記憶體最佳化資料表會維護不同的資料列版本，即使 READ_COMMITTED_SNAPSHOT 和 ALLOW_SNAPSHOT_ISOLATION 設為 OFF 也一樣。</span><span class="sxs-lookup"><span data-stu-id="74c8d-126">Memory-optimized tables maintain different row versions, even if READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION are OFF.</span></span> <span data-ttu-id="74c8d-127">記憶體最佳化的資料表的資料列版本不是在 tempdb 中維護，</span><span class="sxs-lookup"><span data-stu-id="74c8d-127">The row versions of memory-optimized tables are not maintained in tempdb.</span></span> <span data-ttu-id="74c8d-128">而是以內嵌方式維護資料列版本 (當做在記憶體中儲存資料列之記憶體最佳化資料結構的一部分)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-128">Instead, the row versions are maintained in-line, as part of the memory-optimized data structures storing the rows in memory.</span></span>

## <a name="snapshot-based-transaction-isolation-for-memory-optimized-tables"></a><span data-ttu-id="74c8d-129">記憶體最佳化的資料表所適用的快照集交易隔離</span><span class="sxs-lookup"><span data-stu-id="74c8d-129">Snapshot-Based Transaction Isolation for Memory-Optimized Tables</span></span>
 <span data-ttu-id="74c8d-130">單一交易中的所有作業都會使用記憶體最佳化資料表的相同交易一致性快照集。</span><span class="sxs-lookup"><span data-stu-id="74c8d-130">All operations in a single transaction use the same transactionally-consistent snapshot of the memory-optimized tables.</span></span> <span data-ttu-id="74c8d-131">記憶體最佳化的資料表的所有交易隔離都是以快照集為基礎。</span><span class="sxs-lookup"><span data-stu-id="74c8d-131">All transaction isolation for memory-optimized tables is snapshot-based.</span></span> <span data-ttu-id="74c8d-132">例如，使用可序列化隔離等級存取記憶體最佳化的資料表的交易，都將會在相同的交易一致性快照集上執行所有作業。</span><span class="sxs-lookup"><span data-stu-id="74c8d-132">For example, a transaction using the serializable isolation level to access memory-optimized tables will perform all operations on the same transactionally consistent snapshot.</span></span>

 <span data-ttu-id="74c8d-133">存取記憶體最佳化的資料表的交易會使用此資料列版本設定來取得資料表中資料列的交易一致性快照集。</span><span class="sxs-lookup"><span data-stu-id="74c8d-133">Transactions that access memory-optimized tables use this row versioning to obtain a transactionally consistent snapshot of the rows in the tables.</span></span> <span data-ttu-id="74c8d-134">交易中任何陳述式所讀取的資料，都是交易開始時就存在之資料的交易一致性版本。</span><span class="sxs-lookup"><span data-stu-id="74c8d-134">The data read by any statement in the transaction will be the transactionally consistent version of the data that existed at the time the transaction started.</span></span> <span data-ttu-id="74c8d-135">因此，目前交易中的陳述式看不到並行執行之交易所做的任何修改。</span><span class="sxs-lookup"><span data-stu-id="74c8d-135">Therefore, any modifications made by concurrently running transactions are not visible to statements in the current transaction.</span></span>

## <a name="optimistic-concurrency-control-for-memory-optimized-tables"></a><span data-ttu-id="74c8d-136">記憶體最佳化的資料表的開放式並行存取控制</span><span class="sxs-lookup"><span data-stu-id="74c8d-136">Optimistic Concurrency Control for Memory-Optimized Tables</span></span>
 <span data-ttu-id="74c8d-137">衝突和失敗的狀況很少見，而且記憶體最佳化資料表的交易會假設與並行交易沒有衝突且作業順利完成。</span><span class="sxs-lookup"><span data-stu-id="74c8d-137">Conflicts and failures are rare and transactions on memory-optimized tables assume there are no conflicts with concurrent transactions and operations succeed.</span></span> <span data-ttu-id="74c8d-138">交易不會對記憶體最佳化資料表進行鎖定或閂鎖以保證交易隔離。</span><span class="sxs-lookup"><span data-stu-id="74c8d-138">Transactions do not take locks or latches on memory-optimized table to guarantee transaction isolation.</span></span> <span data-ttu-id="74c8d-139">寫入器不會封鎖讀取器。</span><span class="sxs-lookup"><span data-stu-id="74c8d-139">Writers do not block readers.</span></span> <span data-ttu-id="74c8d-140">寫入器不會封鎖寫入器。</span><span class="sxs-lookup"><span data-stu-id="74c8d-140">Writers do not block writers.</span></span> <span data-ttu-id="74c8d-141">但是，交易會在開放式假設之下繼續，在這個假設之下不會與其他交易發生衝突。</span><span class="sxs-lookup"><span data-stu-id="74c8d-141">Instead, transactions proceed under the (optimistic) assumption that there will be no conflicts with other transactions.</span></span> <span data-ttu-id="74c8d-142">不使用鎖定和閂鎖，而且不等候其他交易完成處理相同的資料列可改善效能。</span><span class="sxs-lookup"><span data-stu-id="74c8d-142">Not using locks and latches and not waiting for other transactions to finish processing the same rows improves performance.</span></span>

 <span data-ttu-id="74c8d-143">此外，如果某筆交易 (TxA) 讀取的資料列已由另一筆交易 (TxB) 插入或修改，而且正在認可中，它會樂觀地假設該另一筆交易會認可，而不是等候認可發生。</span><span class="sxs-lookup"><span data-stu-id="74c8d-143">In addition, if a transaction (TxA) reads rows that have been inserted or modified by another transaction (TxB) that is in the process of committing, it will optimistically assume the other transaction will commit rather than wait for the commit to occur.</span></span> <span data-ttu-id="74c8d-144">在此情況下，交易 TxA 會相依於交易 TxB 的認可。</span><span class="sxs-lookup"><span data-stu-id="74c8d-144">In this case, transaction TxA will take a commit dependency on transaction TxB.</span></span>

## <a name="conflict-detection-validation-and-commit-dependency-checks"></a><span data-ttu-id="74c8d-145">衝突偵測、驗證和認可相依性檢查</span><span class="sxs-lookup"><span data-stu-id="74c8d-145">Conflict Detection, Validation, and Commit Dependency Checks</span></span>
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="74c8d-146">會偵測並行交易之間的衝突以及隔離等級違規，而且將會終止其中一個衝突的交易。</span><span class="sxs-lookup"><span data-stu-id="74c8d-146">detects conflicts between concurrent transactions, as well as isolation level violations, and will doom one of the conflicting transactions.</span></span> <span data-ttu-id="74c8d-147">此交易將必須重試。</span><span class="sxs-lookup"><span data-stu-id="74c8d-147">This transaction will need to be retried.</span></span> <span data-ttu-id="74c8d-148"> (需詳細資訊，請參閱[記憶體優化資料表上交易的重試邏輯方針](../relational-databases/in-memory-oltp/memory-optimized-tables.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="74c8d-148">(For more information, see [Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).)</span></span>

 <span data-ttu-id="74c8d-149">系統會樂觀地假設交易隔離沒有任何衝突和違規。</span><span class="sxs-lookup"><span data-stu-id="74c8d-149">The system optimistically assumes there are no conflicts and no violations of transaction isolation.</span></span> <span data-ttu-id="74c8d-150">如果發生的任何衝突可能導致資料庫的不一致或可能違反交易隔離，系統會偵測到這些衝突，並且終止交易。</span><span class="sxs-lookup"><span data-stu-id="74c8d-150">If any conflicts occur that may cause inconsistencies in the database or that may violate transaction isolation, these conflicts are detected, and the transaction is terminated.</span></span>

 <span data-ttu-id="74c8d-151">如果系統偵測到衝突，交易將會終止，而且用戶端必須重試。</span><span class="sxs-lookup"><span data-stu-id="74c8d-151">If a conflict is detected, the transaction is terminated and the client needs to retry.</span></span>

 <span data-ttu-id="74c8d-152">下表摘要說明存取記憶體最佳化資料表之交易的錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="74c8d-152">The following table summarizes the error conditions for transactions that accesses memory-optimized tables.</span></span>

### <a name="error-conditions-for-transactions-accessing-memory-optimized-tables"></a><span data-ttu-id="74c8d-153">存取記憶體最佳化的資料表之交易的錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="74c8d-153">Error conditions for transactions accessing memory-optimized tables.</span></span>

|<span data-ttu-id="74c8d-154">錯誤</span><span class="sxs-lookup"><span data-stu-id="74c8d-154">Error</span></span>|<span data-ttu-id="74c8d-155">案例</span><span class="sxs-lookup"><span data-stu-id="74c8d-155">Scenario</span></span>|
|-----------|--------------|
|<span data-ttu-id="74c8d-156">寫入衝突。</span><span class="sxs-lookup"><span data-stu-id="74c8d-156">Write conflict.</span></span> <span data-ttu-id="74c8d-157">嘗試更新交易開始之後已更新的記錄。</span><span class="sxs-lookup"><span data-stu-id="74c8d-157">Attempting to update a record that has been updated since the transaction started.</span></span>|<span data-ttu-id="74c8d-158">針對並行交易已更新或刪除的資料列進行 UPDATE 或 DELETE 作業。</span><span class="sxs-lookup"><span data-stu-id="74c8d-158">UPDATE or DELETE a row that has been updated or deleted by a concurrent transaction.</span></span>|
|<span data-ttu-id="74c8d-159">可重複的讀取驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="74c8d-159">Repeatable read validation failure.</span></span>|<span data-ttu-id="74c8d-160">交易所讀取的資料列從交易開始就已經變更 (更新或刪除)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-160">A row that was read by the transaction has changed (updated or deleted) since the transaction started.</span></span> <span data-ttu-id="74c8d-161">可重複的讀取驗證通常是在使用 REPEATABLE READ 和 SERIALIZABLE 交易隔離等級時進行。</span><span class="sxs-lookup"><span data-stu-id="74c8d-161">Repeatable read validation is typically occurs when using REPEATABLE READ and SERIALIZABLE transaction isolation levels.</span></span>|
|<span data-ttu-id="74c8d-162">可序列化的驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="74c8d-162">Serializable validation failure.</span></span>|<span data-ttu-id="74c8d-163">從交易開始，就已經在交易中其中一個掃描範圍內插入新的 (虛設) 資料列。</span><span class="sxs-lookup"><span data-stu-id="74c8d-163">A new (phantom) row has been inserted in one of the scan ranges in the transaction, since the transaction started.</span></span> <span data-ttu-id="74c8d-164">原本在交易開始之前如果資料庫已經認可資料列，交易就已經看得到此資料列。</span><span class="sxs-lookup"><span data-stu-id="74c8d-164">The row would have been visible to the transaction if the row had been committed to the database before the transaction started.</span></span> <span data-ttu-id="74c8d-165">SERIALIZABLE 驗證通常是在使用 SERIALIZABLE 隔離及驗證 PRIMARY KEY 條件約束時進行。</span><span class="sxs-lookup"><span data-stu-id="74c8d-165">SERIALIZABLE validation typically occurs when using SERIALIZABLE isolation and validating PRIMARY KEY constraints.</span></span>|
|<span data-ttu-id="74c8d-166">認可相依性失敗。</span><span class="sxs-lookup"><span data-stu-id="74c8d-166">Commit dependency failure.</span></span>|<span data-ttu-id="74c8d-167">此交易相依於另一筆交易，而後者認可失敗，原因是因為此資料表中的其中一個失敗狀況、發生記憶體不足的情況，或是未能認可到交易記錄。</span><span class="sxs-lookup"><span data-stu-id="74c8d-167">The transaction took a dependency on another transaction that failed to commit, either due to one of the failures in this table, an out-of-memory condition, or due to failure to commit to the transaction log.</span></span> <span data-ttu-id="74c8d-168">讀取/寫入交易和唯讀交易都會發生這種失敗狀況。</span><span class="sxs-lookup"><span data-stu-id="74c8d-168">This failure can occur with both read/write and read-only transactions.</span></span>|

### <a name="transaction-lifetime"></a><span data-ttu-id="74c8d-169">交易存留期間</span><span class="sxs-lookup"><span data-stu-id="74c8d-169">Transaction Lifetime</span></span>
 <span data-ttu-id="74c8d-170">上表所提及的失敗可能會發生在交易期間的不同時間點。</span><span class="sxs-lookup"><span data-stu-id="74c8d-170">The failures mentioned in the previous table can occur at different points during a transaction.</span></span> <span data-ttu-id="74c8d-171">下圖說明存取記憶體最佳化的資料表的交易階段。</span><span class="sxs-lookup"><span data-stu-id="74c8d-171">The following figure illustrates the phases of a transaction that accesses memory-optimized tables.</span></span>

 <span data-ttu-id="74c8d-172">![交易的存留期間。](../../2014/database-engine/media/hekaton-transactions.gif "交易的存留期間。")</span><span class="sxs-lookup"><span data-stu-id="74c8d-172">![Lifetime of a transaction.](../../2014/database-engine/media/hekaton-transactions.gif "Lifetime of a transaction.")</span></span>
<span data-ttu-id="74c8d-173">存取記憶體最佳化的資料表的交易存留期間。</span><span class="sxs-lookup"><span data-stu-id="74c8d-173">Lifetime of a transaction that accesses memory-optimized tables.</span></span>

#### <a name="regular-processing"></a><span data-ttu-id="74c8d-174">正常處理</span><span class="sxs-lookup"><span data-stu-id="74c8d-174">Regular Processing</span></span>
 <span data-ttu-id="74c8d-175">在這個階段會執行使用者發出的 [!INCLUDE[tsql](../includes/tsql-md.md)] 陳述式。</span><span class="sxs-lookup"><span data-stu-id="74c8d-175">During this phase, the user-issued [!INCLUDE[tsql](../includes/tsql-md.md)] statements are executed.</span></span> <span data-ttu-id="74c8d-176">從資料表讀取資料列，而且新的資料列版本會寫入資料庫。</span><span class="sxs-lookup"><span data-stu-id="74c8d-176">Rows are read from the tables, and new row versions are written to the database.</span></span> <span data-ttu-id="74c8d-177">此交易會與所有其他並行交易隔離。</span><span class="sxs-lookup"><span data-stu-id="74c8d-177">The transaction is isolated from all other concurrent transactions.</span></span> <span data-ttu-id="74c8d-178">此交易會使用從交易開始就存在的記憶體最佳化資料表快照集。</span><span class="sxs-lookup"><span data-stu-id="74c8d-178">The transaction uses the snapshot of the memory-optimized tables that exists at the start of the transaction.</span></span>

 <span data-ttu-id="74c8d-179">其他交易還看不到這個交易階段的資料表寫入，但是有一個例外狀況：其他交易中的更新和刪除作業可看到資料列更新和刪除，以便偵測寫入衝突。</span><span class="sxs-lookup"><span data-stu-id="74c8d-179">Writes to the tables in this phase of the transaction are not yet visible to other transactions, with one exception: row updates and deletes are visible to update and delete operations in other transactions, in order to detect write conflicts.</span></span>

 <span data-ttu-id="74c8d-180">如果更新或刪除作業從交易的邏輯開始之後就看到資料列已更新或刪除，作業會失敗並出現錯誤 41302。</span><span class="sxs-lookup"><span data-stu-id="74c8d-180">If an update or delete operation sees that a row has been updated or deleted since the logical start of the transaction, the operation will fail with error 41302.</span></span> <span data-ttu-id="74c8d-181">錯誤 41302 的訊息為：「目前交易嘗試更新自從此交易啟動以來已經更新的資料表 X 記錄。</span><span class="sxs-lookup"><span data-stu-id="74c8d-181">The message for error 41302 is "The current transaction attempted to update a record in table X that has been updated since this transaction started.</span></span> <span data-ttu-id="74c8d-182">交易已中止。」</span><span class="sxs-lookup"><span data-stu-id="74c8d-182">The transaction was aborted."</span></span>

 <span data-ttu-id="74c8d-183">此錯誤會終止交易 (即便 XACT_ABORT 為 OFF)，這表示交易將在使用者工作階段結束時回復。</span><span class="sxs-lookup"><span data-stu-id="74c8d-183">This error dooms the transaction (even if XACT_ABORT is OFF), meaning that the transaction will be rolled back when the user session ends.</span></span> <span data-ttu-id="74c8d-184">無法認可注定失敗的交易，且僅支援不寫入記錄及不存取記憶體最佳化資料表的讀取作業。</span><span class="sxs-lookup"><span data-stu-id="74c8d-184">Doomed transactions cannot be committed and only support read operations that do not write to the log and do not access memory-optimized tables.</span></span>

#####  <a name="commit-dependencies"></a><a name="cd"></a><span data-ttu-id="74c8d-185">認可相依性</span><span class="sxs-lookup"><span data-stu-id="74c8d-185">Commit Dependencies</span></span>
 <span data-ttu-id="74c8d-186">在正常處理期間，交易可讀取其他交易在驗證或認可階段寫入但是尚未認可的資料列。</span><span class="sxs-lookup"><span data-stu-id="74c8d-186">During regular processing, a transaction can read rows written by other transactions that are in the validation or commit phase, but have not yet committed.</span></span> <span data-ttu-id="74c8d-187">這些資料列是可見的，因為在驗證階段開始就已經指派交易的邏輯結束時間。</span><span class="sxs-lookup"><span data-stu-id="74c8d-187">The rows are visible because the logical end time of the transactions has been assigned at the start of the validation phase.</span></span>

 <span data-ttu-id="74c8d-188">如果交易讀取這類未認可的資料列，它將會相依於該筆交易的認可。</span><span class="sxs-lookup"><span data-stu-id="74c8d-188">If a transaction reads such uncommitted rows, it will take a commit dependency on that transaction.</span></span> <span data-ttu-id="74c8d-189">這有兩個主要的含意：</span><span class="sxs-lookup"><span data-stu-id="74c8d-189">This has two main implications:</span></span>

-   <span data-ttu-id="74c8d-190">交易在它所相依的交易認可之前無法認可。</span><span class="sxs-lookup"><span data-stu-id="74c8d-190">A transaction cannot commit until the transactions it depends on have committed.</span></span> <span data-ttu-id="74c8d-191">換句話說，除非所有相依項目都已清除，否則它無法進入認可階段。</span><span class="sxs-lookup"><span data-stu-id="74c8d-191">In other words, it cannot enter the commit phase, until all dependencies have cleared.</span></span>

-   <span data-ttu-id="74c8d-192">此外，除非所有相依項目都已清除，否則結果集不會傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="74c8d-192">In addition, result sets are not returned to the client until all dependencies have cleared.</span></span> <span data-ttu-id="74c8d-193">這樣可防止用戶端觀察未認可的資料。</span><span class="sxs-lookup"><span data-stu-id="74c8d-193">This prevents the client from observing uncommitted data.</span></span>

 <span data-ttu-id="74c8d-194">如果有任何相依交易無法認可，就表示發生認可相依性失敗。</span><span class="sxs-lookup"><span data-stu-id="74c8d-194">If any of the dependent transactions fails to commit, there is a commit dependency failure.</span></span> <span data-ttu-id="74c8d-195">這表示交易將無法認可，並且出現錯誤 41301 (「目前交易具有相依性的先前交易已經中止，而且目前交易無法再認可。」)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-195">This means the transaction will fail to commit with error 41301 ("A previous transaction that the current transaction took a dependency on has aborted, and the current transaction can no longer commit.").</span></span>

#### <a name="validation-phase"></a><span data-ttu-id="74c8d-196">驗證階段</span><span class="sxs-lookup"><span data-stu-id="74c8d-196">Validation Phase</span></span>
 <span data-ttu-id="74c8d-197">在驗證階段，系統會驗證要求的交易隔離等級所需的假設在交易的邏輯開始和邏輯結束之間是否成立。</span><span class="sxs-lookup"><span data-stu-id="74c8d-197">During the validation phase, the system validates that the assumptions necessary for the requested transaction isolation level were true between the logical start and logical end of the transaction.</span></span>

 <span data-ttu-id="74c8d-198">在驗證階段開始，系統會指派邏輯結束時間給交易。</span><span class="sxs-lookup"><span data-stu-id="74c8d-198">At the start of the validation phase, the transaction is assigned a logical end time.</span></span> <span data-ttu-id="74c8d-199">其他交易會在邏輯結束時間看到資料庫中寫入的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="74c8d-199">The row versions written in the database become visible to other transactions at the logical end time.</span></span> <span data-ttu-id="74c8d-200">如需詳細資訊，請參閱[認可](#cd)相依性。</span><span class="sxs-lookup"><span data-stu-id="74c8d-200">For more information, see [Commit Dependencies](#cd).</span></span>

##### <a name="repeatable-read-validation"></a><span data-ttu-id="74c8d-201">可重複的讀取驗證</span><span class="sxs-lookup"><span data-stu-id="74c8d-201">Repeatable Read Validation</span></span>
 <span data-ttu-id="74c8d-202">如果交易的隔離等級是可重複讀取或可序列化的，或如果在可重複讀取或可序列化隔離下存取資料表 (如需詳細資訊，請參閱) 的[交易隔離等級](../../2014/database-engine/transaction-isolation-levels.md)中隔離個別作業一節，系統會驗證讀取是否可重複。</span><span class="sxs-lookup"><span data-stu-id="74c8d-202">If the isolation level of the transaction is REPEATABLE READ or SERIALIZABLE, or if tables are accessed under REPEATABLE READ or SERIALIZABLE isolation (for more information, see the section on Isolation of Individual Operations in [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)), the system validates that the reads are repeatable.</span></span> <span data-ttu-id="74c8d-203">這表示，它會驗證交易所讀取的資料列版本在交易的邏輯結束時間依然是有效的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="74c8d-203">This means it validates that the versions of the rows read by the transaction are still valid row versions at the logical end time of the transaction.</span></span>

 <span data-ttu-id="74c8d-204">如果有任何資料列已更新或變更，交易就無法認可而且會出現錯誤 41305 (「目前交易無法認可，因為可重複的讀取驗證失敗。」)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-204">If any of the rows have been updated or changed, the transaction fails to commit with error 41305 ("The current transaction failed to commit due to a repeatable read validation failure.").</span></span>

 <span data-ttu-id="74c8d-205">如果在插入、更新或刪除作業之後及交易認可之前卸除資料表，也會發生這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="74c8d-205">This error can also occur if a table is dropped after an insert, update, or delete operation and before the transaction commits.</span></span> <span data-ttu-id="74c8d-206">這只適用於原生編譯預存程序中的插入、更新或刪除作業。</span><span class="sxs-lookup"><span data-stu-id="74c8d-206">This applies only to insert, update, or delete operations in natively compiled stored procedures.</span></span> <span data-ttu-id="74c8d-207">透過解譯的 [!INCLUDE[tsql](../includes/tsql-md.md)] 執行的這類寫入作業會造成 DROP TABLE 陳述式封鎖並且等候到交易認可為止。</span><span class="sxs-lookup"><span data-stu-id="74c8d-207">Such write operations performed through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] cause the DROP TABLE statement to block and wait until the transaction commits.</span></span>

##### <a name="serializable-validation"></a><span data-ttu-id="74c8d-208">可序列化的驗證</span><span class="sxs-lookup"><span data-stu-id="74c8d-208">Serializable Validation</span></span>
 <span data-ttu-id="74c8d-209">可序列化的驗證會在兩個情況下執行：</span><span class="sxs-lookup"><span data-stu-id="74c8d-209">Serializable validation is performed in two cases:</span></span>

-   <span data-ttu-id="74c8d-210">如果交易的隔離等級為 SERIALIZABLE 或是在 SERIALIZABLE 隔離之下存取資料表。</span><span class="sxs-lookup"><span data-stu-id="74c8d-210">If the isolation level of the transaction is SERIALIZABLE or tables are accessed under SERIALIZABLE isolation.</span></span>

-   <span data-ttu-id="74c8d-211">如果將資料列插入唯一的索引中，例如為 PRIMARY KEY 條件約束建立的索引。</span><span class="sxs-lookup"><span data-stu-id="74c8d-211">If rows are inserted in a unique index, such as the index created for a PRIMARY KEY constraint.</span></span> <span data-ttu-id="74c8d-212">系統會驗證並未同時插入有相同索引鍵的資料列。</span><span class="sxs-lookup"><span data-stu-id="74c8d-212">The system validates that no rows with the same key have been concurrently inserted.</span></span>

 <span data-ttu-id="74c8d-213">系統會驗證沒有任何虛設項目列已寫入資料庫。</span><span class="sxs-lookup"><span data-stu-id="74c8d-213">The system validates that no phantom rows have been written to the database.</span></span> <span data-ttu-id="74c8d-214">系統會評估交易所執行的讀取作業，以判斷在這些讀取作業的掃描範圍內並未插入任何新的資料列。</span><span class="sxs-lookup"><span data-stu-id="74c8d-214">The read operations performed by the transaction are evaluated to determine that no new rows were inserted in the scan ranges of these read operations.</span></span>

 <span data-ttu-id="74c8d-215">在唯一的索引中插入索引鍵包含了隱含的讀取作業，以判斷該索引鍵不是重複項目。</span><span class="sxs-lookup"><span data-stu-id="74c8d-215">Insertion of a key in a unique index includes an implicit read operation, to determine that the key is not a duplicate.</span></span> <span data-ttu-id="74c8d-216">唯一索引的可序列化驗證可確保萬一兩筆交易同時插入相同的索引鍵時，這些索引不能有重複。</span><span class="sxs-lookup"><span data-stu-id="74c8d-216">Serializable validation for unique indexes ensures these indexes cannot have duplicates in case two transactions concurrently insert the same key.</span></span>

 <span data-ttu-id="74c8d-217">如果偵測到虛設項目列，交易就無法認可而且會出現錯誤 41325 (「目前交易無法認可，因為可序列化的驗證失敗。」)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-217">If phantom rows are detected, the transaction fails to commit with error 41325 ("The current transaction failed to commit due to a serializable validation failure.").</span></span>

#### <a name="commit-processing"></a><span data-ttu-id="74c8d-218">認可處理</span><span class="sxs-lookup"><span data-stu-id="74c8d-218">Commit Processing</span></span>
 <span data-ttu-id="74c8d-219">如果驗證成功，而且所有交易相依項目都已清除，則交易會進入認可處理階段。</span><span class="sxs-lookup"><span data-stu-id="74c8d-219">If validation succeeds and all transaction dependencies clear, the transaction enters the commit processing phase.</span></span> <span data-ttu-id="74c8d-220">在這個階段，持久性資料表的變更會寫入記錄中，而且記錄會寫入磁碟，以確保持久性。</span><span class="sxs-lookup"><span data-stu-id="74c8d-220">During this phase the changes to durable tables are written to the log, and the log is written to disk, to ensure durability.</span></span> <span data-ttu-id="74c8d-221">一旦交易的記錄檔記錄寫入磁碟後，控制權就會傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="74c8d-221">Once the log record for the transaction has been written to disk, control is returned to the client.</span></span>

 <span data-ttu-id="74c8d-222">系統會清除此交易的所有認可相依項目，而正在等候此交易認可的所有交易都可以繼續。</span><span class="sxs-lookup"><span data-stu-id="74c8d-222">All commit dependencies on this transaction are cleared, and all transactions that had been waiting for this transaction to commit can proceed.</span></span>

## <a name="limitations"></a><span data-ttu-id="74c8d-223">限制</span><span class="sxs-lookup"><span data-stu-id="74c8d-223">Limitations</span></span>

-   <span data-ttu-id="74c8d-224">記憶體最佳化的資料表不支援跨資料庫的交易。</span><span class="sxs-lookup"><span data-stu-id="74c8d-224">Cross-database transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="74c8d-225">存取記憶體最佳化的資料表的每一筆交易都無法存取一個以上的資料庫，除非是 tempdb 的讀寫存取以及 master 系統資料庫的唯讀存取。</span><span class="sxs-lookup"><span data-stu-id="74c8d-225">Every transaction that accesses memory-optimized tables cannot access more than one database, with the exception of read-write access to tempdb and read-only access to the system database master.</span></span>

-   <span data-ttu-id="74c8d-226">記憶體最佳化的資料表不支援分散式交易。</span><span class="sxs-lookup"><span data-stu-id="74c8d-226">Distributed transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="74c8d-227">以 BEGIN DISTRIBUTED TRANSACTION 啟動的分散式交易無法存取記憶體最佳化的資料表。</span><span class="sxs-lookup"><span data-stu-id="74c8d-227">Distributed transactions started with BEGIN DISTRIBUTED TRANSACTION cannot access memory-optimized tables.</span></span>

-   <span data-ttu-id="74c8d-228">記憶體最佳化資料表不支援鎖定。</span><span class="sxs-lookup"><span data-stu-id="74c8d-228">Memory-optimized tables do not support locking.</span></span> <span data-ttu-id="74c8d-229">記憶體最佳化的資料表不支援透過鎖定提示的明確鎖定 (例如 TABLOCK、XLOCK 和 ROWLOCK)。</span><span class="sxs-lookup"><span data-stu-id="74c8d-229">Explicit locks through locking hints (such as TABLOCK, XLOCK, ROWLOCK) are not supported with memory-optimized tables.</span></span>

## <a name="see-also"></a><span data-ttu-id="74c8d-230">另請參閱</span><span class="sxs-lookup"><span data-stu-id="74c8d-230">See Also</span></span>
 [<span data-ttu-id="74c8d-231">了解經記憶體最佳化的資料表上的交易</span><span class="sxs-lookup"><span data-stu-id="74c8d-231">Understanding Transactions on Memory-Optimized Tables</span></span>](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md)


