---
title: 作用中次要資料庫：可讀取的次要複本 (Always On 可用性群組) |Microsoft Docs
ms.custom: ''
ms.date: 10/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: high-availability
ms.topic: conceptual
helpviewer_keywords:
- connection access to availability replicas
- Availability Groups [SQL Server], availability replicas
- Availability Groups [SQL Server], readable secondary replicas
- active secondary replicas [SQL Server], read-only access to
- readable secondary replicas
- Availability Groups [SQL Server], active secondary replicas
ms.assetid: 78f3f81a-066a-4fff-b023-7725ff874fdf
author: MashaMSFT
ms.author: mathoma
ms.openlocfilehash: 8b85704b8110eb84ea6f4c33dfa79694112c2328
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87607104"
---
# <a name="active-secondaries-readable-secondary-replicas-always-on-availability-groups"></a><span data-ttu-id="fdfb7-102">使用中次要：可讀取的次要複本 (AlwaysOn 可用性群組)</span><span class="sxs-lookup"><span data-stu-id="fdfb7-102">Active Secondaries: Readable Secondary Replicas (Always On Availability Groups)</span></span>
  <span data-ttu-id="fdfb7-103">[!INCLUDE[ssHADR](../../../includes/sshadr-md.md)] 使用中次要功能包含對一個或多個次要複本進行唯讀存取的支援 ( *「可讀取的次要複本」* (Readable Secondary Replicas))。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-103">The [!INCLUDE[ssHADR](../../../includes/sshadr-md.md)] active secondary capabilities include support for read-only access to one or more secondary replicas (*readable secondary replicas*).</span></span> <span data-ttu-id="fdfb7-104">可讀取的次要複本允許對其所有次要資料庫進行唯讀存取。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-104">A readable secondary replica allows read-only access to all its secondary databases.</span></span> <span data-ttu-id="fdfb7-105">但可讀取的次要資料庫並不會設定為唯讀。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-105">However, readable secondary databases are not set to read-only.</span></span> <span data-ttu-id="fdfb7-106">這些資料庫是動態的。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-106">They are dynamic.</span></span> <span data-ttu-id="fdfb7-107">隨著對應主要資料庫變更而衍生的給定次要資料庫變更，會套用至次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-107">A given secondary database changes as changes on the corresponding primary database are applied to the secondary database.</span></span> <span data-ttu-id="fdfb7-108">對於一般次要複本而言，次要資料庫中的資料 (包含持久記憶體最佳化資料表) 幾近即時。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-108">For a typical secondary replica, the data, including durable memory optimized tables, in the secondary databases is in near real time.</span></span> <span data-ttu-id="fdfb7-109">此外，全文檢索索引會與次要資料庫進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-109">Furthermore, full-text indexes are synchronized with the secondary databases.</span></span> <span data-ttu-id="fdfb7-110">在許多情況下，主要資料庫和對應次要資料庫之間的資料延遲只在幾秒鐘內。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-110">In many circumstances, data latency between a primary database and the corresponding secondary database is only a few seconds.</span></span>  
  
 <span data-ttu-id="fdfb7-111">主要資料庫中進行的安全性設定會保存到次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-111">Security settings that occur in the primary databases are persisted to the secondary databases.</span></span> <span data-ttu-id="fdfb7-112">其中包括使用者、資料庫角色和應用程式角色，連同其各自的權限，以及透明資料加密 (TDE) (如果主要資料庫上已啟用)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-112">This includes users, database roles, and applications roles together with their respective permissions and transparent data encryption (TDE), if enabled on the primary database.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="fdfb7-113">雖然您無法將資料寫入次要資料庫，但是您可以寫入裝載次要複本的伺服器執行個體上的讀寫資料庫，包括使用者資料庫和系統資料庫 (例如 **tempdb**)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-113">Though you cannot write data to secondary databases, you can write to read-write databases on the server instance that hosts the secondary replica, including user databases and system databases such as **tempdb**.</span></span>  
  
 [!INCLUDE[ssHADR](../../../includes/sshadr-md.md)] <span data-ttu-id="fdfb7-114">也可將讀取意圖的連接要求重新路由到可讀取的次要複本 ( *「唯讀路由」* (Read-Only Routing))。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-114">also supports the re-routing of read-intent connection requests to a readable secondary replica (*read-only routing*).</span></span> <span data-ttu-id="fdfb7-115">如需唯讀路由的相關資訊，請參閱 [使用接聽程式連接到唯讀次要複本 (唯讀路由)](../../listeners-client-connectivity-application-failover.md#ConnectToSecondary)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-115">For information about read-only routing, see [Using a Listener to Connect to a Read-Only Secondary Replica (Read-Only Routing)](../../listeners-client-connectivity-application-failover.md#ConnectToSecondary).</span></span>  
  
 
  
##  <a name="benefits"></a><a name="bkmk_Benefits"></a> <span data-ttu-id="fdfb7-116">優點</span><span class="sxs-lookup"><span data-stu-id="fdfb7-116">Benefits</span></span>  
 <span data-ttu-id="fdfb7-117">將唯讀連接導向至可讀取的次要複本，具有下列優點：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-117">Directing read-only connections to readable secondary replicas provides the following benefits:</span></span>  
  
-   <span data-ttu-id="fdfb7-118">從主要複本卸載次要唯讀工作負載，將主要複本的資源保留給關鍵任務工作負載使用。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-118">Offloads your secondary read-only workloads from your primary replica, which conserves its resources for your mission critical workloads.</span></span> <span data-ttu-id="fdfb7-119">如果您有關鍵任務的讀取工作負載或不能容忍延遲的工作負載，則應該在主要複本上執行此工作負載。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-119">If you have mission critical read-workload or the workload that cannot tolerate latency, you should run it on the primary.</span></span>  
  
-   <span data-ttu-id="fdfb7-120">提高裝載可讀取次要複本之系統的投資報酬率。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-120">Improves your return on investment for the systems that host readable secondary replicas.</span></span>  
  
 <span data-ttu-id="fdfb7-121">此外，可讀取的次要複本對唯讀作業提供強大的支援，如下：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-121">In addition, readable secondaries provide robust support for read-only operations, as follows:</span></span>  
  
-   <span data-ttu-id="fdfb7-122">可讀取次要資料庫的自動暫時統計資料會最佳化磁碟資料表的唯讀查詢。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-122">Automatic temporary statistics on readable secondary database optimize read-only queries on disk-based tables.</span></span> <span data-ttu-id="fdfb7-123">對於記憶體最佳化的資料表，系統會自動建立遺漏的統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-123">For memory-optimized tables, the missing statistics are created automatically.</span></span> <span data-ttu-id="fdfb7-124">不過，過時的統計資料不會自動更新。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-124">However, there is no auto-update of stale statistics.</span></span> <span data-ttu-id="fdfb7-125">您必須手動更新主要複本的統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-125">You will need to manually update the statistics on the primary replica.</span></span> <span data-ttu-id="fdfb7-126">如需詳細資訊，請參閱本主題稍後的 [唯讀存取資料庫的統計資料](#Read-OnlyStats)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-126">For more information, see [Statistics for Read-Only Access Databases](#Read-OnlyStats), later in this topic.</span></span>  
  
-   <span data-ttu-id="fdfb7-127">以磁碟資料表的唯讀工作負載，會使用資料列版本設定以移除對於次要資料庫的封鎖競爭。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-127">Read-only workloads for disk-based tables use row versioning to remove blocking contention on the secondary databases.</span></span> <span data-ttu-id="fdfb7-128">針對次要資料庫執行的所有查詢都會自動對應到快照集隔離交易層級，即使已明確設定其他交易隔離等級也是如此。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-128">All queries that run against the secondary databases are automatically mapped to snapshot isolation transaction level, even when other transaction isolation levels are explicitly set.</span></span> <span data-ttu-id="fdfb7-129">此外，所有鎖定提示都會被忽略。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-129">Also, all locking hints are ignored.</span></span> <span data-ttu-id="fdfb7-130">這排除了讀取器/寫入器競爭。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-130">This eliminates reader/writer contention.</span></span>  
  
-   <span data-ttu-id="fdfb7-131">記憶體最佳化持久資料表的唯讀工作負載存取資料的方式，與主要資料庫上的存取方式完全相同，都是使用原生預存程序或 SQL 互通性，而且具有相同的交易隔離等級限制。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-131">Read-only workloads for memory-optimized durable tables access the data in exactly the same way it is accessed on the primary database, using native stored procedures or SQL Interoperability with the same transaction isolation level limitations.</span></span> <span data-ttu-id="fdfb7-132">在主要複本上執行的報表工作負載或唯讀查詢可以在次要複本上執行，不需要任何變更。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-132">Reporting workload or read-only queries running on the primary replica can be run on the secondary replica without requiring any changes.</span></span> <span data-ttu-id="fdfb7-133">同樣地，在次要複本上執行的報表工作負載或唯讀查詢也可以在主要複本上執行，不需要任何變更。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-133">Similarly, a reporting workload or read-only queries running on a secondary replica can be run on the primary replica without requiring any changes.</span></span>  <span data-ttu-id="fdfb7-134">與磁碟基礎的資料表類似，對次要資料庫執行的所有查詢都會自動對應到快照集隔離交易層級，即使已明確設定其他交易隔離等級也是如此。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-134">Similar to disk-based tables, all queries that run against the secondary databases are automatically mapped to snapshot isolation transaction level, even when other transaction isolation levels are explicitly set.</span></span>  
  
-   <span data-ttu-id="fdfb7-135">次要複本上以磁碟為基礎和記憶體最佳化資料表類型，都允許對資料表變數進行 DML 作業。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-135">DML operations are allowed on table variables both for disk-based and memory-optimized table types on the secondary replica.</span></span>  
  
##  <a name="prerequisites-for-the-availability-group"></a><a name="bkmk_Prerequisites"></a> <span data-ttu-id="fdfb7-136">可用性群組的必要條件</span><span class="sxs-lookup"><span data-stu-id="fdfb7-136">Prerequisites for the Availability Group</span></span>  
  
-   <span data-ttu-id="fdfb7-137">**可讀取的次要複本 (必要)**</span><span class="sxs-lookup"><span data-stu-id="fdfb7-137">**Readable secondary replicas (required)**</span></span>  
  
     <span data-ttu-id="fdfb7-138">資料庫管理員必須設定一個或多個複本，以便在以次要角色執行時，這些複本可以允許所有連接 (僅供唯讀存取) 或只允許讀取意圖的連接。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-138">The database administrator needs to configure one or more replicas so that, when running under the secondary role, they allow either all connections (just for read-only access) or only read-intent connections.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="fdfb7-139">除此之外，資料庫管理員也可選擇在以主要角色執行時，將可用性複本設定為排除唯讀連接。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-139">Optionally, the database administrator can configure any of the availability replicas to exclude read-only connections when running under the primary role.</span></span>  
  
     <span data-ttu-id="fdfb7-140">如需詳細資訊，請參閱本主題稍後的 [關於可用性複本的用戶端連接存取 &#40;SQL Server&#41;](about-client-connection-access-to-availability-replicas-sql-server.md))。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-140">For more information, see [About Client Connection Access to Availability Replicas &#40;SQL Server&#41;](about-client-connection-access-to-availability-replicas-sql-server.md).</span></span>  
  
-   <span data-ttu-id="fdfb7-141">**可用性群組接聽程式**</span><span class="sxs-lookup"><span data-stu-id="fdfb7-141">**Availability group listener**</span></span>  
  
     <span data-ttu-id="fdfb7-142">若要支援唯讀路由，可用性群組必須具有 [可用性群組接聽程式](../../listeners-client-connectivity-application-failover.md)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-142">To support read-only routing, an availability group must possess an [availability group listener](../../listeners-client-connectivity-application-failover.md).</span></span> <span data-ttu-id="fdfb7-143">唯讀用戶端必須將其連接要求導向至此接聽程式，且用戶端的連接字串必須將應用程式的意圖指定為「唯讀」。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-143">The read-only client must direct its connection requests to this listener, and the client's connection string must specify the application intent as "read-only."</span></span> <span data-ttu-id="fdfb7-144">換句話說必須是 *「讀取意圖的連接要求」* (Read-Intent Connection Request)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-144">That is, they must be *read-intent connection requests*.</span></span>  
  
-   <span data-ttu-id="fdfb7-145">**唯讀路由**</span><span class="sxs-lookup"><span data-stu-id="fdfb7-145">**Read only routing**</span></span>  
  
     <span data-ttu-id="fdfb7-146">*「唯讀路由」* (Read-Only Routing) 是 SQL Server 功能，可將導向至可用性群組接聽程式之內送讀取意圖的連接要求，路由至可用之可讀取的次要複本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-146">*Read-only routing* refers to the ability of SQL Server to route incoming read-intent connection requests, that are directed to an availability group listener, to an available readable secondary replica.</span></span> <span data-ttu-id="fdfb7-147">唯讀路由的必要條件如下：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-147">The prerequisites for read-only routing are as follows:</span></span>  
  
    -   <span data-ttu-id="fdfb7-148">若要支援唯讀路由，可讀取的次要複本需要唯讀路由 URL。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-148">To support read-only routing, a readable secondary replica requires a read-only routing URL.</span></span> <span data-ttu-id="fdfb7-149">只有在本機複本以次要角色執行時，此 URL 才會生效。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-149">This URL takes effect only when the local replica is running under the secondary role.</span></span> <span data-ttu-id="fdfb7-150">如有必要，您必須各自指定每個複本的唯讀路由 URL。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-150">The read-only routing URL must be specified on a replica-by-replica basis, as needed.</span></span> <span data-ttu-id="fdfb7-151">每個唯讀路由 URL 可用於將讀取意圖的連接要求路由至特定可讀取的次要複本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-151">Each read-only routing URL is used for routing read-intent connection requests to a specific readable secondary replica.</span></span> <span data-ttu-id="fdfb7-152">一般而言，每個可讀取的次要複本都有一個指派的唯讀路由 URL。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-152">Typically, every readable secondary replica is assigned a read-only routing URL.</span></span>  
  
    -   <span data-ttu-id="fdfb7-153">當支援唯讀路由的可用性複本為主要複本時，每一個可用性複本皆需要唯讀路由清單。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-153">Each availability replica that is to support read-only routing when it is the primary replica requires a read-only routing list.</span></span> <span data-ttu-id="fdfb7-154">只有本機複本以主要角色執行時，給定的唯讀路由清單才會生效。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-154">A given read-only routing list takes effect only when the local replica is running under the primary role.</span></span> <span data-ttu-id="fdfb7-155">如有必要，您必須各自指定每個複本的這份清單。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-155">This list must be specified on a replica-by-replica basis, as needed.</span></span> <span data-ttu-id="fdfb7-156">一般而言，每份唯讀路由清單皆會包含每一個唯讀路由 URL，並在清單結尾提供本機複本的 URL。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-156">Typically, each read-only routing list would contain every read-only routing URL, with the URL of the local replica at the end of the list.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="fdfb7-157">讀取意圖的連接要求會路由至目前之主要複本的唯讀路由清單上，第一個可用之可讀取的次要複本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-157">Read-intent connection requests are routed to the first available readable secondary on the read-only routing list of the current primary replica.</span></span> <span data-ttu-id="fdfb7-158">沒有負載平衡。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-158">There is no load balancing.</span></span>  
  
     <span data-ttu-id="fdfb7-159">如需詳細資訊，請參閱本主題稍後的 [設定可用性群組的唯讀路由 &#40;SQL Server&#41;](configure-read-only-routing-for-an-availability-group-sql-server.md))。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-159">For more information, see [Configure Read-Only Routing for an Availability Group &#40;SQL Server&#41;](configure-read-only-routing-for-an-availability-group-sql-server.md).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="fdfb7-160">如需可用性群組接聽程式的相關資訊，以及唯讀路由的詳細資訊，請參閱 [可用性群組接聽程式、用戶端連接性及應用程式容錯移轉 &#40;SQL Server&#41;](../../listeners-client-connectivity-application-failover.md)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-160">For information about availability group listeners and more information about read-only routing, see [Availability Group Listeners, Client Connectivity, and Application Failover &#40;SQL Server&#41;](../../listeners-client-connectivity-application-failover.md).</span></span>  
  
##  <a name="limitations-and-restrictions"></a><a name="bkmk_LimitationsRestrictions"></a> <span data-ttu-id="fdfb7-161">限制事項</span><span class="sxs-lookup"><span data-stu-id="fdfb7-161">Limitations and Restrictions</span></span>  
 <span data-ttu-id="fdfb7-162">某些作業未完全受到支援，如下所示：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-162">Some operations are not fully supported, as follows:</span></span>  
  
-   <span data-ttu-id="fdfb7-163">一旦可讀取的複本啟用讀取之後，它就可以開始接受其次要資料庫的連接。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-163">As soon as a readable replica is enabled for read, it can start accepting connections to its secondary databases.</span></span> <span data-ttu-id="fdfb7-164">但是，如果主要複本上有任何使用中交易，在對應的次要資料庫上無法完全使用資料列版本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-164">However, if any active transactions exist on a primary database, the row versions will not be fully available on the corresponding secondary database.</span></span> <span data-ttu-id="fdfb7-165">設定次要複本時，主要複本上若有使用中交易，則必須認可或回復這些交易。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-165">Any active transactions that existed on the primary replica when the secondary replica was configured must commit or roll back.</span></span> <span data-ttu-id="fdfb7-166">完成此程序之前，次要資料庫的交易隔離等級對應並不完整，而且查詢會暫時封鎖。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-166">Until this process completes, the transaction isolation level mapping on the secondary database is incomplete and queries are temporarily blocked.</span></span>  
  
    > [!WARNING]  
    >  <span data-ttu-id="fdfb7-167">對於磁碟和記憶體最佳化資料表，執行長時間交易都會影響保存的版本資料列數目。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-167">Running long transactions impacts the number of versioned rows kept, both for disk-based and memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="fdfb7-168">在具有記憶體最佳化資料表的次要資料庫上，即使系統一定會對記憶體最佳化的資料表產生資料列版本，查詢仍然會遭到封鎖，直到次要複本啟用讀取時，存在於主要複本中的所有使用中交易都完成為止。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-168">On a secondary database with memory-optimized tables, even though row versions are always generated for memory-optimzied tables, queries are blocked until all active transactions that existed in the primary replica when the secondary replica was enabled for read complete.</span></span> <span data-ttu-id="fdfb7-169">這樣可確保報表工作負載與唯讀查詢可以同時使用磁碟基礎的和記憶體最佳化的資料表。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-169">This ensures that both disk-based and memory-optimized tables are available to the reporting workload and read-only queries at the same time.</span></span>  
  
-   <span data-ttu-id="fdfb7-170">在屬於可讀取次要複本的次要資料庫上，不支援變更追蹤和異動資料擷取：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-170">Change tracking and change data capture are not supported on secondary databases that belong to a readable secondary replica:</span></span>  
  
    -   <span data-ttu-id="fdfb7-171">次要資料庫上已明確停用變更追蹤。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-171">Change tracking is explicitly disabled on secondary databases.</span></span>  
  
    -   <span data-ttu-id="fdfb7-172">次要資料庫上可以啟用異動資料擷取，但是這不受支援。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-172">Change data capture can be enabled on a secondary database, but this is not supported.</span></span>  
  
-   <span data-ttu-id="fdfb7-173">由於讀取作業會對應至快照集隔離交易層級，因此一個或多個次要複本上的交易會封鎖在主要複本上的準刪除記錄清除。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-173">Because read operations are mapped to snapshot isolation transaction level, the cleanup of ghost records on the primary replica can be blocked by transactions on one or more secondary replicas.</span></span> <span data-ttu-id="fdfb7-174">當任何次要複本不再需要準刪除記錄時，準刪除記錄清除工作會自動清除主要複本上以磁碟為基礎之資料表的準刪除記錄。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-174">The ghost record cleanup task will automatically clean up the ghost records for disk-based tables on the primary replica when they are no longer needed by any secondary replica.</span></span>  <span data-ttu-id="fdfb7-175">這類似於在主要複本上執行交易時所完成的作業。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-175">This is similar to what is done when you run transaction(s) on the primary replica.</span></span> <span data-ttu-id="fdfb7-176">在次要資料庫的極端案例，您需要終止長時間執行、封鎖準刪除清除的讀取查詢。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-176">In the extreme case on the secondary database, you will need to kill a long running read-query that is blocking the ghost cleanup.</span></span> <span data-ttu-id="fdfb7-177">請注意，如果次要複本中斷連接或在次要資料庫上的資料移動暫停時，可能會封鎖準刪除清除。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-177">Note, the ghost clean can be blocked if the secondary replica gets disconnected or when data movement is suspended on the secondary database.</span></span> <span data-ttu-id="fdfb7-178">這種狀態也會防止記錄截斷，因此如果此狀態持續發生，建議您從可用性群組中移除此次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-178">This state also prevents log truncation, so if this state persists, we recommend that you remove this secondary database from the availability group.</span></span> <span data-ttu-id="fdfb7-179">記憶體最佳化的資料表沒有任何準刪除記錄清除問題，因為資料列版本保留在記憶體中，而且獨立於主要複本上的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-179">There is no ghost record cleanup issue with memory-optimized tables because the row versions are kept in memory and are independent of the row versions on the primary replica.</span></span>  
  
-   <span data-ttu-id="fdfb7-180">若檔案包含了次要複本所需要的準刪除記錄，則主要複本上對於包含以磁碟為基礎資料表之檔案的 DBCC SHRINKFILE 作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-180">The DBCC SHRINKFILE operation on files containing disk-based tables might fail on the primary replica if the file contains ghost records that are still needed on a secondary replica.</span></span>  
  
-   <span data-ttu-id="fdfb7-181">從 [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)]開始，即使主要複本由於使用者動作或失敗而離線，可讀取的次要複本依然可以維持在線上。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-181">Beginning in [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)], readable secondary replicas can remain online even when the primary replica is offline due to user action or a failure.</span></span> <span data-ttu-id="fdfb7-182">但是，唯讀路由在此情況下無法運作，因為可用性群組接聽程式也離線。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-182">However, read-only routing does not work in this situation because the availability group listener is offline as well.</span></span> <span data-ttu-id="fdfb7-183">用戶端必須直接連接到唯讀工作負載的唯讀次要複本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-183">Clients must connect directly to the read-only secondary replicas for read-only workloads.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="fdfb7-184">對裝載可讀取之次要複本的伺服器執行個體上查詢 [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) 動態管理檢視時，可能會發生 REDO 封鎖問題。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-184">If you query the [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) dynamic management view on a server instance that is hosting a readable secondary replica, you might encounter a REDO blocking issue.</span></span> <span data-ttu-id="fdfb7-185">這是因為此動態管理檢視會取得指定使用者資料表或檢視表的 IS 鎖定，並因此而封鎖了對該使用者資料表或檢視表之 X 鎖定的 REDO 執行緒要求。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-185">This is because this dynamic management view acquires an IS lock on the specified user table or view that can block requests by a REDO thread for an X lock on that user table or view.</span></span>  
  
##  <a name="performance-considerations"></a><a name="bkmk_Performance"></a> <span data-ttu-id="fdfb7-186">效能考量</span><span class="sxs-lookup"><span data-stu-id="fdfb7-186">Performance Considerations</span></span>  
 <span data-ttu-id="fdfb7-187">本節討論可讀取次要資料庫的數項效能考量。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-187">This section discusses several performance considerations for readable secondary databases</span></span>  
  
 
  
###  <a name="data-latency"></a><a name="DataLatency"></a> <span data-ttu-id="fdfb7-188">資料延遲</span><span class="sxs-lookup"><span data-stu-id="fdfb7-188">Data Latency</span></span>  
 <span data-ttu-id="fdfb7-189">如果您的唯讀工作負載可以容忍某些資料延遲時，實作次要複本的唯讀存取會很有用。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-189">Implementing read-only access to secondary replicas is useful if your read-only workloads can tolerate some data latency.</span></span> <span data-ttu-id="fdfb7-190">在無法接受資料延遲的狀況下，請考慮針對主要複本執行唯讀工作負載。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-190">In situations where data latency is unacceptable, consider running read-only workloads against the primary replica.</span></span>  
  
 <span data-ttu-id="fdfb7-191">主要複本上會將主要資料庫變更的記錄檔記錄傳送到次要複本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-191">The primary replica sends log records of changes on primary database to the secondary replicas.</span></span> <span data-ttu-id="fdfb7-192">在每個次要資料庫上，專用的重做執行緒會套用記錄檔記錄。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-192">On each secondary database, a dedicated redo thread applies the log records.</span></span> <span data-ttu-id="fdfb7-193">在讀取存取的次要資料庫上，給定資料變更不會出現在查詢結果，除非包含變更的記錄檔記錄已套用至次要資料庫，而且已經在主要資料庫認可交易。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-193">On a read-access secondary database, a given data change does not appear in query results until the log record that contains the change has been applied to the secondary database and the transaction has been committed on primary database.</span></span>  
  
 <span data-ttu-id="fdfb7-194">這表示，主要複本和次要複本之間會有一些延遲 (通常只有幾秒鐘)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-194">This means that there is some latency, usually only a matter of seconds, between the primary and secondary replicas.</span></span> <span data-ttu-id="fdfb7-195">但在很少見的情況下 (例如網路問題減少輸送量的狀況下)，延遲可能會比較長。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-195">In unusual cases, however, for example if network issues reduce throughput, latency can become significant.</span></span> <span data-ttu-id="fdfb7-196">在發生 I/O 瓶頸和資料移動暫停時，會增加延遲。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-196">Latency increases when I/O bottlenecks occur and when data movement is suspended.</span></span> <span data-ttu-id="fdfb7-197">若要監視暫停的資料移動，您可以使用 [AlwaysOn 儀表板](use-the-always-on-dashboard-sql-server-management-studio.md) 或 [sys.dm_hadr_database_replica_states](/sql/relational-databases/system-dynamic-management-views/sys-dm-hadr-database-replica-states-transact-sql) 動態管理檢視。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-197">To monitor suspended data movement, you can use the [AlwaysOn Dashboard](use-the-always-on-dashboard-sql-server-management-studio.md) or the [sys.dm_hadr_database_replica_states](/sql/relational-databases/system-dynamic-management-views/sys-dm-hadr-database-replica-states-transact-sql) dynamic management view.</span></span>  
  
####  <a name="data-latency-on-databases-with-memory-optimized-tables"></a><a name="bkmk_LatencyWithInMemOLTP"></a> <span data-ttu-id="fdfb7-198">具有記憶體最佳化資料表之資料庫的資料延遲</span><span class="sxs-lookup"><span data-stu-id="fdfb7-198">Data Latency on databases with memory-optimized tables</span></span>  
 <span data-ttu-id="fdfb7-199">為讀取工作負載存取次要複本上的記憶體最佳化資料表時，會使用「安全時間戳記」 \*\* ，從早於「安全時間戳記」 \*\* 認可的交易傳回資料列。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-199">When accessing memory-optimized tables on secondary replica for read workload, a *safe-timestamp* is used to return rows from transactions that have committed earlier than *safe-timestamp*.</span></span> <span data-ttu-id="fdfb7-200">安全時間戳記是記憶體回收執行緒所使用之最舊的時間戳記提示，可在主要複本上進行資料列的記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-200">The safe-timestamp is the oldest timestamp hint used by the garbage collection thread to garbage collect the rows on the primary replica.</span></span> <span data-ttu-id="fdfb7-201">當記憶體最佳化資料表上的 DML 交易數目超出上次更新時的內部臨界值，就會更新此時間戳記。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-201">This timestamp is updated when the number of DML transactions on memory-optimized tables exceed an internal threshold since the last update.</span></span> <span data-ttu-id="fdfb7-202">每當主要複本上最舊的交易時間戳記更新時，持久記憶體最佳化資料表上的下一個 DML 交易會將要傳送到次要複本的時間戳記，做為特定記錄檔記錄的一部分傳送。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-202">Whenever the oldest transaction timestamp is updated on the primary replica, the next DML transaction on a durable memory-optimized table will send this timestamp to be sent to secondary replica as part of a special log record.</span></span> <span data-ttu-id="fdfb7-203">次要複本上的 REDO 執行緒會在處理此記錄檔記錄時，更新安全時間戳記。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-203">REDO thread on the secondary replica, updates the safe-timestamp as part of processing this log record.</span></span>  
  
#### <a name="the-impact-of-safe-timestamp-on-latency"></a><span data-ttu-id="fdfb7-204">安全時間戳記對延遲的影響</span><span class="sxs-lookup"><span data-stu-id="fdfb7-204">The impact of safe-timestamp on Latency</span></span>  
  
-   <span data-ttu-id="fdfb7-205">對於具有高交易輸送量的 OLTP 工作負載，延遲應該與磁碟基礎的資料表類似。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-205">For OLTP workloads with high transaction throughput, the latency should be comparable to disk-based tables.</span></span> <span data-ttu-id="fdfb7-206">我們預期此為常見情況。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-206">We expect this to be the common case.</span></span>  
  
-   <span data-ttu-id="fdfb7-207">長時間執行的交易可能會造成安全時間戳記任意延遲。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-207">A long running transaction can cause the safe-timestamp to be delayed arbitrarily.</span></span>  <span data-ttu-id="fdfb7-208">存取磁碟基礎的資料表時也一樣，因為快照集隔離的時間戳記取決於最舊交易的認可。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-208">This is no different when accessing disk-based tables as the timestamp of snapshot isolation is determined by the commit of oldest transaction.</span></span>  
  
-   <span data-ttu-id="fdfb7-209">自上次安全時間戳記更新後，在主要複本上由交易所做的變更，直到下一次傳輸和更新安全時間戳記之前，都不會在次要複本上看到。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-209">Changes made by transactions on the primary replica since the last safe-timestamp update are not visible on the secondary replica till the next transmission and update of the safe-timestamp.</span></span> <span data-ttu-id="fdfb7-210">若在超過安全時間戳記更新的內部臨界值之前，主要複本上的交易活動停止，則不會在次要複本上看到上次安全時間戳記變更後所進行的變更。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-210">If transactional activity on the primary replica stops before the internal threshold for safe-timestamp update is crossed, the changes made since the last update to safe-timestamp will not be visible on the secondary replica.</span></span> <span data-ttu-id="fdfb7-211">若要減少此類問題發生，您可能需要在主要複本上，於一個虛擬持久記憶體最佳化的資料表中執行一些 DML 交易。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-211">To alleviate this issue, you may need to run a few DML transactions on a dummy durable memory-optimized table on the primary replica.</span></span> <span data-ttu-id="fdfb7-212">或者，雖然不建議這麼做，但您可以執行手動檢查點，強制執行安全時間戳記傳送。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-212">Alternatively, though not recommended, you can force shipping of safe-timestamp by running a manual checkpoint.</span></span>  
  
#### <a name="monitoring-and-troubleshooting-data-latency-in-memory-optimized-tables"></a><span data-ttu-id="fdfb7-213">監視和疑難排解記憶體最佳化資料表中的資料延遲</span><span class="sxs-lookup"><span data-stu-id="fdfb7-213">Monitoring and Troubleshooting data latency in memory-optimized tables</span></span>  
 <span data-ttu-id="fdfb7-214">您可以藉由在主要複本上執行下列查詢，找出安全時間戳記</span><span class="sxs-lookup"><span data-stu-id="fdfb7-214">You can find out the safe-timestamp by running the following query on the primary replica</span></span>  
  
```  
  
SELECT MAX(base_generation)   
   AS max_base_generation  
   FROM sys.dm_db_xtp_gc_cycle_stats  
GO  
  
```  
  
 <span data-ttu-id="fdfb7-215">您也可以藉由同時執行下列查詢與使用中讀取工作負載，識別次要複本上使用的安全時間戳記。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-215">You can also identify the safe-timestamp used on the secondary replica by running the following query concurrently with the active read-workload.</span></span>  
  
```  
  
SELECT begin_tsn   
   FROM sys.dm_db_xtp_transactions  
GO  
  
```  
  
###  <a name="read-only-workload-impact"></a><a name="ReadOnlyWorkloadImpact"></a> <span data-ttu-id="fdfb7-216">唯讀工作負載的影響</span><span class="sxs-lookup"><span data-stu-id="fdfb7-216">Read-Only Workload Impact</span></span>  
 <span data-ttu-id="fdfb7-217">將次要複本設定為唯讀存取時，次要資料庫上的唯讀工作負載會耗用系統資源，例如重做執行緒的 CPU 和 I/O (針對以磁碟為基礎之資料表)，特別是當以磁碟為基礎之資料表的唯讀工作負載高密度使用 I/O 資料時。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-217">When you configure a secondary replica for read-only access, your read-only workloads on the secondary databases consume system resources, such as CPU and I/O (for disk-based tables) from redo threads, especially if the read-only workloads on disk-based tables are highly I/O-intensive.</span></span> <span data-ttu-id="fdfb7-218">存取記憶體最佳化的資料表時，不會造成任何 IO 影響，因為所有資料列都位於記憶體中。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-218">There is no IO impact when accessing memory-optimized tables because all the rows reside in memory.</span></span>  
  
 <span data-ttu-id="fdfb7-219">此外，次要複本上的唯讀工作負載可以封鎖透過記錄檔記錄套用的資料定義語言 (DDL) 變更。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-219">Also, read-only workloads on the secondary replicas can block data definition language (DDL) changes that are applied through log records.</span></span>  
  
-   <span data-ttu-id="fdfb7-220">雖然讀取作業因為資料列版本設定的緣故而不會取得共用鎖定，但是這些作業會取得結構描述穩定性 (Sch-S) 鎖定，而這些鎖定可能會封鎖套用 DDL 變更的重做作業。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-220">Even though the read operations do not take shared locks because of row versioning, these operations take schema stability (Sch-S) locks, which can block redo operations that are applying DDL changes.</span></span> <span data-ttu-id="fdfb7-221">DDL 作業包含 ALTER/DROP 資料表和檢視表，但不包含 DROP 或 ALTER 預存程序。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-221">DDL operations include ALTER/DROP tables and Views but not DROP or ALTER of stored procedures.</span></span> <span data-ttu-id="fdfb7-222">因此，假設您在主要複本上卸除磁碟或記憶體最佳化資料表。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-222">So for example, if you drop a table disk-based or memory-optimized, on primary.</span></span> <span data-ttu-id="fdfb7-223">當 REDO 執行緒處理記錄檔記錄以卸除資料表時，它必須取得資料表的 SCH_M 鎖定，而且可能會由存取資料表的執行中查詢封鎖。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-223">When REDO thread processes the log record to drop the table, it must acquire a SCH_M lock on the table and can get blocked by a running query accessing table.</span></span>  <span data-ttu-id="fdfb7-224">此行為與主要複本相同，但是資料表的卸除是在使用者工作階段中完成，而非由 REDO 執行緒完成。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-224">This is the same behavior on primary replica except that the drop of the table is done as part of a user session and not REDO thread.</span></span>  
  
-   <span data-ttu-id="fdfb7-225">還有其他封鎖中的記憶體最佳化資料表。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-225">There is additional blocking Memory-Optimized Tables.</span></span> <span data-ttu-id="fdfb7-226">如果次要複本有同時執行的原生預存程序，則卸除原生預存程序可能會導致 REDO 執行緒封鎖。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-226">A drop of native stored procedure can cause REDO thread to block if there is a concurrent execution of the native stored procedure on the secondary replica.</span></span> <span data-ttu-id="fdfb7-227">此行為與主要複本相同，但是預存程序的卸除是在使用者工作階段中完成，而非由 REDO 執行緒完成。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-227">This is the same behavior on the primary replica except that the drop of the stored procedure is done as part of a user session and not REDO thread.</span></span>  
  
 <span data-ttu-id="fdfb7-228">請查明建立查詢的最佳作法，並在次要資料庫中執行這些最佳作法。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-228">Be aware of best practices around building queries, and exercise those best practices in the secondary databases.</span></span> <span data-ttu-id="fdfb7-229">例如，將長時間執行的查詢 (如資料彙總) 安排在活動較少的期間執行。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-229">For example, schedule long-running queries such as aggregations of data during times of low activity.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="fdfb7-230">如果重做執行緒遭到次要複本上的查詢封鎖，便會引發 **sqlserver.lock_redo_blocked** XEvent。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-230">If a redo thread is blocked by queries on a secondary replica, the **sqlserver.lock_redo_blocked** XEvent is raised.</span></span>  
  
###  <a name="indexing"></a><a name="bkmk_Indexing"></a> <span data-ttu-id="fdfb7-231">索引</span><span class="sxs-lookup"><span data-stu-id="fdfb7-231">Indexing</span></span>  
 <span data-ttu-id="fdfb7-232">若要將可讀取次要複本上的唯讀工作負載最佳化，您可能會想要在次要資料庫的資料表上建立索引。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-232">To optimize read-only workloads on the readable secondary replicas, you may want to create indexes on the tables in the secondary databases.</span></span> <span data-ttu-id="fdfb7-233">因為您無法在次要資料庫上進行結構描述或資料變更，所以請在主要資料庫中建立索引，並允許透過重做處理序將變更傳送到次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-233">Because you cannot make schema or data changes on the secondary databases, create indexes in the primary databases and allow the changes to transfer to the secondary database through the redo process.</span></span>  
  
 <span data-ttu-id="fdfb7-234">若要監視次要複本的索引使用活動，請查詢 **sys.dm_db_index_usage_stats**動態管理檢視的 **user_seeks**、 **user_scans** 和 [user_lookups](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-usage-stats-transact-sql) 資料行。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-234">To monitor index usage activity on a secondary replica, query the **user_seeks**, **user_scans**, and **user_lookups** columns of the [sys.dm_db_index_usage_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-usage-stats-transact-sql) dynamic management view.</span></span>  
  
###  <a name="statistics-for-read-only-access-databases"></a><a name="Read-OnlyStats"></a> <span data-ttu-id="fdfb7-235">唯讀存取資料庫的統計資料</span><span class="sxs-lookup"><span data-stu-id="fdfb7-235">Statistics for Read-Only Access Databases</span></span>  
 <span data-ttu-id="fdfb7-236">資料表資料行和索引檢視表的統計資料可用來最佳化查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-236">Statistics on columns of tables and indexed views are used to optimize query plans.</span></span> <span data-ttu-id="fdfb7-237">對於可用性群組而言，在主要資料庫上建立和維護的統計資料會自動保存至次要資料庫，做為交易記錄檔記錄應用的一部分。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-237">For availability groups, statistics that are created and maintained on the primary databases are automatically persisted on the secondary databases as part of applying the transaction log records.</span></span> <span data-ttu-id="fdfb7-238">然而，次要資料庫上的唯讀工作負載所需的統計資料，可能與主要資料庫上所建立的統計資料不同。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-238">However, the read-only workload on the secondary databases may need different statistics than those that are created on the primary databases.</span></span> <span data-ttu-id="fdfb7-239">但因次要資料庫受限為唯讀存取，所以無法在次要資料庫上建立統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-239">However, because secondary databases are restricted to read-only access, statistics cannot be created on the secondary databases.</span></span>  
  
 <span data-ttu-id="fdfb7-240">為了解決此問題，次要複本會在 **tempdb**中建立及維護次要資料庫的暫時統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-240">To address this problem, the secondary replica creates and maintains temporary statistics for secondary databases in **tempdb**.</span></span> <span data-ttu-id="fdfb7-241">暫時統計資料名稱會附加後置詞 suffix _readonly_database_statistic，以便區分暫時統計資料與主要資料庫中保存的永久統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-241">The suffix _readonly_database_statistic is appended to the name of temporary statistics to differentiate them from the permanent statistics that are persisted from the primary database.</span></span>  
  
 <span data-ttu-id="fdfb7-242">只有 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以建立和更新暫時統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-242">Only [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can create and update temporary statistics.</span></span> <span data-ttu-id="fdfb7-243">但是，您可以使用永久統計資料所使用的相同工具來刪除暫時統計資料及監控其屬性：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-243">However, you can delete temporary statistics and monitor their properties using the same tools that you use for permanent statistics:</span></span>  
  
-   <span data-ttu-id="fdfb7-244">使用 [DROP STATISTICS](/sql/t-sql/statements/drop-statistics-transact-sql)[!INCLUDE[tsql](../../../includes/tsql-md.md)] 陳述式刪除暫時統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-244">Delete temporary statistics using the [DROP STATISTICS](/sql/t-sql/statements/drop-statistics-transact-sql)[!INCLUDE[tsql](../../../includes/tsql-md.md)] statement.</span></span>  
  
-   <span data-ttu-id="fdfb7-245">使用 **sys.stats** 和 **sys.stats_columns** 目錄檢視監視統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-245">Monitor statistics using the **sys.stats** and **sys.stats_columns** catalog views.</span></span> <span data-ttu-id="fdfb7-246">**sys_stats** 包含 **is_temporary**資料行，以表示哪些統計資料為永久性而哪些統計資料為暫時性。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-246">**sys_stats** includes a column, **is_temporary**, to indicate which statistics are permanent and which are temporary.</span></span>  
  
 <span data-ttu-id="fdfb7-247">主要或次要複本上的記憶體最佳化資料表都不支援自動統計資料更新。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-247">There is no support for auto-statistics update for memory-optimized tables on the primary or secondary replica.</span></span> <span data-ttu-id="fdfb7-248">您必須監視次要複本的查詢效能和計劃，並且視需要手動更新主要複本的統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-248">You must monitor query performance and plans on the secondary replica and manually update the statistics on the primary replica when needed.</span></span> <span data-ttu-id="fdfb7-249">不過，系統會自動建立主要和次要複本的遺漏統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-249">However, the missing statistics are automatically created both on primary and secondary replica.</span></span>  
  
 <span data-ttu-id="fdfb7-250">如需 SQL Server 統計資料的詳細資訊，請參閱 [統計資料](../../../relational-databases/statistics/statistics.md)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-250">For more information about SQL Server statistics, see [Statistics](../../../relational-databases/statistics/statistics.md).</span></span>  
  

  
####  <a name="stale-permanent-statistics-on-secondary-databases"></a><a name="StalePermStats"></a> <span data-ttu-id="fdfb7-251">次要資料庫上過時的永久統計資料</span><span class="sxs-lookup"><span data-stu-id="fdfb7-251">Stale Permanent Statistics on Secondary Databases</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="fdfb7-252">會偵測次要資料庫上的永久統計資料何時過時。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-252">detects when permanent statistics on a secondary database are stale.</span></span> <span data-ttu-id="fdfb7-253">但除了對主要資料庫所做的變更以外，無法對永久統計資料進行變更。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-253">But changes cannot be made to the permanent statistics except through changes on the primary database.</span></span> <span data-ttu-id="fdfb7-254">為達到查詢最佳化， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 會在次要資料庫上建立以磁碟為基礎之資料表的暫時統計資料，並且使用這些統計資料以取代過時的永久統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-254">For query optimization, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] creates temporary statistics for disk-based tables on the secondary database and uses these statistics instead of the stale permanent statistics.</span></span>  
  
 <span data-ttu-id="fdfb7-255">在主要資料庫上更新永久統計資料時，這些統計資料會自動保存至次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-255">When the permanent statistics are updated on the primary database, they are automatically persisted to the secondary database.</span></span> <span data-ttu-id="fdfb7-256">然後 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 會使用更新的永久統計資資料 (比暫時統計資料還要新)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-256">Then [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] uses the updated permanent statistics, which are more current than the temporary statistics.</span></span>  
  
 <span data-ttu-id="fdfb7-257">如果可用性群組容錯移轉，所有次要複本上的暫時統計資料都會被刪除。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-257">If the availability group fails over, temporary statistics are deleted on all of the secondary replicas.</span></span>  
  
####  <a name="limitations-and-restrictions"></a><a name="StatsLimitationsRestrictions"></a> <span data-ttu-id="fdfb7-258">限制事項</span><span class="sxs-lookup"><span data-stu-id="fdfb7-258">Limitations and Restrictions</span></span>  
  
-   <span data-ttu-id="fdfb7-259">因為暫時統計資料會儲存在 **tempdb**中，所以重新啟動 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 服務會導致所有暫時統計資料消失。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-259">Because temporary statistics are stored in **tempdb**, a restart of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] service causes all temporary statistics to disappear.</span></span>  
  
-   <span data-ttu-id="fdfb7-260">後置詞 _readonly_database_statistic 會保留給 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]產生的統計資料使用。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-260">The suffix _readonly_database_statistic is reserved for statistics generated by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="fdfb7-261">當您在主要資料庫上建立統計資料時，將無法使用這個後置詞。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-261">You cannot use this suffix when creating statistics on a primary database.</span></span> <span data-ttu-id="fdfb7-262">如需詳細資訊，請參閱[統計資料](../../../relational-databases/statistics/statistics.md)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-262">For more information, see [Statistics](../../../relational-databases/statistics/statistics.md).</span></span>  
  
##  <a name="accessing-memory-optimized-tables-on-a-secondary-replica"></a><a name="bkmk_AccessInMemTables"></a> <span data-ttu-id="fdfb7-263">存取次要複本上的記憶體最佳化資料表</span><span class="sxs-lookup"><span data-stu-id="fdfb7-263">Accessing memory-optimized tables on a Secondary Replica</span></span>  
 <span data-ttu-id="fdfb7-264">次要複本的讀取工作負載隔離等級僅限於主要複本允許的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-264">The read workload isolation levels on secondary replica are only those allowed on the primary replica.</span></span> <span data-ttu-id="fdfb7-265">系統不會針對次要複本進行任何隔離等級對應。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-265">There is no mapping of isolations levels done on the secondary replica.</span></span> <span data-ttu-id="fdfb7-266">這樣可確保任何可在主要複本上執行的報表工作負載都能夠在次要複本上執行，不需要任何變更。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-266">This ensure that any reporting workload that can be run on primary replica is able to run on the secondary replica without requiring any changes.</span></span> <span data-ttu-id="fdfb7-267">如此可讓您輕鬆地將報表工作負載從主要複本移轉至次要複本，反之亦然 (次要複本無法使用時)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-267">This makes it easy for you to migrate a reporting workload from the primary replica to a secondary or vice versa when the secondary replica is not available.</span></span>  
  
 <span data-ttu-id="fdfb7-268">下列查詢無法在次要複本上執行，其失敗狀況與主要複本很相似。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-268">The following queries fail to run on the secondary replica similarly to the way they fail on the primary replica.</span></span>  
  
-   <span data-ttu-id="fdfb7-269">對於只在記憶體最佳化資料表上執行的查詢，支援的隔離等級只有快照集、可重複讀取和可序列化。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-269">For queries running only on memory-optimized tables, the only supported isolation levels are snapshot, repeatable read, and serializable.</span></span> <span data-ttu-id="fdfb7-270">除非您在資料庫層級啟用 MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT 選項，否則所有具有讀取未認可或讀取認可隔離等級的查詢都會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-270">Any queries with read-uncommitted or read committed isolation level returns an error unless you have enabled the option MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT at the database level.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL READ_COMMITTED  
    -- This is not allowed  
    BEGIN TRAN  
    SELECT * FROM t_hk  
    COMMIT  
  
    ```  
  
     <span data-ttu-id="fdfb7-271">錯誤訊息：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-271">Error message:</span></span>  
  
    ```  
    Msg 41368, Level 16, State 0, Line 2  
    Accessing memory optimized tables using the CREAD_COMMITTED isolation level is supported only for autocommit transactions. It is not supported for explicit or implicit transactions. Provide a supported isolation level for the memory optimized table using a table hing, such as WITH (SNAPSHOT).  
    ```  
  
-   <span data-ttu-id="fdfb7-272">記憶體最佳化資料表不支援任何鎖定提示。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-272">No locking hints are supported on memory-optimized tables.</span></span> <span data-ttu-id="fdfb7-273">例如，下列所有查詢都會失敗並出現錯誤。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-273">For example, all of the following queries fail with an error.</span></span> <span data-ttu-id="fdfb7-274">僅允許 NOLOCK 提示，而搭配記憶體最佳化資料表使用時，則為 NOOP。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-274">Only NOLOCK hint is allowed and it is NOOP when used with memory-optimized tables.</span></span>  
  
    ```sql  
    SELECT * FROM t_hk WITH (PAGLOCK)  
    SELECT * FROM t_hk WITH (READPAST)  
    SELECT * FROM t_hk WITH (ROWLOCK)  
    SELECT * FROM t_hk WITH (READPAST)  
    SELECT * FROM t_hk WITH (TABLOCK)  
    SELECT * FROM t_hk WITH (XLOCK)  
    SELECT * FROM t_hk WITH (UPDLOCK)  
    ```  
  
-   <span data-ttu-id="fdfb7-275">針對跨容器交易，不支援具有會話隔離等級「快照集」的交易來存取記憶體優化資料表。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-275">For cross-container transactions, transactions with session isolation level "snapshot" that access memory-optimized tables is not supported.</span></span> <span data-ttu-id="fdfb7-276">例如</span><span class="sxs-lookup"><span data-stu-id="fdfb7-276">For example,</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT  
    -- This is not allowed  
    BEGIN TRAN  
       SELECT * FROM t_hk  
    COMMIT  
    ```  
  
     <span data-ttu-id="fdfb7-277">錯誤訊息：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-277">Error message:</span></span>  
  
    ```  
    Msg 41332, Level 16, State 0, Line 5  
    Memory optimized tables and natively compiled stored procedures cannot be accessed or created when the session TRANSACTION ISOLATION LEVEL is set to SNAPSHOT.  
    ```  
  
##  <a name="capacity-planning-considerations"></a><a name="bkmk_CapacityPlanning"></a> <span data-ttu-id="fdfb7-278">容量規劃考量</span><span class="sxs-lookup"><span data-stu-id="fdfb7-278">Capacity Planning Considerations</span></span>  
  
-   <span data-ttu-id="fdfb7-279">在以磁碟為基礎之資料表案例中，可讀取的次要複本需要 **tempdb** 的空間主要基於以下兩個原因：</span><span class="sxs-lookup"><span data-stu-id="fdfb7-279">In the case of disk-based tables, readable secondary replicas can require space in **tempdb** for two reasons:</span></span>  
  
    -   <span data-ttu-id="fdfb7-280">快照集隔離等級會將資料列版本複製到 **tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-280">Snapshot isolation level copies row versions into **tempdb**.</span></span>  
  
    -   <span data-ttu-id="fdfb7-281">在 **tempdb**中建立和維護次要資料庫的暫時統計資料。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-281">Temporary statistics for secondary databases are created and maintained in **tempdb**.</span></span> <span data-ttu-id="fdfb7-282">暫時統計資料會導致 **tempdb**略微增大。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-282">The temporary statistics can cause a slight increase in the size of **tempdb**.</span></span> <span data-ttu-id="fdfb7-283">如需詳細資訊，請參閱本節稍後的 [唯讀存取資料庫的統計資料](#Read-OnlyStats)。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-283">For more information, see [Statistics for Read-Only Access Databases](#Read-OnlyStats), later in this section.</span></span>  
  
-   <span data-ttu-id="fdfb7-284">當您設定一個或多個次要複本的讀取權時，主要資料庫會在已刪除、修改或插入的資料列上增加 14 個位元組的額外負擔，以便在以磁碟為基礎之資料表的次要資料庫上，儲存資料列版本的指標。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-284">When you configure read-access for one or more secondary replicas, the primary databases add 14 bytes of overhead on deleted, modified, or inserted data rows to store pointers to row versions on the secondary databases for disk-based tables.</span></span> <span data-ttu-id="fdfb7-285">此 14 個位元組的額外負擔會轉至次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-285">This 14-byte overhead is carried over to the secondary databases.</span></span> <span data-ttu-id="fdfb7-286">將 14 個位元組的負擔增加到資料列時，可能會發生頁面分割。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-286">As the 14-byte overhead is added to data rows, page splits might occur.</span></span>  
  
     <span data-ttu-id="fdfb7-287">主要資料庫不會產生資料列版本資料，</span><span class="sxs-lookup"><span data-stu-id="fdfb7-287">The row version data is not generated by the primary databases.</span></span> <span data-ttu-id="fdfb7-288">而是由次要資料庫產生資料列版本。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-288">Instead, the secondary databases generate the row versions.</span></span> <span data-ttu-id="fdfb7-289">不過，資料列版本設定會同時增加主要和次要資料庫的資料儲存量。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-289">However, row versioning increases data storage in both the primary and secondary databases.</span></span>  
  
     <span data-ttu-id="fdfb7-290">系統是否新增資料列版本資料，取決於主要資料庫的快照集隔離或讀取認可快照集隔離 (RCSI) 等級設定。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-290">The addition of the row version data depends on the snapshot isolation or read-committed snapshot isolation (RCSI) level setting on the primary database.</span></span> <span data-ttu-id="fdfb7-291">下表描述在不同磁碟資料表的設定下可讀取次要資料庫的版本設定行為。</span><span class="sxs-lookup"><span data-stu-id="fdfb7-291">The table below describes the behavior of versioning on a readable secondary database under different settings for disk based tables.</span></span>  
  
    |<span data-ttu-id="fdfb7-292">可讀取的次要複本？</span><span class="sxs-lookup"><span data-stu-id="fdfb7-292">Readable secondary replica?</span></span>|<span data-ttu-id="fdfb7-293">已啟用快照集隔離或 RCSI 等級？</span><span class="sxs-lookup"><span data-stu-id="fdfb7-293">Snapshot isolation or RCSI level enabled?</span></span>|<span data-ttu-id="fdfb7-294">主要資料庫</span><span class="sxs-lookup"><span data-stu-id="fdfb7-294">Primary Database</span></span>|<span data-ttu-id="fdfb7-295">次要資料庫</span><span class="sxs-lookup"><span data-stu-id="fdfb7-295">Secondary Database</span></span>|  
    |---------------------------------|-----------------------------------------------|----------------------|------------------------|  
    |<span data-ttu-id="fdfb7-296">否</span><span class="sxs-lookup"><span data-stu-id="fdfb7-296">No</span></span>|<span data-ttu-id="fdfb7-297">否</span><span class="sxs-lookup"><span data-stu-id="fdfb7-297">No</span></span>|<span data-ttu-id="fdfb7-298">沒有資料列版本或 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-298">No row versions or 14-byte overhead</span></span>|<span data-ttu-id="fdfb7-299">沒有資料列版本或 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-299">No row versions or 14-byte overhead</span></span>|  
    |<span data-ttu-id="fdfb7-300">否</span><span class="sxs-lookup"><span data-stu-id="fdfb7-300">No</span></span>|<span data-ttu-id="fdfb7-301">是</span><span class="sxs-lookup"><span data-stu-id="fdfb7-301">Yes</span></span>|<span data-ttu-id="fdfb7-302">有資料列版本和 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-302">Row versions and 14-byte overhead</span></span>|<span data-ttu-id="fdfb7-303">沒有資料列版本，但有 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-303">No row versions, but 14-byte overhead</span></span>|  
    |<span data-ttu-id="fdfb7-304">是</span><span class="sxs-lookup"><span data-stu-id="fdfb7-304">Yes</span></span>|<span data-ttu-id="fdfb7-305">否</span><span class="sxs-lookup"><span data-stu-id="fdfb7-305">No</span></span>|<span data-ttu-id="fdfb7-306">沒有資料列版本，但有 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-306">No row versions, but 14-byte overhead</span></span>|<span data-ttu-id="fdfb7-307">有資料列版本和 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-307">Row versions and 14-byte overhead</span></span>|  
    |<span data-ttu-id="fdfb7-308">是</span><span class="sxs-lookup"><span data-stu-id="fdfb7-308">Yes</span></span>|<span data-ttu-id="fdfb7-309">是</span><span class="sxs-lookup"><span data-stu-id="fdfb7-309">Yes</span></span>|<span data-ttu-id="fdfb7-310">有資料列版本和 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-310">Row versions and 14-byte overhead</span></span>|<span data-ttu-id="fdfb7-311">有資料列版本和 14 個位元組的負擔</span><span class="sxs-lookup"><span data-stu-id="fdfb7-311">Row versions and 14-byte overhead</span></span>|  
  
##  <a name="related-tasks"></a><a name="bkmk_RelatedTasks"></a> <span data-ttu-id="fdfb7-312">相關工作</span><span class="sxs-lookup"><span data-stu-id="fdfb7-312">Related Tasks</span></span>  
  
-   [<span data-ttu-id="fdfb7-313">設定可用性複本的唯讀存取 &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="fdfb7-313">Configure Read-Only Access on an Availability Replica &#40;SQL Server&#41;</span></span>](configure-read-only-access-on-an-availability-replica-sql-server.md)  
  
-   [<span data-ttu-id="fdfb7-314">設定可用性群組的唯讀路由 &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="fdfb7-314">Configure Read-Only Routing for an Availability Group &#40;SQL Server&#41;</span></span>](configure-read-only-routing-for-an-availability-group-sql-server.md)  
  
-   [<span data-ttu-id="fdfb7-315">建立或設定可用性群組接聽程式 &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="fdfb7-315">Create or Configure an Availability Group Listener &#40;SQL Server&#41;</span></span>](create-or-configure-an-availability-group-listener-sql-server.md)  
  
-   [<span data-ttu-id="fdfb7-316">監視可用性群組 &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="fdfb7-316">Monitor Availability Groups &#40;Transact-SQL&#41;</span></span>](monitor-availability-groups-transact-sql.md)  
  
-   [<span data-ttu-id="fdfb7-317">檢視可用性複本屬性 &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="fdfb7-317">View Availability Replica Properties &#40;SQL Server&#41;</span></span>](view-availability-replica-properties-sql-server.md)  
  
-   [<span data-ttu-id="fdfb7-318">使用新增可用性群組對話方塊 &#40;SQL Server Management Studio&#41;</span><span class="sxs-lookup"><span data-stu-id="fdfb7-318">Use the New Availability Group Dialog Box &#40;SQL Server Management Studio&#41;</span></span>](use-the-new-availability-group-dialog-box-sql-server-management-studio.md)  
  
##  <a name="related-content"></a><a name="RelatedContent"></a> <span data-ttu-id="fdfb7-319">相關內容</span><span class="sxs-lookup"><span data-stu-id="fdfb7-319">Related Content</span></span>  
  
-   [<span data-ttu-id="fdfb7-320">SQL Server AlwaysOn 團隊部落格：官方 SQL Server AlwaysOn 團隊部落格</span><span class="sxs-lookup"><span data-stu-id="fdfb7-320">SQL Server AlwaysOn Team Blog: The official SQL Server AlwaysOn Team Blog</span></span>](https://blogs.msdn.com/b/sqlalwayson/)  
  
## <a name="see-also"></a><span data-ttu-id="fdfb7-321">另請參閱</span><span class="sxs-lookup"><span data-stu-id="fdfb7-321">See Also</span></span>  
 <span data-ttu-id="fdfb7-322">[AlwaysOn 可用性群組 &#40;SQL Server 的總覽&#41;](overview-of-always-on-availability-groups-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="fdfb7-322">[Overview of AlwaysOn Availability Groups &#40;SQL Server&#41;](overview-of-always-on-availability-groups-sql-server.md) </span></span>  
 <span data-ttu-id="fdfb7-323">[關於可用性複本的用戶端連線存取 &#40;SQL Server&#41;](about-client-connection-access-to-availability-replicas-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="fdfb7-323">[About Client Connection Access to Availability Replicas &#40;SQL Server&#41;](about-client-connection-access-to-availability-replicas-sql-server.md) </span></span>  
 <span data-ttu-id="fdfb7-324">[可用性群組接聽程式、用戶端連接性及應用程式容錯移轉 &#40;SQL Server&#41;](../../listeners-client-connectivity-application-failover.md) </span><span class="sxs-lookup"><span data-stu-id="fdfb7-324">[Availability Group Listeners, Client Connectivity, and Application Failover &#40;SQL Server&#41;](../../listeners-client-connectivity-application-failover.md) </span></span>  
 [<span data-ttu-id="fdfb7-325">統計資料</span><span class="sxs-lookup"><span data-stu-id="fdfb7-325">Statistics</span></span>](../../../relational-databases/statistics/statistics.md)  
  
  
