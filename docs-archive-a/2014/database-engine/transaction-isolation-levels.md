---
title: 交易隔離等級的記憶體優化資料表 |Microsoft Docs
ms.custom: seo-dt-2019
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 8a6a82bf-273c-40ab-a101-46bd3615db8a
author: stevestein
ms.author: sstein
ms.openlocfilehash: 5ee0ba17dc999c9076ca4622d47db28b8200b851
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/04/2020
ms.locfileid: "87698473"
---
# <a name="transaction-isolation-levels-in-memory-optimized-tables"></a><span data-ttu-id="32ee5-102">記憶體優化資料表中的交易隔離等級</span><span class="sxs-lookup"><span data-stu-id="32ee5-102">Transaction Isolation Levels in memory-optimized tables</span></span>

  <span data-ttu-id="32ee5-103">存取記憶體最佳化的資料表的交易，可支援下列隔離等級。</span><span class="sxs-lookup"><span data-stu-id="32ee5-103">The following isolation levels are supported for transactions that access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="32ee5-104">SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="32ee5-104">SNAPSHOT</span></span>  
  
-   <span data-ttu-id="32ee5-105">REPEATABLE READ</span><span class="sxs-lookup"><span data-stu-id="32ee5-105">REPEATABLE READ</span></span>  
  
-   <span data-ttu-id="32ee5-106">SERIALIZABLE</span><span class="sxs-lookup"><span data-stu-id="32ee5-106">SERIALIZABLE</span></span>  
  
-   <span data-ttu-id="32ee5-107">READ COMMITTED</span><span class="sxs-lookup"><span data-stu-id="32ee5-107">READ COMMITTED</span></span>  
  
 <span data-ttu-id="32ee5-108">交易隔離等級可以指定為原生編譯預存程序之不可部分完成的區塊的一部分。</span><span class="sxs-lookup"><span data-stu-id="32ee5-108">The transaction isolation level can be specified as part of the atomic block of a natively compiled stored procedure.</span></span> <span data-ttu-id="32ee5-109">如需詳細資訊，請參閱 [CREATE PROCEDURE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-procedure-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="32ee5-109">For more information, see [CREATE PROCEDURE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-procedure-transact-sql).</span></span> <span data-ttu-id="32ee5-110">從解譯的 [!INCLUDE[tsql](../includes/tsql-md.md)] 存取記憶體最佳化的資料表時，可以使用資料表層級的提示指定隔離等級。</span><span class="sxs-lookup"><span data-stu-id="32ee5-110">When accessing memory-optimized tables from interpreted [!INCLUDE[tsql](../includes/tsql-md.md)], the isolation level can be specified using table-level hints.</span></span>  
  
 <span data-ttu-id="32ee5-111">當您定義原生編譯的預存程序時，必須指定交易隔離等級。</span><span class="sxs-lookup"><span data-stu-id="32ee5-111">You must specify the transaction isolation level when you define a natively compiled stored procedure.</span></span> <span data-ttu-id="32ee5-112">從解譯之 [!INCLUDE[tsql](../includes/tsql-md.md)] 中的使用者交易存取記憶體最佳化的資料表時，您必須在資料表提示中指定隔離等級。</span><span class="sxs-lookup"><span data-stu-id="32ee5-112">You must specify the isolation level in table hints when accessing memory-optimized tables from user transactions in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)].</span></span> <span data-ttu-id="32ee5-113">如需詳細資訊，請參閱[具有記憶體優化資料表的交易隔離等級方針](../relational-databases/in-memory-oltp/memory-optimized-tables.md)。</span><span class="sxs-lookup"><span data-stu-id="32ee5-113">For more information, see [Guidelines for Transaction Isolation Levels with Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="32ee5-114">包含自動認可交易之記憶體最佳化的資料表支援 READ COMMITTED 隔離等級。</span><span class="sxs-lookup"><span data-stu-id="32ee5-114">The isolation level READ COMMITTED is supported for memory-optimized tables with autocommit transactions.</span></span> <span data-ttu-id="32ee5-115">READ COMMITTED 在使用者交易或不可部分完成的區塊中無效。</span><span class="sxs-lookup"><span data-stu-id="32ee5-115">READ COMMITTED is not valid in user transactions or in an atomic block.</span></span> <span data-ttu-id="32ee5-116">明確或隱含使用者交易則不支援 READ COMMITTED。</span><span class="sxs-lookup"><span data-stu-id="32ee5-116">READ COMMITTED is not supported with explicit or implicit user transactions.</span></span> <span data-ttu-id="32ee5-117">包含自動認可交易的記憶體最佳化資料表可支援 READ_COMMITTED_SNAPSHOT 隔離等級，前提是查詢未存取任何以磁碟為基礎的資料表。</span><span class="sxs-lookup"><span data-stu-id="32ee5-117">Isolation level READ_COMMITTED_SNAPSHOT is supported for memory-optimized tables with autocommit transactions and only if the query does not access any disk-based tables.</span></span> <span data-ttu-id="32ee5-118">此外，搭配 SNAPSHOT 隔離使用解譯的 [!INCLUDE[tsql](../includes/tsql-md.md)] 所啟動的交易，無法存取記憶體最佳化的資料表。</span><span class="sxs-lookup"><span data-stu-id="32ee5-118">In addition, transactions that are started using interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] with SNAPSHOT isolation cannot access memory-optimized tables.</span></span> <span data-ttu-id="32ee5-119">搭配 REPEATABLE READ 或 SERIALIZABLE 隔離使用解譯的 [!INCLUDE[tsql](../includes/tsql-md.md)] 啟動的交易，必須使用 SNAPSHOT 隔離來存取記憶體最佳化的資料表。</span><span class="sxs-lookup"><span data-stu-id="32ee5-119">Transactions that are use interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] with either REPEATABLE READ or SERIALIZABLE isolation must access memory-optimized tables using SNAPSHOT isolation.</span></span> <span data-ttu-id="32ee5-120">如需此案例的詳細資訊，請參閱[跨容器交易](cross-container-transactions.md)。</span><span class="sxs-lookup"><span data-stu-id="32ee5-120">For more information about this scenario, see [Cross-Container Transactions](cross-container-transactions.md).</span></span>  
  
 <span data-ttu-id="32ee5-121">READ COMMITTED 是 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 的預設隔離等級。</span><span class="sxs-lookup"><span data-stu-id="32ee5-121">READ COMMITTED is the default isolation level in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="32ee5-122">當工作階段的隔離等級為 READ COMMITED (或更低) 時，您可以執行下列其中一個動作：</span><span class="sxs-lookup"><span data-stu-id="32ee5-122">When the isolation level of the session is READ COMMITED (or lower), you can do one of the following:</span></span>  
  
-   <span data-ttu-id="32ee5-123">明確使用存取記憶體最佳化資料表的較高的隔離等級提示 (例如，WITH (SNAPSHOT) )。</span><span class="sxs-lookup"><span data-stu-id="32ee5-123">Explicitly use a higher isolation level hint for accessing the memory-optimized table (for example, WITH (SNAPSHOT)).</span></span>  
  
-   <span data-ttu-id="32ee5-124">指定 `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT` 設定選項，可以將記憶體最佳化之資料表的隔離等級，設定為 SNAPSHOT (等同於在每個記憶體最佳化之資料表中加入 WITH(SNAPSHOT) 提示)。</span><span class="sxs-lookup"><span data-stu-id="32ee5-124">Specify the `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT` set option, which will set the isolation level for memory-optimized tables to SNAPSHOT (as if you included WITH(SNAPSHOT) hints to every memory-optimized table).</span></span> <span data-ttu-id="32ee5-125">如需的詳細資訊 `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT` ，請參閱[ALTER DATABASE SET 選項 &#40;transact-sql&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options)。</span><span class="sxs-lookup"><span data-stu-id="32ee5-125">For more information about `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT`, see [ALTER DATABASE SET Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options).</span></span>  
  
 <span data-ttu-id="32ee5-126">或者，如果工作階段的隔離等級為 READ COMMITTED，您可以使用自動認可交易。</span><span class="sxs-lookup"><span data-stu-id="32ee5-126">Alternatively, if the isolation level of the session is READ COMMITTED, you can use autocommit transactions.</span></span>  
  
 <span data-ttu-id="32ee5-127">在解譯的 [!INCLUDE[tsql](../includes/tsql-md.md)] 中啟動的 SNAPSHOT 交易無法存取記憶體最佳化資料表。</span><span class="sxs-lookup"><span data-stu-id="32ee5-127">SNAPSHOT transactions started in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] cannot access memory-optimized tables.</span></span>  
  
 <span data-ttu-id="32ee5-128">記憶體最佳化的資料表所支援的交易隔離等級，會提供與以磁碟為基礎之資料表相同的邏輯保證。</span><span class="sxs-lookup"><span data-stu-id="32ee5-128">The transaction isolation levels supported for memory-optimized tables provide the same logical guarantees as disk-based tables.</span></span> <span data-ttu-id="32ee5-129">用於提供隔離等級保證的機制則不同。</span><span class="sxs-lookup"><span data-stu-id="32ee5-129">The mechanism used for providing isolation level guarantees is different.</span></span>  
  
 <span data-ttu-id="32ee5-130">如果是以磁碟為基礎的資料表，大部分的隔離等級保證都會使用鎖定來實作，透過封鎖來避免衝突。</span><span class="sxs-lookup"><span data-stu-id="32ee5-130">For disk-based tables, most isolation level guarantees are implemented using locking, which prevent conflicts through blocking.</span></span> <span data-ttu-id="32ee5-131">如果是記憶體最佳化的資料表，則會使用衝突偵測機制來施行保證，以免需要進行鎖定。</span><span class="sxs-lookup"><span data-stu-id="32ee5-131">For memory-optimized tables, the guarantees are enforced using a conflict detection mechanism, which avoids the need to take locks.</span></span> <span data-ttu-id="32ee5-132">例外狀況是磁碟資料表上的 SNAPSHOT 隔離。</span><span class="sxs-lookup"><span data-stu-id="32ee5-132">The exception is SNAPSHOT isolation on disk-based tables.</span></span> <span data-ttu-id="32ee5-133">這個實作方式類似於在記憶體最佳化的資料表上使用衝突偵測機制的 SNAPSHOT 隔離。</span><span class="sxs-lookup"><span data-stu-id="32ee5-133">This is implemented similarly to SNAPSHOT isolation on memory-optimized tables using a conflict detection mechanism.</span></span>  
  
 <span data-ttu-id="32ee5-134">SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="32ee5-134">SNAPSHOT</span></span>  
 <span data-ttu-id="32ee5-135">這個隔離等級會指定交易中任何陳述式所讀取的資料，都是交易開始時就存在之資料的交易一致性版本。</span><span class="sxs-lookup"><span data-stu-id="32ee5-135">This isolation level specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction.</span></span> <span data-ttu-id="32ee5-136">交易只能辨識交易開始之前所認可的資料修改。</span><span class="sxs-lookup"><span data-stu-id="32ee5-136">The transaction can only recognize data modifications that were committed before the start of the transaction.</span></span> <span data-ttu-id="32ee5-137">在目前交易中執行的陳述式，看不到其他交易在目前交易開始之後所進行的資料修改。</span><span class="sxs-lookup"><span data-stu-id="32ee5-137">Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction.</span></span> <span data-ttu-id="32ee5-138">交易中的陳述式會取得已認可之資料的快照集，如同資料在交易開始時的狀態。</span><span class="sxs-lookup"><span data-stu-id="32ee5-138">The statements in a transaction get a snapshot of the committed data as it existed at the start of the transaction.</span></span>  
  
 <span data-ttu-id="32ee5-139">寫入作業 (更新、插入和刪除) 永遠都會與其他交易完全隔離。</span><span class="sxs-lookup"><span data-stu-id="32ee5-139">Write operations (updates, inserts and deletes) are always fully isolated from other transactions.</span></span> <span data-ttu-id="32ee5-140">因此，SNAPSHOT 交易中的寫入作業可能會與其他交易的寫入作業發生衝突。</span><span class="sxs-lookup"><span data-stu-id="32ee5-140">Therefore, the write operations in a SNAPSHOT transaction can conflict with write operations by other transactions.</span></span> <span data-ttu-id="32ee5-141">當目前交易嘗試更新或刪除目前交易開始之後由另一筆已認可的交易所更新或刪除的資料列時，此交易將會終止，並產生以下錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="32ee5-141">When the current transaction attempts to update or delete a row that has been updated or deleted by another transaction that committed after the current transaction started, the transaction terminates with the following error message.</span></span>  
  
 <span data-ttu-id="32ee5-142">錯誤 41302。</span><span class="sxs-lookup"><span data-stu-id="32ee5-142">Error 41302.</span></span> <span data-ttu-id="32ee5-143">目前交易嘗試更新自此交易啟動以來已經更新的資料表 X 記錄。</span><span class="sxs-lookup"><span data-stu-id="32ee5-143">The current transaction attempted to update a record in table X that has been updated since this transaction started.</span></span> <span data-ttu-id="32ee5-144">交易已中止。</span><span class="sxs-lookup"><span data-stu-id="32ee5-144">The transaction was aborted.</span></span>  
  
 <span data-ttu-id="32ee5-145">當目前交易嘗試插入之資料列的主索引鍵值與目前交易之前另一筆已認可的交易所插入的資料列相同時，將會認可失敗並產生下列錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="32ee5-145">When the current transaction attempts to insert a row with the same primary key value as a row that was inserted by another transaction that committed before the current transaction, there will be a failure to commit with the following error message.</span></span>  
  
 <span data-ttu-id="32ee5-146">錯誤41325。</span><span class="sxs-lookup"><span data-stu-id="32ee5-146">Error 41325.</span></span> <span data-ttu-id="32ee5-147">目前的交易無法認可，因為可序列化驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="32ee5-147">The current transaction failed to commit due to a serializable validation failure.</span></span>  
  
 <span data-ttu-id="32ee5-148">如果交易寫入的資料表在交易認可之前卸除，交易將會終止並產生下列錯誤訊息：</span><span class="sxs-lookup"><span data-stu-id="32ee5-148">If a transaction writes to a table that is dropped before the transaction commits, the transaction terminates with the following error message:</span></span>  
  
 <span data-ttu-id="32ee5-149">錯誤41305。</span><span class="sxs-lookup"><span data-stu-id="32ee5-149">Error 41305.</span></span> <span data-ttu-id="32ee5-150">目前的交易無法認可，因為可重複的讀取驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="32ee5-150">The current transaction failed to commit due to a repeatable read validation failure.</span></span>  
  
 <span data-ttu-id="32ee5-151">REPEATABLE READ</span><span class="sxs-lookup"><span data-stu-id="32ee5-151">REPEATABLE READ</span></span>  
 <span data-ttu-id="32ee5-152">此隔離等級包括 SNAPSHOT 隔離等級所提供的保證。</span><span class="sxs-lookup"><span data-stu-id="32ee5-152">This isolation level includes the guarantees given by SNAPSHOT isolation level.</span></span> <span data-ttu-id="32ee5-153">此外，REPEATABLE READ 保證，對於交易讀取的任何資料列而言，當認可交易時，另一筆交易尚未變更此資料列。</span><span class="sxs-lookup"><span data-stu-id="32ee5-153">In addition, REPEATABLE READ guarantees that for any row that is read by the transaction, at the time the transaction commits the row has not been changed by any other transaction.</span></span> <span data-ttu-id="32ee5-154">交易中的每個讀取作業都可重複，直到交易結束為止。</span><span class="sxs-lookup"><span data-stu-id="32ee5-154">Every read operation in the transaction is repeatable up to the end of the transaction.</span></span>  
  
 <span data-ttu-id="32ee5-155">如果目前交易已讀取在目前交易之前的另一筆已認可的交易所更新的任何資料列，則認可會失敗並出現下列錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="32ee5-155">If the current transaction has read any row that has then been updated by another transaction that has committed before the current transaction, the commit fails with the following error message.</span></span>  
  
 <span data-ttu-id="32ee5-156">錯誤41305。</span><span class="sxs-lookup"><span data-stu-id="32ee5-156">Error 41305.</span></span> <span data-ttu-id="32ee5-157">目前的交易無法認可，因為可重複的讀取驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="32ee5-157">The current transaction failed to commit due to a repeatable read validation failure.</span></span>  
  
 <span data-ttu-id="32ee5-158">SERIALIZABLE</span><span class="sxs-lookup"><span data-stu-id="32ee5-158">SERIALIZABLE</span></span>  
 <span data-ttu-id="32ee5-159">此隔離等級包括 REPEATABLE READ 所提供的保證。</span><span class="sxs-lookup"><span data-stu-id="32ee5-159">This isolation level includes the guarantees given by REPEATABLE READ.</span></span> <span data-ttu-id="32ee5-160">快照集和交易結束之間未出現任何虛設項目列。</span><span class="sxs-lookup"><span data-stu-id="32ee5-160">No phantom rows have appeared between the snapshot and the end of the transaction.</span></span> <span data-ttu-id="32ee5-161">虛設項目列符合選取、更新或刪除的篩選條件。</span><span class="sxs-lookup"><span data-stu-id="32ee5-161">Phantom rows match the filter condition of a select, update, or delete.</span></span>  
  
 <span data-ttu-id="32ee5-162">執行此交易時，就像是沒有並行交易一樣。</span><span class="sxs-lookup"><span data-stu-id="32ee5-162">The transaction is executed as if there are no concurrent transactions.</span></span> <span data-ttu-id="32ee5-163">所有動作幾乎都發生在單一序列化時間點 (認可時間)。</span><span class="sxs-lookup"><span data-stu-id="32ee5-163">All actions virtually occur at a single serialization point (commit time).</span></span>  
  
 <span data-ttu-id="32ee5-164">如果違反任何保證，便無法認可交易，而且會出現下列錯誤訊息：</span><span class="sxs-lookup"><span data-stu-id="32ee5-164">If any of these guarantees is violated, the transaction fails to commit with the following error message:</span></span>  
  
 <span data-ttu-id="32ee5-165">錯誤41325。</span><span class="sxs-lookup"><span data-stu-id="32ee5-165">Error 41325.</span></span> <span data-ttu-id="32ee5-166">目前的交易無法認可，因為可序列化驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="32ee5-166">The current transaction failed to commit due to a serializable validation failure.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="32ee5-167">另請參閱</span><span class="sxs-lookup"><span data-stu-id="32ee5-167">See Also</span></span>  
 <span data-ttu-id="32ee5-168">[瞭解記憶體優化資料表上的交易](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="32ee5-168">[Understanding Transactions on Memory-Optimized Tables](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span></span>  
 <span data-ttu-id="32ee5-169">[具有記憶體優化資料表的交易隔離等級方針](../relational-databases/in-memory-oltp/memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="32ee5-169">[Guidelines for Transaction Isolation Levels with Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md) </span></span>  
 [<span data-ttu-id="32ee5-170">記憶體最佳化資料表交易的重試邏輯方針</span><span class="sxs-lookup"><span data-stu-id="32ee5-170">Guidelines for Retry Logic for Transactions on Memory-Optimized Tables</span></span>](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md)  
  
  
